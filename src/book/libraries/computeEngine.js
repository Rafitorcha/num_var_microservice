/** CortexJS Compute Engine 0.23.0 */
(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ComputeEngine = {})); })(this, (function (exports) {
  'use strict';
  var ComputeEngine = (() => {
    var sl = Object.create; var wt = Object.defineProperty; var al = Object.getOwnPropertyDescriptor; var ul = Object.getOwnPropertyNames; var ll = Object.getPrototypeOf, fl = Object.prototype.hasOwnProperty; var dl = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports), cl = (e, n) => { for (var i in n) wt(e, i, { get: n[i], enumerable: !0 }) }, ys = (e, n, i, t) => { if (n && typeof n == "object" || typeof n == "function") for (let r of ul(n)) !fl.call(e, r) && r !== i && wt(e, r, { get: () => n[r], enumerable: !(t = al(n, r)) || t.enumerable }); return e }; var pe = (e, n, i) => (i = e != null ? sl(ll(e)) : {}, ys(n || !e || !e.__esModule ? wt(i, "default", { value: e, enumerable: !0 }) : i, e)), ml = e => ys(wt({}, "__esModule", { value: !0 }), e); var ce = dl((Hr, Es) => {
      (function (e) {
        "use strict"; var n = Math.cosh || function (l) { return Math.abs(l) < 1e-9 ? 1 - l : (Math.exp(l) + Math.exp(-l)) * .5 }, i = Math.sinh || function (l) { return Math.abs(l) < 1e-9 ? l : (Math.exp(l) - Math.exp(-l)) * .5 }, t = function (l) { var f = Math.PI / 4; if (-f > l || l > f) return Math.cos(l) - 1; var d = l * l; return d * (d * (d * (d * (d * (d * (d * (d / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2) }, r = function (l, f) { var d = Math.abs(l), c = Math.abs(f); return d < 3e3 && c < 3e3 ? Math.sqrt(d * d + c * c) : (d < c ? (d = c, c = l / f) : c = f / l, d * Math.sqrt(1 + c * c)) }, o = function () { throw SyntaxError("Invalid Param") }; function s(l, f) { var d = Math.abs(l), c = Math.abs(f); return l === 0 ? Math.log(c) : f === 0 ? Math.log(d) : d < 3e3 && c < 3e3 ? Math.log(l * l + f * f) * .5 : (l = l / 2, f = f / 2, .5 * Math.log(l * l + f * f) + Math.LN2) } var a = function (l, f) {
          var d = { re: 0, im: 0 }; if (l == null) d.re = d.im = 0; else if (f !== void 0) d.re = l, d.im = f; else switch (typeof l) {
            case "object": if ("im" in l && "re" in l) d.re = l.re, d.im = l.im; else if ("abs" in l && "arg" in l) { if (!Number.isFinite(l.abs) && Number.isFinite(l.arg)) return u.INFINITY; d.re = l.abs * Math.cos(l.arg), d.im = l.abs * Math.sin(l.arg) } else if ("r" in l && "phi" in l) { if (!Number.isFinite(l.r) && Number.isFinite(l.phi)) return u.INFINITY; d.re = l.r * Math.cos(l.phi), d.im = l.r * Math.sin(l.phi) } else l.length === 2 ? (d.re = l[0], d.im = l[1]) : o(); break; case "string": d.im = d.re = 0; var c = l.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g), m = 1, g = 0; c === null && o(); for (var h = 0; h < c.length; h++) {
              var x = c[h]; x === " " || x === "	" || x === `
`|| (x === "+" ? m++ : x === "-" ? g++ : x === "i" || x === "I" ? (m + g === 0 && o(), c[h + 1] !== " " && !isNaN(c[h + 1]) ? (d.im += parseFloat((g % 2 ? "-" : "") + c[h + 1]), h++) : d.im += parseFloat((g % 2 ? "-" : "") + "1"), m = g = 0) : ((m + g === 0 || isNaN(x)) && o(), c[h + 1] === "i" || c[h + 1] === "I" ? (d.im += parseFloat((g % 2 ? "-" : "") + x), h++) : d.re += parseFloat((g % 2 ? "-" : "") + x), m = g = 0))
            } m + g > 0 && o(); break; case "number": d.im = 0, d.re = l; break; default: o()
          }return isNaN(d.re) || isNaN(d.im), d
        }; function u(l, f) { if (!(this instanceof u)) return new u(l, f); var d = a(l, f); this.re = d.re, this.im = d.im } u.prototype = { re: 0, im: 0, sign: function () { var l = this.abs(); return new u(this.re / l, this.im / l) }, add: function (l, f) { var d = new u(l, f); return this.isInfinite() && d.isInfinite() ? u.NAN : this.isInfinite() || d.isInfinite() ? u.INFINITY : new u(this.re + d.re, this.im + d.im) }, sub: function (l, f) { var d = new u(l, f); return this.isInfinite() && d.isInfinite() ? u.NAN : this.isInfinite() || d.isInfinite() ? u.INFINITY : new u(this.re - d.re, this.im - d.im) }, mul: function (l, f) { var d = new u(l, f); return this.isInfinite() && d.isZero() || this.isZero() && d.isInfinite() ? u.NAN : this.isInfinite() || d.isInfinite() ? u.INFINITY : d.im === 0 && this.im === 0 ? new u(this.re * d.re, 0) : new u(this.re * d.re - this.im * d.im, this.re * d.im + this.im * d.re) }, div: function (l, f) { var d = new u(l, f); if (this.isZero() && d.isZero() || this.isInfinite() && d.isInfinite()) return u.NAN; if (this.isInfinite() || d.isZero()) return u.INFINITY; if (this.isZero() || d.isInfinite()) return u.ZERO; l = this.re, f = this.im; var c = d.re, m = d.im, g, h; return m === 0 ? new u(l / c, f / c) : Math.abs(c) < Math.abs(m) ? (h = c / m, g = c * h + m, new u((l * h + f) / g, (f * h - l) / g)) : (h = m / c, g = m * h + c, new u((l + f * h) / g, (f - l * h) / g)) }, pow: function (l, f) { var d = new u(l, f); if (l = this.re, f = this.im, d.isZero()) return u.ONE; if (d.im === 0) { if (f === 0 && l > 0) return new u(Math.pow(l, d.re), 0); if (l === 0) switch ((d.re % 4 + 4) % 4) { case 0: return new u(Math.pow(f, d.re), 0); case 1: return new u(0, Math.pow(f, d.re)); case 2: return new u(-Math.pow(f, d.re), 0); case 3: return new u(0, -Math.pow(f, d.re)) } } if (l === 0 && f === 0 && d.re > 0 && d.im >= 0) return u.ZERO; var c = Math.atan2(f, l), m = s(l, f); return l = Math.exp(d.re * m - d.im * c), f = d.im * m + d.re * c, new u(l * Math.cos(f), l * Math.sin(f)) }, sqrt: function () { var l = this.re, f = this.im, d = this.abs(), c, m; if (l >= 0) { if (f === 0) return new u(Math.sqrt(l), 0); c = .5 * Math.sqrt(2 * (d + l)) } else c = Math.abs(f) / Math.sqrt(2 * (d - l)); return l <= 0 ? m = .5 * Math.sqrt(2 * (d - l)) : m = Math.abs(f) / Math.sqrt(2 * (d + l)), new u(c, f < 0 ? -m : m) }, exp: function () { var l = Math.exp(this.re); return this.im, new u(l * Math.cos(this.im), l * Math.sin(this.im)) }, expm1: function () { var l = this.re, f = this.im; return new u(Math.expm1(l) * Math.cos(f) + t(f), Math.exp(l) * Math.sin(f)) }, log: function () { var l = this.re, f = this.im; return f === 0 && l > 0, new u(s(l, f), Math.atan2(f, l)) }, abs: function () { return r(this.re, this.im) }, arg: function () { return Math.atan2(this.im, this.re) }, sin: function () { var l = this.re, f = this.im; return new u(Math.sin(l) * n(f), Math.cos(l) * i(f)) }, cos: function () { var l = this.re, f = this.im; return new u(Math.cos(l) * n(f), -Math.sin(l) * i(f)) }, tan: function () { var l = 2 * this.re, f = 2 * this.im, d = Math.cos(l) + n(f); return new u(Math.sin(l) / d, i(f) / d) }, cot: function () { var l = 2 * this.re, f = 2 * this.im, d = Math.cos(l) - n(f); return new u(-Math.sin(l) / d, i(f) / d) }, sec: function () { var l = this.re, f = this.im, d = .5 * n(2 * f) + .5 * Math.cos(2 * l); return new u(Math.cos(l) * n(f) / d, Math.sin(l) * i(f) / d) }, csc: function () { var l = this.re, f = this.im, d = .5 * n(2 * f) - .5 * Math.cos(2 * l); return new u(Math.sin(l) * n(f) / d, -Math.cos(l) * i(f) / d) }, asin: function () { var l = this.re, f = this.im, d = new u(f * f - l * l + 1, -2 * l * f).sqrt(), c = new u(d.re - f, d.im + l).log(); return new u(c.im, -c.re) }, acos: function () { var l = this.re, f = this.im, d = new u(f * f - l * l + 1, -2 * l * f).sqrt(), c = new u(d.re - f, d.im + l).log(); return new u(Math.PI / 2 - c.im, c.re) }, atan: function () { var l = this.re, f = this.im; if (l === 0) { if (f === 1) return new u(0, 1 / 0); if (f === -1) return new u(0, -1 / 0) } var d = l * l + (1 - f) * (1 - f), c = new u((1 - f * f - l * l) / d, -2 * l / d).log(); return new u(-.5 * c.im, .5 * c.re) }, acot: function () { var l = this.re, f = this.im; if (f === 0) return new u(Math.atan2(1, l), 0); var d = l * l + f * f; return d !== 0 ? new u(l / d, -f / d).atan() : new u(l !== 0 ? l / 0 : 0, f !== 0 ? -f / 0 : 0).atan() }, asec: function () { var l = this.re, f = this.im; if (l === 0 && f === 0) return new u(0, 1 / 0); var d = l * l + f * f; return d !== 0 ? new u(l / d, -f / d).acos() : new u(l !== 0 ? l / 0 : 0, f !== 0 ? -f / 0 : 0).acos() }, acsc: function () { var l = this.re, f = this.im; if (l === 0 && f === 0) return new u(Math.PI / 2, 1 / 0); var d = l * l + f * f; return d !== 0 ? new u(l / d, -f / d).asin() : new u(l !== 0 ? l / 0 : 0, f !== 0 ? -f / 0 : 0).asin() }, sinh: function () { var l = this.re, f = this.im; return new u(i(l) * Math.cos(f), n(l) * Math.sin(f)) }, cosh: function () { var l = this.re, f = this.im; return new u(n(l) * Math.cos(f), i(l) * Math.sin(f)) }, tanh: function () { var l = 2 * this.re, f = 2 * this.im, d = n(l) + Math.cos(f); return new u(i(l) / d, Math.sin(f) / d) }, coth: function () { var l = 2 * this.re, f = 2 * this.im, d = n(l) - Math.cos(f); return new u(i(l) / d, -Math.sin(f) / d) }, csch: function () { var l = this.re, f = this.im, d = Math.cos(2 * f) - n(2 * l); return new u(-2 * i(l) * Math.cos(f) / d, 2 * n(l) * Math.sin(f) / d) }, sech: function () { var l = this.re, f = this.im, d = Math.cos(2 * f) + n(2 * l); return new u(2 * n(l) * Math.cos(f) / d, -2 * i(l) * Math.sin(f) / d) }, asinh: function () { var l = this.im; this.im = -this.re, this.re = l; var f = this.asin(); return this.re = -this.im, this.im = l, l = f.re, f.re = -f.im, f.im = l, f }, acosh: function () { var l = this.acos(); if (l.im <= 0) { var f = l.re; l.re = -l.im, l.im = f } else { var f = l.im; l.im = -l.re, l.re = f } return l }, atanh: function () { var l = this.re, f = this.im, d = l > 1 && f === 0, c = 1 - l, m = 1 + l, g = c * c + f * f, h = g !== 0 ? new u((m * c - f * f) / g, (f * c + m * f) / g) : new u(l !== -1 ? l / 0 : 0, f !== 0 ? f / 0 : 0), x = h.re; return h.re = s(h.re, h.im) / 2, h.im = Math.atan2(h.im, x) / 2, d && (h.im = -h.im), h }, acoth: function () { var l = this.re, f = this.im; if (l === 0 && f === 0) return new u(0, Math.PI / 2); var d = l * l + f * f; return d !== 0 ? new u(l / d, -f / d).atanh() : new u(l !== 0 ? l / 0 : 0, f !== 0 ? -f / 0 : 0).atanh() }, acsch: function () { var l = this.re, f = this.im; if (f === 0) return new u(l !== 0 ? Math.log(l + Math.sqrt(l * l + 1)) : 1 / 0, 0); var d = l * l + f * f; return d !== 0 ? new u(l / d, -f / d).asinh() : new u(l !== 0 ? l / 0 : 0, f !== 0 ? -f / 0 : 0).asinh() }, asech: function () { var l = this.re, f = this.im; if (this.isZero()) return u.INFINITY; var d = l * l + f * f; return d !== 0 ? new u(l / d, -f / d).acosh() : new u(l !== 0 ? l / 0 : 0, f !== 0 ? -f / 0 : 0).acosh() }, inverse: function () { if (this.isZero()) return u.INFINITY; if (this.isInfinite()) return u.ZERO; var l = this.re, f = this.im, d = l * l + f * f; return new u(l / d, -f / d) }, conjugate: function () { return new u(this.re, -this.im) }, neg: function () { return new u(-this.re, -this.im) }, ceil: function (l) { return l = Math.pow(10, l || 0), new u(Math.ceil(this.re * l) / l, Math.ceil(this.im * l) / l) }, floor: function (l) { return l = Math.pow(10, l || 0), new u(Math.floor(this.re * l) / l, Math.floor(this.im * l) / l) }, round: function (l) { return l = Math.pow(10, l || 0), new u(Math.round(this.re * l) / l, Math.round(this.im * l) / l) }, equals: function (l, f) { var d = new u(l, f); return Math.abs(d.re - this.re) <= u.EPSILON && Math.abs(d.im - this.im) <= u.EPSILON }, clone: function () { return new u(this.re, this.im) }, toString: function () { var l = this.re, f = this.im, d = ""; return this.isNaN() ? "NaN" : this.isInfinite() ? "Infinity" : (Math.abs(l) < u.EPSILON && (l = 0), Math.abs(f) < u.EPSILON && (f = 0), f === 0 ? d + l : (l !== 0 ? (d += l, d += " ", f < 0 ? (f = -f, d += "-") : d += "+", d += " ") : f < 0 && (f = -f, d += "-"), f !== 1 && (d += f), d + "i")) }, toVector: function () { return [this.re, this.im] }, valueOf: function () { return this.im === 0 ? this.re : null }, isNaN: function () { return isNaN(this.re) || isNaN(this.im) }, isZero: function () { return this.im === 0 && this.re === 0 }, isFinite: function () { return isFinite(this.re) && isFinite(this.im) }, isInfinite: function () { return !(this.isNaN() || this.isFinite()) } }, u.ZERO = new u(0, 0), u.ONE = new u(1, 0), u.I = new u(0, 1), u.PI = new u(Math.PI, 0), u.E = new u(Math.E, 0), u.INFINITY = new u(1 / 0, 1 / 0), u.NAN = new u(NaN, NaN), u.EPSILON = 1e-15, typeof define == "function" && define.amd ? define([], function () { return u }) : typeof Hr == "object" ? (Object.defineProperty(u, "__esModule", { value: !0 }), u.default = u, u.Complex = u, Es.exports = u) : e.Complex = u
      })(Hr)
    }); var Ud = {}; cl(Ud, { ADDITION_PRECEDENCE: () => re, ARROW_PRECEDENCE: () => sn, ASSIGNMENT_PRECEDENCE: () => di, COMPARISON_PRECEDENCE: () => A, ComputeEngine: () => ji, DIVISION_PRECEDENCE: () => an, EXPONENTIATION_PRECEDENCE: () => pl, MULTIPLICATION_PRECEDENCE: () => ze, POSTFIX_PRECEDENCE: () => Ct, isEnvironmentEntry: () => Zr, isExpressionEntry: () => Gr, isFunctionEntry: () => hl, isInfixEntry: () => Mt, isMatchfixEntry: () => ci, isPostfixEntry: () => At, isPrefixEntry: () => Zi, isSymbolEntry: () => jr, version: () => zd }); var A = 245, di = 260, sn = 270, re = 275, ze = 390, an = 600, pl = 700, Ct = 810; function Gr(e) { return !("kind" in e) || e.kind === "expression" } function jr(e) { return "kind" in e && e.kind === "symbol" } function hl(e) { return "kind" in e && e.kind === "function" } function ci(e) { return "kind" in e && e.kind === "matchfix" } function Mt(e) { return "kind" in e && e.kind === "infix" } function Zi(e) { return "kind" in e && e.kind === "prefix" } function At(e) { return "kind" in e && e.kind === "postfix" } function Zr(e) { return "kind" in e && e.kind === "environment" } var Gi = pe(ce(), 1); var mi = 9e15, Pn = 1e9, Jr = "0123456789abcdef", Pt = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", Ft = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", Wr = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -mi, maxE: mi, crypto: !1 }, Ss, En, C = !0, Lt = "[DecimalError] ", On = Lt + "Invalid argument: ", Ts = Lt + "Precision limit exceeded", Bs = Lt + "crypto unavailable", Ds = "[object Decimal]", ke = Math.floor, ye = Math.pow, gl = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, xl = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, bl = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, Is = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, Xe = 1e7, I = 7, yl = 9007199254740991, El = Pt.length - 1, Yr = Ft.length - 1, y = { toStringTag: Ds }; y.absoluteValue = y.abs = function () { var e = new this.constructor(this); return e.s < 0 && (e.s = 1), D(e) }; y.ceil = function () { return D(new this.constructor(this), this.e + 1, 2) }; y.clampedTo = y.clamp = function (e, n) { var i, t = this, r = t.constructor; if (e = new r(e), n = new r(n), !e.s || !n.s) return new r(NaN); if (e.gt(n)) throw Error(On + n); return i = t.cmp(e), i < 0 ? e : t.cmp(n) > 0 ? n : new r(t) }; y.comparedTo = y.cmp = function (e) { var n, i, t, r, o = this, s = o.d, a = (e = new o.constructor(e)).d, u = o.s, l = e.s; if (!s || !a) return !u || !l ? NaN : u !== l ? u : s === a ? 0 : !s ^ u < 0 ? 1 : -1; if (!s[0] || !a[0]) return s[0] ? u : a[0] ? -l : 0; if (u !== l) return u; if (o.e !== e.e) return o.e > e.e ^ u < 0 ? 1 : -1; for (t = s.length, r = a.length, n = 0, i = t < r ? t : r; n < i; ++n)if (s[n] !== a[n]) return s[n] > a[n] ^ u < 0 ? 1 : -1; return t === r ? 0 : t > r ^ u < 0 ? 1 : -1 }; y.cosine = y.cos = function () { var e, n, i = this, t = i.constructor; return i.d ? i.d[0] ? (e = t.precision, n = t.rounding, t.precision = e + Math.max(i.e, i.sd()) + I, t.rounding = 1, i = vl(t, As(t, i)), t.precision = e, t.rounding = n, D(En == 2 || En == 3 ? i.neg() : i, e, n, !0)) : new t(1) : new t(NaN) }; y.cubeRoot = y.cbrt = function () { var e, n, i, t, r, o, s, a, u, l, f = this, d = f.constructor; if (!f.isFinite() || f.isZero()) return new d(f); for (C = !1, o = f.s * ye(f.s * f, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (i = Te(f.d), e = f.e, (o = (e - i.length + 1) % 3) && (i += o == 1 || o == -2 ? "0" : "00"), o = ye(i, 1 / 3), e = ke((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? i = "5e" + e : (i = o.toExponential(), i = i.slice(0, i.indexOf("e") + 1) + e), t = new d(i), t.s = f.s) : t = new d(o.toString()), s = (e = d.precision) + 3; ;)if (a = t, u = a.times(a).times(a), l = u.plus(f), t = ee(l.plus(f).times(a), l.plus(u), s + 2, 1), Te(a.d).slice(0, s) === (i = Te(t.d)).slice(0, s)) if (i = i.slice(s - 3, s + 1), i == "9999" || !r && i == "4999") { if (!r && (D(a, e + 1, 0), a.times(a).times(a).eq(f))) { t = a; break } s += 4, r = 1 } else { (!+i || !+i.slice(1) && i.charAt(0) == "5") && (D(t, e + 1, 1), n = !t.times(t).times(t).eq(f)); break } return C = !0, D(t, e, d.rounding, n) }; y.decimalPlaces = y.dp = function () { var e, n = this.d, i = NaN; if (n) { if (e = n.length - 1, i = (e - ke(this.e / I)) * I, e = n[e], e) for (; e % 10 == 0; e /= 10)i--; i < 0 && (i = 0) } return i }; y.dividedBy = y.div = function (e) { return ee(this, new this.constructor(e)) }; y.dividedToIntegerBy = y.divToInt = function (e) { var n = this, i = n.constructor; return D(ee(n, new i(e), 0, 1, 1), i.precision, i.rounding) }; y.equals = y.eq = function (e) { return this.cmp(e) === 0 }; y.floor = function () { return D(new this.constructor(this), this.e + 1, 3) }; y.greaterThan = y.gt = function (e) { return this.cmp(e) > 0 }; y.greaterThanOrEqualTo = y.gte = function (e) { var n = this.cmp(e); return n == 1 || n === 0 }; y.hyperbolicCosine = y.cosh = function () { var e, n, i, t, r, o = this, s = o.constructor, a = new s(1); if (!o.isFinite()) return new s(o.s ? 1 / 0 : NaN); if (o.isZero()) return a; i = s.precision, t = s.rounding, s.precision = i + Math.max(o.e, o.sd()) + 4, s.rounding = 1, r = o.d.length, r < 32 ? (e = Math.ceil(r / 3), n = (1 / Vt(4, e)).toString()) : (e = 16, n = "2.3283064365386962890625e-10"), o = pi(s, 1, o.times(n), new s(1), !0); for (var u, l = e, f = new s(8); l--;)u = o.times(o), o = a.minus(u.times(f.minus(u.times(f)))); return D(o, s.precision = i, s.rounding = t, !0) }; y.hyperbolicSine = y.sinh = function () { var e, n, i, t, r = this, o = r.constructor; if (!r.isFinite() || r.isZero()) return new o(r); if (n = o.precision, i = o.rounding, o.precision = n + Math.max(r.e, r.sd()) + 4, o.rounding = 1, t = r.d.length, t < 3) r = pi(o, 2, r, r, !0); else { e = 1.4 * Math.sqrt(t), e = e > 16 ? 16 : e | 0, r = r.times(1 / Vt(5, e)), r = pi(o, 2, r, r, !0); for (var s, a = new o(5), u = new o(16), l = new o(20); e--;)s = r.times(r), r = r.times(a.plus(s.times(u.times(s).plus(l)))) } return o.precision = n, o.rounding = i, D(r, n, i, !0) }; y.hyperbolicTangent = y.tanh = function () { var e, n, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + 7, t.rounding = 1, ee(i.sinh(), i.cosh(), t.precision = e, t.rounding = n)) : new t(i.s) }; y.inverseCosine = y.acos = function () { var e, n = this, i = n.constructor, t = n.abs().cmp(1), r = i.precision, o = i.rounding; return t !== -1 ? t === 0 ? n.isNeg() ? Qe(i, r, o) : new i(0) : new i(NaN) : n.isZero() ? Qe(i, r + 4, o).times(.5) : (i.precision = r + 6, i.rounding = 1, n = n.asin(), e = Qe(i, r + 4, o).times(.5), i.precision = r, i.rounding = o, e.minus(n)) }; y.inverseHyperbolicCosine = y.acosh = function () { var e, n, i = this, t = i.constructor; return i.lte(1) ? new t(i.eq(1) ? 0 : NaN) : i.isFinite() ? (e = t.precision, n = t.rounding, t.precision = e + Math.max(Math.abs(i.e), i.sd()) + 4, t.rounding = 1, C = !1, i = i.times(i).minus(1).sqrt().plus(i), C = !0, t.precision = e, t.rounding = n, i.ln()) : new t(i) }; y.inverseHyperbolicSine = y.asinh = function () { var e, n, i = this, t = i.constructor; return !i.isFinite() || i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + 2 * Math.max(Math.abs(i.e), i.sd()) + 6, t.rounding = 1, C = !1, i = i.times(i).plus(1).sqrt().plus(i), C = !0, t.precision = e, t.rounding = n, i.ln()) }; y.inverseHyperbolicTangent = y.atanh = function () { var e, n, i, t, r = this, o = r.constructor; return r.isFinite() ? r.e >= 0 ? new o(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (e = o.precision, n = o.rounding, t = r.sd(), Math.max(t, e) < 2 * -r.e - 1 ? D(new o(r), e, n, !0) : (o.precision = i = t - r.e, r = ee(r.plus(1), new o(1).minus(r), i + e, 1), o.precision = e + 4, o.rounding = 1, r = r.ln(), o.precision = e, o.rounding = n, r.times(.5))) : new o(NaN) }; y.inverseSine = y.asin = function () { var e, n, i, t, r = this, o = r.constructor; return r.isZero() ? new o(r) : (n = r.abs().cmp(1), i = o.precision, t = o.rounding, n !== -1 ? n === 0 ? (e = Qe(o, i + 4, t).times(.5), e.s = r.s, e) : new o(NaN) : (o.precision = i + 6, o.rounding = 1, r = r.div(new o(1).minus(r.times(r)).sqrt().plus(1)).atan(), o.precision = i, o.rounding = t, r.times(2))) }; y.inverseTangent = y.atan = function () { var e, n, i, t, r, o, s, a, u, l = this, f = l.constructor, d = f.precision, c = f.rounding; if (l.isFinite()) { if (l.isZero()) return new f(l); if (l.abs().eq(1) && d + 4 <= Yr) return s = Qe(f, d + 4, c).times(.25), s.s = l.s, s } else { if (!l.s) return new f(NaN); if (d + 4 <= Yr) return s = Qe(f, d + 4, c).times(.5), s.s = l.s, s } for (f.precision = a = d + 10, f.rounding = 1, i = Math.min(28, a / I + 2 | 0), e = i; e; --e)l = l.div(l.times(l).plus(1).sqrt().plus(1)); for (C = !1, n = Math.ceil(a / I), t = 1, u = l.times(l), s = new f(l), r = l; e !== -1;)if (r = r.times(u), o = s.minus(r.div(t += 2)), r = r.times(u), s = o.plus(r.div(t += 2)), s.d[n] !== void 0) for (e = n; s.d[e] === o.d[e] && e--;); return i && (s = s.times(2 << i - 1)), C = !0, D(s, f.precision = d, f.rounding = c, !0) }; y.isFinite = function () { return !!this.d }; y.isInteger = y.isInt = function () { return !!this.d && ke(this.e / I) > this.d.length - 2 }; y.isNaN = function () { return !this.s }; y.isNegative = y.isNeg = function () { return this.s < 0 }; y.isPositive = y.isPos = function () { return this.s > 0 }; y.isZero = function () { return !!this.d && this.d[0] === 0 }; y.lessThan = y.lt = function (e) { return this.cmp(e) < 0 }; y.lessThanOrEqualTo = y.lte = function (e) { return this.cmp(e) < 1 }; y.logarithm = y.log = function (e) { var n, i, t, r, o, s, a, u, l = this, f = l.constructor, d = f.precision, c = f.rounding, m = 5; if (e == null) e = new f(10), n = !0; else { if (e = new f(e), i = e.d, e.s < 0 || !i || !i[0] || e.eq(1)) return new f(NaN); n = e.eq(10) } if (i = l.d, l.s < 0 || !i || !i[0] || l.eq(1)) return new f(i && !i[0] ? -1 / 0 : l.s != 1 ? NaN : i ? 0 : 1 / 0); if (n) if (i.length > 1) o = !0; else { for (r = i[0]; r % 10 === 0;)r /= 10; o = r !== 1 } if (C = !1, a = d + m, s = An(l, a), t = n ? Rt(f, a + 10) : An(e, a), u = ee(s, t, a, 1), Hi(u.d, r = d, c)) do if (a += 10, s = An(l, a), t = n ? Rt(f, a + 10) : An(e, a), u = ee(s, t, a, 1), !o) { +Te(u.d).slice(r + 1, r + 15) + 1 == 1e14 && (u = D(u, d + 1, 0)); break } while (Hi(u.d, r += 10, c)); return C = !0, D(u, d, c) }; y.minus = y.sub = function (e) { var n, i, t, r, o, s, a, u, l, f, d, c, m = this, g = m.constructor; if (e = new g(e), !m.d || !e.d) return !m.s || !e.s ? e = new g(NaN) : m.d ? e.s = -e.s : e = new g(e.d || m.s !== e.s ? m : NaN), e; if (m.s != e.s) return e.s = -e.s, m.plus(e); if (l = m.d, c = e.d, a = g.precision, u = g.rounding, !l[0] || !c[0]) { if (c[0]) e.s = -e.s; else if (l[0]) e = new g(m); else return new g(u === 3 ? -0 : 0); return C ? D(e, a, u) : e } if (i = ke(e.e / I), f = ke(m.e / I), l = l.slice(), o = f - i, o) { for (d = o < 0, d ? (n = l, o = -o, s = c.length) : (n = c, i = f, s = l.length), t = Math.max(Math.ceil(a / I), s) + 2, o > t && (o = t, n.length = 1), n.reverse(), t = o; t--;)n.push(0); n.reverse() } else { for (t = l.length, s = c.length, d = t < s, d && (s = t), t = 0; t < s; t++)if (l[t] != c[t]) { d = l[t] < c[t]; break } o = 0 } for (d && (n = l, l = c, c = n, e.s = -e.s), s = l.length, t = c.length - s; t > 0; --t)l[s++] = 0; for (t = c.length; t > o;) { if (l[--t] < c[t]) { for (r = t; r && l[--r] === 0;)l[r] = Xe - 1; --l[r], l[t] += Xe } l[t] -= c[t] } for (; l[--s] === 0;)l.pop(); for (; l[0] === 0; l.shift())--i; return l[0] ? (e.d = l, e.e = qt(l, i), C ? D(e, a, u) : e) : new g(u === 3 ? -0 : 0) }; y.modulo = y.mod = function (e) { var n, i = this, t = i.constructor; return e = new t(e), !i.d || !e.s || e.d && !e.d[0] ? new t(NaN) : !e.d || i.d && !i.d[0] ? D(new t(i), t.precision, t.rounding) : (C = !1, t.modulo == 9 ? (n = ee(i, e.abs(), 0, 3, 1), n.s *= e.s) : n = ee(i, e, 0, t.modulo, 1), n = n.times(e), C = !0, i.minus(n)) }; y.naturalExponential = y.exp = function () { return Qr(this) }; y.naturalLogarithm = y.ln = function () { return An(this) }; y.negated = y.neg = function () { var e = new this.constructor(this); return e.s = -e.s, D(e) }; y.plus = y.add = function (e) { var n, i, t, r, o, s, a, u, l, f, d = this, c = d.constructor; if (e = new c(e), !d.d || !e.d) return !d.s || !e.s ? e = new c(NaN) : d.d || (e = new c(e.d || d.s === e.s ? d : NaN)), e; if (d.s != e.s) return e.s = -e.s, d.minus(e); if (l = d.d, f = e.d, a = c.precision, u = c.rounding, !l[0] || !f[0]) return f[0] || (e = new c(d)), C ? D(e, a, u) : e; if (o = ke(d.e / I), t = ke(e.e / I), l = l.slice(), r = o - t, r) { for (r < 0 ? (i = l, r = -r, s = f.length) : (i = f, t = o, s = l.length), o = Math.ceil(a / I), s = o > s ? o + 1 : s + 1, r > s && (r = s, i.length = 1), i.reverse(); r--;)i.push(0); i.reverse() } for (s = l.length, r = f.length, s - r < 0 && (r = s, i = f, f = l, l = i), n = 0; r;)n = (l[--r] = l[r] + f[r] + n) / Xe | 0, l[r] %= Xe; for (n && (l.unshift(n), ++t), s = l.length; l[--s] == 0;)l.pop(); return e.d = l, e.e = qt(l, t), C ? D(e, a, u) : e }; y.precision = y.sd = function (e) { var n, i = this; if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(On + e); return i.d ? (n = ks(i.d), e && i.e + 1 > n && (n = i.e + 1)) : n = NaN, n }; y.round = function () { var e = this, n = e.constructor; return D(new n(e), e.e + 1, n.rounding) }; y.sine = y.sin = function () { var e, n, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + Math.max(i.e, i.sd()) + I, t.rounding = 1, i = _l(t, As(t, i)), t.precision = e, t.rounding = n, D(En > 2 ? i.neg() : i, e, n, !0)) : new t(NaN) }; y.squareRoot = y.sqrt = function () { var e, n, i, t, r, o, s = this, a = s.d, u = s.e, l = s.s, f = s.constructor; if (l !== 1 || !a || !a[0]) return new f(!l || l < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0); for (C = !1, l = Math.sqrt(+s), l == 0 || l == 1 / 0 ? (n = Te(a), (n.length + u) % 2 == 0 && (n += "0"), l = Math.sqrt(n), u = ke((u + 1) / 2) - (u < 0 || u % 2), l == 1 / 0 ? n = "5e" + u : (n = l.toExponential(), n = n.slice(0, n.indexOf("e") + 1) + u), t = new f(n)) : t = new f(l.toString()), i = (u = f.precision) + 3; ;)if (o = t, t = o.plus(ee(s, o, i + 2, 1)).times(.5), Te(o.d).slice(0, i) === (n = Te(t.d)).slice(0, i)) if (n = n.slice(i - 3, i + 1), n == "9999" || !r && n == "4999") { if (!r && (D(o, u + 1, 0), o.times(o).eq(s))) { t = o; break } i += 4, r = 1 } else { (!+n || !+n.slice(1) && n.charAt(0) == "5") && (D(t, u + 1, 1), e = !t.times(t).eq(s)); break } return C = !0, D(t, u, f.rounding, e) }; y.tangent = y.tan = function () { var e, n, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + 10, t.rounding = 1, i = i.sin(), i.s = 1, i = ee(i, new t(1).minus(i.times(i)).sqrt(), e + 10, 0), t.precision = e, t.rounding = n, D(En == 2 || En == 4 ? i.neg() : i, e, n, !0)) : new t(NaN) }; y.times = y.mul = function (e) { var n, i, t, r, o, s, a, u, l, f = this, d = f.constructor, c = f.d, m = (e = new d(e)).d; if (e.s *= f.s, !c || !c[0] || !m || !m[0]) return new d(!e.s || c && !c[0] && !m || m && !m[0] && !c ? NaN : !c || !m ? e.s / 0 : e.s * 0); for (i = ke(f.e / I) + ke(e.e / I), u = c.length, l = m.length, u < l && (o = c, c = m, m = o, s = u, u = l, l = s), o = [], s = u + l, t = s; t--;)o.push(0); for (t = l; --t >= 0;) { for (n = 0, r = u + t; r > t;)a = o[r] + m[t] * c[r - t - 1] + n, o[r--] = a % Xe | 0, n = a / Xe | 0; o[r] = (o[r] + n) % Xe | 0 } for (; !o[--s];)o.pop(); return n ? ++i : o.shift(), e.d = o, e.e = qt(o, i), C ? D(e, d.precision, d.rounding) : e }; y.toBinary = function (e, n) { return Kr(this, 2, e, n) }; y.toDecimalPlaces = y.toDP = function (e, n) { var i = this, t = i.constructor; return i = new t(i), e === void 0 ? i : (Me(e, 0, Pn), n === void 0 ? n = t.rounding : Me(n, 0, 8), D(i, e + i.e + 1, n)) }; y.toExponential = function (e, n) { var i, t = this, r = t.constructor; return e === void 0 ? i = un(t, !0) : (Me(e, 0, Pn), n === void 0 ? n = r.rounding : Me(n, 0, 8), t = D(new r(t), e + 1, n), i = un(t, !0, e + 1)), t.isNeg() && !t.isZero() ? "-" + i : i }; y.toFixed = function (e, n) { var i, t, r = this, o = r.constructor; return e === void 0 ? i = un(r) : (Me(e, 0, Pn), n === void 0 ? n = o.rounding : Me(n, 0, 8), t = D(new o(r), e + r.e + 1, n), i = un(t, !1, e + t.e + 1)), r.isNeg() && !r.isZero() ? "-" + i : i }; y.toFraction = function (e) { var n, i, t, r, o, s, a, u, l, f, d, c, m = this, g = m.d, h = m.constructor; if (!g) return new h(m); if (l = i = new h(1), t = u = new h(0), n = new h(t), o = n.e = ks(g) - m.e - 1, s = o % I, n.d[0] = ye(10, s < 0 ? I + s : s), e == null) e = o > 0 ? n : l; else { if (a = new h(e), !a.isInt() || a.lt(l)) throw Error(On + a); e = a.gt(n) ? o > 0 ? n : l : a } for (C = !1, a = new h(Te(g)), f = h.precision, h.precision = o = g.length * I * 2; d = ee(a, n, 0, 1, 1), r = i.plus(d.times(t)), r.cmp(e) != 1;)i = t, t = r, r = l, l = u.plus(d.times(r)), u = r, r = n, n = a.minus(d.times(r)), a = r; return r = ee(e.minus(i), t, 0, 1, 1), u = u.plus(r.times(l)), i = i.plus(r.times(t)), u.s = l.s = m.s, c = ee(l, t, o, 1).minus(m).abs().cmp(ee(u, i, o, 1).minus(m).abs()) < 1 ? [l, t] : [u, i], h.precision = f, C = !0, c }; y.toHexadecimal = y.toHex = function (e, n) { return Kr(this, 16, e, n) }; y.toNearest = function (e, n) { var i = this, t = i.constructor; if (i = new t(i), e == null) { if (!i.d) return i; e = new t(1), n = t.rounding } else { if (e = new t(e), n === void 0 ? n = t.rounding : Me(n, 0, 8), !i.d) return e.s ? i : e; if (!e.d) return e.s && (e.s = i.s), e } return e.d[0] ? (C = !1, i = ee(i, e, 0, n, 1).times(e), C = !0, D(i)) : (e.s = i.s, i = e), i }; y.toNumber = function () { return +this }; y.toOctal = function (e, n) { return Kr(this, 8, e, n) }; y.toPower = y.pow = function (e) { var n, i, t, r, o, s, a = this, u = a.constructor, l = +(e = new u(e)); if (!a.d || !e.d || !a.d[0] || !e.d[0]) return new u(ye(+a, l)); if (a = new u(a), a.eq(1)) return a; if (t = u.precision, o = u.rounding, e.eq(1)) return D(a, t, o); if (n = ke(e.e / I), n >= e.d.length - 1 && (i = l < 0 ? -l : l) <= yl) return r = ws(u, a, i, t), e.s < 0 ? new u(1).div(r) : D(r, t, o); if (s = a.s, s < 0) { if (n < e.d.length - 1) return new u(NaN); if (e.d[n] & 1 || (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1) return a.s = s, a } return i = ye(+a, l), n = i == 0 || !isFinite(i) ? ke(l * (Math.log("0." + Te(a.d)) / Math.LN10 + a.e + 1)) : new u(i + "").e, n > u.maxE + 1 || n < u.minE - 1 ? new u(n > 0 ? s / 0 : 0) : (C = !1, u.rounding = a.s = 1, i = Math.min(12, (n + "").length), r = Qr(e.times(An(a, t + i)), t), r.d && (r = D(r, t + 5, 1), Hi(r.d, t, o) && (n = t + 10, r = D(Qr(e.times(An(a, n + i)), n), n + 5, 1), +Te(r.d).slice(t + 1, t + 15) + 1 == 1e14 && (r = D(r, t + 1, 0)))), r.s = s, C = !0, u.rounding = o, D(r, t, o)) }; y.toPrecision = function (e, n) { var i, t = this, r = t.constructor; return e === void 0 ? i = un(t, t.e <= r.toExpNeg || t.e >= r.toExpPos) : (Me(e, 1, Pn), n === void 0 ? n = r.rounding : Me(n, 0, 8), t = D(new r(t), e, n), i = un(t, e <= t.e || t.e <= r.toExpNeg, e)), t.isNeg() && !t.isZero() ? "-" + i : i }; y.toSignificantDigits = y.toSD = function (e, n) { var i = this, t = i.constructor; return e === void 0 ? (e = t.precision, n = t.rounding) : (Me(e, 1, Pn), n === void 0 ? n = t.rounding : Me(n, 0, 8)), D(new t(i), e, n) }; y.toString = function () { var e = this, n = e.constructor, i = un(e, e.e <= n.toExpNeg || e.e >= n.toExpPos); return e.isNeg() && !e.isZero() ? "-" + i : i }; y.truncated = y.trunc = function () { return D(new this.constructor(this), this.e + 1, 1) }; y.valueOf = y.toJSON = function () { var e = this, n = e.constructor, i = un(e, e.e <= n.toExpNeg || e.e >= n.toExpPos); return e.isNeg() ? "-" + i : i }; function Te(e) { var n, i, t, r = e.length - 1, o = "", s = e[0]; if (r > 0) { for (o += s, n = 1; n < r; n++)t = e[n] + "", i = I - t.length, i && (o += Mn(i)), o += t; s = e[n], t = s + "", i = I - t.length, i && (o += Mn(i)) } else if (s === 0) return "0"; for (; s % 10 === 0;)s /= 10; return o + s } function Me(e, n, i) { if (e !== ~~e || e < n || e > i) throw Error(On + e) } function Hi(e, n, i, t) { var r, o, s, a; for (o = e[0]; o >= 10; o /= 10)--n; return --n < 0 ? (n += I, r = 0) : (r = Math.ceil((n + 1) / I), n %= I), o = ye(10, I - n), a = e[r] % o | 0, t == null ? n < 3 ? (n == 0 ? a = a / 100 | 0 : n == 1 && (a = a / 10 | 0), s = i < 4 && a == 99999 || i > 3 && a == 49999 || a == 5e4 || a == 0) : s = (i < 4 && a + 1 == o || i > 3 && a + 1 == o / 2) && (e[r + 1] / o / 100 | 0) == ye(10, n - 2) - 1 || (a == o / 2 || a == 0) && (e[r + 1] / o / 100 | 0) == 0 : n < 4 ? (n == 0 ? a = a / 1e3 | 0 : n == 1 ? a = a / 100 | 0 : n == 2 && (a = a / 10 | 0), s = (t || i < 4) && a == 9999 || !t && i > 3 && a == 4999) : s = ((t || i < 4) && a + 1 == o || !t && i > 3 && a + 1 == o / 2) && (e[r + 1] / o / 1e3 | 0) == ye(10, n - 3) - 1, s } function Ot(e, n, i) { for (var t, r = [0], o, s = 0, a = e.length; s < a;) { for (o = r.length; o--;)r[o] *= n; for (r[0] += Jr.indexOf(e.charAt(s++)), t = 0; t < r.length; t++)r[t] > i - 1 && (r[t + 1] === void 0 && (r[t + 1] = 0), r[t + 1] += r[t] / i | 0, r[t] %= i) } return r.reverse() } function vl(e, n) { var i, t, r; if (n.isZero()) return n; t = n.d.length, t < 32 ? (i = Math.ceil(t / 3), r = (1 / Vt(4, i)).toString()) : (i = 16, r = "2.3283064365386962890625e-10"), e.precision += i, n = pi(e, 1, n.times(r), new e(1)); for (var o = i; o--;) { var s = n.times(n); n = s.times(s).minus(s).times(8).plus(1) } return e.precision -= i, n } var ee = function () { function e(t, r, o) { var s, a = 0, u = t.length; for (t = t.slice(); u--;)s = t[u] * r + a, t[u] = s % o | 0, a = s / o | 0; return a && t.unshift(a), t } function n(t, r, o, s) { var a, u; if (o != s) u = o > s ? 1 : -1; else for (a = u = 0; a < o; a++)if (t[a] != r[a]) { u = t[a] > r[a] ? 1 : -1; break } return u } function i(t, r, o, s) { for (var a = 0; o--;)t[o] -= a, a = t[o] < r[o] ? 1 : 0, t[o] = a * s + t[o] - r[o]; for (; !t[0] && t.length > 1;)t.shift() } return function (t, r, o, s, a, u) { var l, f, d, c, m, g, h, x, S, T, _, w, j, Z, De, $e, Ce, zr, Ye, It, kt = t.constructor, Ur = t.s == r.s ? 1 : -1, Ie = t.d, ne = r.d; if (!Ie || !Ie[0] || !ne || !ne[0]) return new kt(!t.s || !r.s || (Ie ? ne && Ie[0] == ne[0] : !ne) ? NaN : Ie && Ie[0] == 0 || !ne ? Ur * 0 : Ur / 0); for (u ? (m = 1, f = t.e - r.e) : (u = Xe, m = I, f = ke(t.e / m) - ke(r.e / m)), Ye = ne.length, Ce = Ie.length, S = new kt(Ur), T = S.d = [], d = 0; ne[d] == (Ie[d] || 0); d++); if (ne[d] > (Ie[d] || 0) && f--, o == null ? (Z = o = kt.precision, s = kt.rounding) : a ? Z = o + (t.e - r.e) + 1 : Z = o, Z < 0) T.push(1), g = !0; else { if (Z = Z / m + 2 | 0, d = 0, Ye == 1) { for (c = 0, ne = ne[0], Z++; (d < Ce || c) && Z--; d++)De = c * u + (Ie[d] || 0), T[d] = De / ne | 0, c = De % ne | 0; g = c || d < Ce } else { for (c = u / (ne[0] + 1) | 0, c > 1 && (ne = e(ne, c, u), Ie = e(Ie, c, u), Ye = ne.length, Ce = Ie.length), $e = Ye, _ = Ie.slice(0, Ye), w = _.length; w < Ye;)_[w++] = 0; It = ne.slice(), It.unshift(0), zr = ne[0], ne[1] >= u / 2 && ++zr; do c = 0, l = n(ne, _, Ye, w), l < 0 ? (j = _[0], Ye != w && (j = j * u + (_[1] || 0)), c = j / zr | 0, c > 1 ? (c >= u && (c = u - 1), h = e(ne, c, u), x = h.length, w = _.length, l = n(h, _, x, w), l == 1 && (c--, i(h, Ye < x ? It : ne, x, u))) : (c == 0 && (l = c = 1), h = ne.slice()), x = h.length, x < w && h.unshift(0), i(_, h, w, u), l == -1 && (w = _.length, l = n(ne, _, Ye, w), l < 1 && (c++, i(_, Ye < w ? It : ne, w, u))), w = _.length) : l === 0 && (c++, _ = [0]), T[d++] = c, l && _[0] ? _[w++] = Ie[$e] || 0 : (_ = [Ie[$e]], w = 1); while (($e++ < Ce || _[0] !== void 0) && Z--); g = _[0] !== void 0 } T[0] || T.shift() } if (m == 1) S.e = f, Ss = g; else { for (d = 1, c = T[0]; c >= 10; c /= 10)d++; S.e = d + f * m - 1, D(S, a ? o + S.e + 1 : o, s, g) } return S } }(); function D(e, n, i, t) { var r, o, s, a, u, l, f, d, c, m = e.constructor; e: if (n != null) { if (d = e.d, !d) return e; for (r = 1, a = d[0]; a >= 10; a /= 10)r++; if (o = n - r, o < 0) o += I, s = n, f = d[c = 0], u = f / ye(10, r - s - 1) % 10 | 0; else if (c = Math.ceil((o + 1) / I), a = d.length, c >= a) if (t) { for (; a++ <= c;)d.push(0); f = u = 0, r = 1, o %= I, s = o - I + 1 } else break e; else { for (f = a = d[c], r = 1; a >= 10; a /= 10)r++; o %= I, s = o - I + r, u = s < 0 ? 0 : f / ye(10, r - s - 1) % 10 | 0 } if (t = t || n < 0 || d[c + 1] !== void 0 || (s < 0 ? f : f % ye(10, r - s - 1)), l = i < 4 ? (u || t) && (i == 0 || i == (e.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (i == 4 || t || i == 6 && (o > 0 ? s > 0 ? f / ye(10, r - s) : 0 : d[c - 1]) % 10 & 1 || i == (e.s < 0 ? 8 : 7)), n < 1 || !d[0]) return d.length = 0, l ? (n -= e.e + 1, d[0] = ye(10, (I - n % I) % I), e.e = -n || 0) : d[0] = e.e = 0, e; if (o == 0 ? (d.length = c, a = 1, c--) : (d.length = c + 1, a = ye(10, I - o), d[c] = s > 0 ? (f / ye(10, r - s) % ye(10, s) | 0) * a : 0), l) for (; ;)if (c == 0) { for (o = 1, s = d[0]; s >= 10; s /= 10)o++; for (s = d[0] += a, a = 1; s >= 10; s /= 10)a++; o != a && (e.e++, d[0] == Xe && (d[0] = 1)); break } else { if (d[c] += a, d[c] != Xe) break; d[c--] = 0, a = 1 } for (o = d.length; d[--o] === 0;)d.pop() } return C && (e.e > m.maxE ? (e.d = null, e.e = NaN) : e.e < m.minE && (e.e = 0, e.d = [0])), e } function un(e, n, i) { if (!e.isFinite()) return Ms(e); var t, r = e.e, o = Te(e.d), s = o.length; return n ? (i && (t = i - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + Mn(t) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : r < 0 ? (o = "0." + Mn(-r - 1) + o, i && (t = i - s) > 0 && (o += Mn(t))) : r >= s ? (o += Mn(r + 1 - s), i && (t = i - r - 1) > 0 && (o = o + "." + Mn(t))) : ((t = r + 1) < s && (o = o.slice(0, t) + "." + o.slice(t)), i && (t = i - s) > 0 && (r + 1 === s && (o += "."), o += Mn(t))), o } function qt(e, n) { var i = e[0]; for (n *= I; i >= 10; i /= 10)n++; return n } function Rt(e, n, i) { if (n > El) throw C = !0, i && (e.precision = i), Error(Ts); return D(new e(Pt), n, 1, !0) } function Qe(e, n, i) { if (n > Yr) throw Error(Ts); return D(new e(Ft), n, i, !0) } function ks(e) { var n = e.length - 1, i = n * I + 1; if (n = e[n], n) { for (; n % 10 == 0; n /= 10)i--; for (n = e[0]; n >= 10; n /= 10)i++ } return i } function Mn(e) { for (var n = ""; e--;)n += "0"; return n } function ws(e, n, i, t) { var r, o = new e(1), s = Math.ceil(t / I + 4); for (C = !1; ;) { if (i % 2 && (o = o.times(n), Ns(o.d, s) && (r = !0)), i = ke(i / 2), i === 0) { i = o.d.length - 1, r && o.d[i] === 0 && ++o.d[i]; break } n = n.times(n), Ns(n.d, s) } return C = !0, o } function vs(e) { return e.d[e.d.length - 1] & 1 } function Cs(e, n, i) { for (var t, r = new e(n[0]), o = 0; ++o < n.length;)if (t = new e(n[o]), t.s) r[i](t) && (r = t); else { r = t; break } return r } function Qr(e, n) { var i, t, r, o, s, a, u, l = 0, f = 0, d = 0, c = e.constructor, m = c.rounding, g = c.precision; if (!e.d || !e.d[0] || e.e > 17) return new c(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0); for (n == null ? (C = !1, u = g) : u = n, a = new c(.03125); e.e > -2;)e = e.times(a), d += 5; for (t = Math.log(ye(2, d)) / Math.LN10 * 2 + 5 | 0, u += t, i = o = s = new c(1), c.precision = u; ;) { if (o = D(o.times(e), u, 1), i = i.times(++f), a = s.plus(ee(o, i, u, 1)), Te(a.d).slice(0, u) === Te(s.d).slice(0, u)) { for (r = d; r--;)s = D(s.times(s), u, 1); if (n == null) if (l < 3 && Hi(s.d, u - t, m, l)) c.precision = u += 10, i = o = a = new c(1), f = 0, l++; else return D(s, c.precision = g, m, C = !0); else return c.precision = g, s } s = a } } function An(e, n) { var i, t, r, o, s, a, u, l, f, d, c, m = 1, g = 10, h = e, x = h.d, S = h.constructor, T = S.rounding, _ = S.precision; if (h.s < 0 || !x || !x[0] || !h.e && x[0] == 1 && x.length == 1) return new S(x && !x[0] ? -1 / 0 : h.s != 1 ? NaN : x ? 0 : h); if (n == null ? (C = !1, f = _) : f = n, S.precision = f += g, i = Te(x), t = i.charAt(0), Math.abs(o = h.e) < 15e14) { for (; t < 7 && t != 1 || t == 1 && i.charAt(1) > 3;)h = h.times(e), i = Te(h.d), t = i.charAt(0), m++; o = h.e, t > 1 ? (h = new S("0." + i), o++) : h = new S(t + "." + i.slice(1)) } else return l = Rt(S, f + 2, _).times(o + ""), h = An(new S(t + "." + i.slice(1)), f - g).plus(l), S.precision = _, n == null ? D(h, _, T, C = !0) : h; for (d = h, u = s = h = ee(h.minus(1), h.plus(1), f, 1), c = D(h.times(h), f, 1), r = 3; ;) { if (s = D(s.times(c), f, 1), l = u.plus(ee(s, new S(r), f, 1)), Te(l.d).slice(0, f) === Te(u.d).slice(0, f)) if (u = u.times(2), o !== 0 && (u = u.plus(Rt(S, f + 2, _).times(o + ""))), u = ee(u, new S(m), f, 1), n == null) if (Hi(u.d, f - g, T, a)) S.precision = f += g, l = s = h = ee(d.minus(1), d.plus(1), f, 1), c = D(h.times(h), f, 1), r = a = 1; else return D(u, S.precision = _, T, C = !0); else return S.precision = _, u; u = l, r += 2 } } function Ms(e) { return String(e.s * e.s / 0) } function Xr(e, n) { var i, t, r; for ((i = n.indexOf(".")) > -1 && (n = n.replace(".", "")), (t = n.search(/e/i)) > 0 ? (i < 0 && (i = t), i += +n.slice(t + 1), n = n.substring(0, t)) : i < 0 && (i = n.length), t = 0; n.charCodeAt(t) === 48; t++); for (r = n.length; n.charCodeAt(r - 1) === 48; --r); if (n = n.slice(t, r), n) { if (r -= t, e.e = i = i - t - 1, e.d = [], t = (i + 1) % I, i < 0 && (t += I), t < r) { for (t && e.d.push(+n.slice(0, t)), r -= I; t < r;)e.d.push(+n.slice(t, t += I)); n = n.slice(t), t = I - n.length } else t -= r; for (; t--;)n += "0"; e.d.push(+n), C && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0])) } else e.e = 0, e.d = [0]; return e } function Nl(e, n) { var i, t, r, o, s, a, u, l, f; if (n.indexOf("_") > -1) { if (n = n.replace(/(\d)_(?=\d)/g, "$1"), Is.test(n)) return Xr(e, n) } else if (n === "Infinity" || n === "NaN") return +n || (e.s = NaN), e.e = NaN, e.d = null, e; if (xl.test(n)) i = 16, n = n.toLowerCase(); else if (gl.test(n)) i = 2; else if (bl.test(n)) i = 8; else throw Error(On + n); for (o = n.search(/p/i), o > 0 ? (u = +n.slice(o + 1), n = n.substring(2, o)) : n = n.slice(2), o = n.indexOf("."), s = o >= 0, t = e.constructor, s && (n = n.replace(".", ""), a = n.length, o = a - o, r = ws(t, new t(i), o, o * 2)), l = Ot(n, i, Xe), f = l.length - 1, o = f; l[o] === 0; --o)l.pop(); return o < 0 ? new t(e.s * 0) : (e.e = qt(l, f), e.d = l, C = !1, s && (e = ee(e, r, a * 4)), u && (e = e.times(Math.abs(u) < 54 ? ye(2, u) : v.pow(2, u))), C = !0, e) } function _l(e, n) { var i, t = n.d.length; if (t < 3) return n.isZero() ? n : pi(e, 2, n, n); i = 1.4 * Math.sqrt(t), i = i > 16 ? 16 : i | 0, n = n.times(1 / Vt(5, i)), n = pi(e, 2, n, n); for (var r, o = new e(5), s = new e(16), a = new e(20); i--;)r = n.times(n), n = n.times(o.plus(r.times(s.times(r).minus(a)))); return n } function pi(e, n, i, t, r) { var o, s, a, u, l = 1, f = e.precision, d = Math.ceil(f / I); for (C = !1, u = i.times(i), a = new e(t); ;) { if (s = ee(a.times(u), new e(n++ * n++), f, 1), a = r ? t.plus(s) : t.minus(s), t = ee(s.times(u), new e(n++ * n++), f, 1), s = a.plus(t), s.d[d] !== void 0) { for (o = d; s.d[o] === a.d[o] && o--;); if (o == -1) break } o = a, a = t, t = s, s = o, l++ } return C = !0, s.d.length = d + 1, s } function Vt(e, n) { for (var i = e; --n;)i *= e; return i } function As(e, n) { var i, t = n.s < 0, r = Qe(e, e.precision, 1), o = r.times(.5); if (n = n.abs(), n.lte(o)) return En = t ? 4 : 1, n; if (i = n.divToInt(r), i.isZero()) En = t ? 3 : 2; else { if (n = n.minus(i.times(r)), n.lte(o)) return En = vs(i) ? t ? 2 : 3 : t ? 4 : 1, n; En = vs(i) ? t ? 1 : 4 : t ? 3 : 2 } return n.minus(r).abs() } function Kr(e, n, i, t) { var r, o, s, a, u, l, f, d, c, m = e.constructor, g = i !== void 0; if (g ? (Me(i, 1, Pn), t === void 0 ? t = m.rounding : Me(t, 0, 8)) : (i = m.precision, t = m.rounding), !e.isFinite()) f = Ms(e); else { for (f = un(e), s = f.indexOf("."), g ? (r = 2, n == 16 ? i = i * 4 - 3 : n == 8 && (i = i * 3 - 2)) : r = n, s >= 0 && (f = f.replace(".", ""), c = new m(1), c.e = f.length - s, c.d = Ot(un(c), 10, r), c.e = c.d.length), d = Ot(f, 10, r), o = u = d.length; d[--u] == 0;)d.pop(); if (!d[0]) f = g ? "0p+0" : "0"; else { if (s < 0 ? o-- : (e = new m(e), e.d = d, e.e = o, e = ee(e, c, i, t, 0, r), d = e.d, o = e.e, l = Ss), s = d[i], a = r / 2, l = l || d[i + 1] !== void 0, l = t < 4 ? (s !== void 0 || l) && (t === 0 || t === (e.s < 0 ? 3 : 2)) : s > a || s === a && (t === 4 || l || t === 6 && d[i - 1] & 1 || t === (e.s < 0 ? 8 : 7)), d.length = i, l) for (; ++d[--i] > r - 1;)d[i] = 0, i || (++o, d.unshift(1)); for (u = d.length; !d[u - 1]; --u); for (s = 0, f = ""; s < u; s++)f += Jr.charAt(d[s]); if (g) { if (u > 1) if (n == 16 || n == 8) { for (s = n == 16 ? 4 : 3, --u; u % s; u++)f += "0"; for (d = Ot(f, r, n), u = d.length; !d[u - 1]; --u); for (s = 1, f = "1."; s < u; s++)f += Jr.charAt(d[s]) } else f = f.charAt(0) + "." + f.slice(1); f = f + (o < 0 ? "p" : "p+") + o } else if (o < 0) { for (; ++o;)f = "0" + f; f = "0." + f } else if (++o > u) for (o -= u; o--;)f += "0"; else o < u && (f = f.slice(0, o) + "." + f.slice(o)) } f = (n == 16 ? "0x" : n == 2 ? "0b" : n == 8 ? "0o" : "") + f } return e.s < 0 ? "-" + f : f } function Ns(e, n) { if (e.length > n) return e.length = n, !0 } function Sl(e) { return new this(e).abs() } function Tl(e) { return new this(e).acos() } function Bl(e) { return new this(e).acosh() } function Dl(e, n) { return new this(e).plus(n) } function Il(e) { return new this(e).asin() } function kl(e) { return new this(e).asinh() } function wl(e) { return new this(e).atan() } function Cl(e) { return new this(e).atanh() } function Ml(e, n) { e = new this(e), n = new this(n); var i, t = this.precision, r = this.rounding, o = t + 4; return !e.s || !n.s ? i = new this(NaN) : !e.d && !n.d ? (i = Qe(this, o, 1).times(n.s > 0 ? .25 : .75), i.s = e.s) : !n.d || e.isZero() ? (i = n.s < 0 ? Qe(this, t, r) : new this(0), i.s = e.s) : !e.d || n.isZero() ? (i = Qe(this, o, 1).times(.5), i.s = e.s) : n.s < 0 ? (this.precision = o, this.rounding = 1, i = this.atan(ee(e, n, o, 1)), n = Qe(this, o, 1), this.precision = t, this.rounding = r, i = e.s < 0 ? i.minus(n) : i.plus(n)) : i = this.atan(ee(e, n, o, 1)), i } function Al(e) { return new this(e).cbrt() } function Ol(e) { return D(e = new this(e), e.e + 1, 2) } function Pl(e, n, i) { return new this(e).clamp(n, i) } function Fl(e) { if (!e || typeof e != "object") throw Error(Lt + "Object expected"); var n, i, t, r = e.defaults === !0, o = ["precision", 1, Pn, "rounding", 0, 8, "toExpNeg", -mi, 0, "toExpPos", 0, mi, "maxE", 0, mi, "minE", -mi, 0, "modulo", 0, 9]; for (n = 0; n < o.length; n += 3)if (i = o[n], r && (this[i] = Wr[i]), (t = e[i]) !== void 0) if (ke(t) === t && t >= o[n + 1] && t <= o[n + 2]) this[i] = t; else throw Error(On + i + ": " + t); if (i = "crypto", r && (this[i] = Wr[i]), (t = e[i]) !== void 0) if (t === !0 || t === !1 || t === 0 || t === 1) if (t) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[i] = !0; else throw Error(Bs); else this[i] = !1; else throw Error(On + i + ": " + t); return this } function Rl(e) { return new this(e).cos() } function Ll(e) { return new this(e).cosh() } function Os(e) { var n, i, t; function r(o) { var s, a, u, l = this; if (!(l instanceof r)) return new r(o); if (l.constructor = r, _s(o)) { l.s = o.s, C ? !o.d || o.e > r.maxE ? (l.e = NaN, l.d = null) : o.e < r.minE ? (l.e = 0, l.d = [0]) : (l.e = o.e, l.d = o.d.slice()) : (l.e = o.e, l.d = o.d ? o.d.slice() : o.d); return } if (u = typeof o, u === "number") { if (o === 0) { l.s = 1 / o < 0 ? -1 : 1, l.e = 0, l.d = [0]; return } if (o < 0 ? (o = -o, l.s = -1) : l.s = 1, o === ~~o && o < 1e7) { for (s = 0, a = o; a >= 10; a /= 10)s++; C ? s > r.maxE ? (l.e = NaN, l.d = null) : s < r.minE ? (l.e = 0, l.d = [0]) : (l.e = s, l.d = [o]) : (l.e = s, l.d = [o]); return } else if (o * 0 !== 0) { o || (l.s = NaN), l.e = NaN, l.d = null; return } return Xr(l, o.toString()) } else if (u !== "string") throw Error(On + o); return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), l.s = -1) : (a === 43 && (o = o.slice(1)), l.s = 1), Is.test(o) ? Xr(l, o) : Nl(l, o) } if (r.prototype = y, r.ROUND_UP = 0, r.ROUND_DOWN = 1, r.ROUND_CEIL = 2, r.ROUND_FLOOR = 3, r.ROUND_HALF_UP = 4, r.ROUND_HALF_DOWN = 5, r.ROUND_HALF_EVEN = 6, r.ROUND_HALF_CEIL = 7, r.ROUND_HALF_FLOOR = 8, r.EUCLID = 9, r.config = r.set = Fl, r.clone = Os, r.isDecimal = _s, r.abs = Sl, r.acos = Tl, r.acosh = Bl, r.add = Dl, r.asin = Il, r.asinh = kl, r.atan = wl, r.atanh = Cl, r.atan2 = Ml, r.cbrt = Al, r.ceil = Ol, r.clamp = Pl, r.cos = Rl, r.cosh = Ll, r.div = ql, r.exp = Vl, r.floor = $l, r.hypot = zl, r.ln = Ul, r.log = Gl, r.log10 = Zl, r.log2 = jl, r.max = Hl, r.min = Jl, r.mod = Wl, r.mul = Yl, r.pow = Ql, r.random = Xl, r.round = Kl, r.sign = ef, r.sin = nf, r.sinh = tf, r.sqrt = rf, r.sub = of, r.sum = sf, r.tan = af, r.tanh = uf, r.trunc = lf, e === void 0 && (e = {}), e && e.defaults !== !0) for (t = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], n = 0; n < t.length;)e.hasOwnProperty(i = t[n++]) || (e[i] = this[i]); return r.config(e), r } function ql(e, n) { return new this(e).div(n) } function Vl(e) { return new this(e).exp() } function $l(e) { return D(e = new this(e), e.e + 1, 3) } function zl() { var e, n, i = new this(0); for (C = !1, e = 0; e < arguments.length;)if (n = new this(arguments[e++]), n.d) i.d && (i = i.plus(n.times(n))); else { if (n.s) return C = !0, new this(1 / 0); i = n } return C = !0, i.sqrt() } function _s(e) { return e instanceof v || e && e.toStringTag === Ds || !1 } function Ul(e) { return new this(e).ln() } function Gl(e, n) { return new this(e).log(n) } function jl(e) { return new this(e).log(2) } function Zl(e) { return new this(e).log(10) } function Hl() { return Cs(this, arguments, "lt") } function Jl() { return Cs(this, arguments, "gt") } function Wl(e, n) { return new this(e).mod(n) } function Yl(e, n) { return new this(e).mul(n) } function Ql(e, n) { return new this(e).pow(n) } function Xl(e) { var n, i, t, r, o = 0, s = new this(1), a = []; if (e === void 0 ? e = this.precision : Me(e, 1, Pn), t = Math.ceil(e / I), this.crypto) if (crypto.getRandomValues) for (n = crypto.getRandomValues(new Uint32Array(t)); o < t;)r = n[o], r >= 429e7 ? n[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = r % 1e7; else if (crypto.randomBytes) { for (n = crypto.randomBytes(t *= 4); o < t;)r = n[o] + (n[o + 1] << 8) + (n[o + 2] << 16) + ((n[o + 3] & 127) << 24), r >= 214e7 ? crypto.randomBytes(4).copy(n, o) : (a.push(r % 1e7), o += 4); o = t / 4 } else throw Error(Bs); else for (; o < t;)a[o++] = Math.random() * 1e7 | 0; for (t = a[--o], e %= I, t && e && (r = ye(10, I - e), a[o] = (t / r | 0) * r); a[o] === 0; o--)a.pop(); if (o < 0) i = 0, a = [0]; else { for (i = -1; a[0] === 0; i -= I)a.shift(); for (t = 1, r = a[0]; r >= 10; r /= 10)t++; t < I && (i -= I - t) } return s.e = i, s.d = a, s } function Kl(e) { return D(e = new this(e), e.e + 1, this.rounding) } function ef(e) { return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN } function nf(e) { return new this(e).sin() } function tf(e) { return new this(e).sinh() } function rf(e) { return new this(e).sqrt() } function of(e, n) { return new this(e).sub(n) } function sf() { var e = 0, n = arguments, i = new this(n[e]); for (C = !1; i.s && ++e < n.length;)i = i.plus(n[e]); return C = !0, D(i, this.precision, this.rounding) } function af(e) { return new this(e).tan() } function uf(e) { return new this(e).tanh() } function lf(e) { return D(e = new this(e), e.e + 1, 1) } y[Symbol.for("nodejs.util.inspect.custom")] = y.toString; y[Symbol.toStringTag] = "Decimal"; var v = y.constructor = Os(Wr); Pt = new v(Pt); Ft = new v(Ft); var Ue = v; function ff(e) { let n = []; for (let i = 0; i < e.length; i++) { let t = e.charCodeAt(i); if (t >= 55296 && t <= 56319) { let r = e.charCodeAt(i + 1); if (r >= 56320 && r <= 57343) { let o = t - 55296, s = r - 56320; t = 2 ** 16 + o * 2 ** 10 + s, i++ } } n.push(t) } return n } var $t = 8205, Ps = [127462, 127487]; function Fs(e) { return e === $t || e === 65038 || e === 65039 || e >= 127995 && e <= 127995 + 5 || e >= 129456 && e <= 129456 + 4 || e >= 917536 && e <= 917536 + 96 } function df(e) { return e >= Ps[0] && e <= Ps[1] } function Rs(e) { if (/^[\u0020-\u00FF]*$/.test(e)) return e; let n = [], i = ff(e), t = 0; for (; t < i.length;) { let r = i[t++], o = i[t]; if (o === $t) { let s = t - 1; for (t += 2; i[t] === $t;)t += 2; n.push(String.fromCodePoint(...i.slice(s, 2 * t - s + 1))) } else if (Fs(o)) { let s = t - 1; for (; Fs(i[t]);)t += i[t] === $t ? 2 : 1; n.push(String.fromCodePoint(...i.slice(s, 2 * t - s - 1))) } else df(r) ? (t += 1, n.push(String.fromCodePoint(...i.slice(t - 2, 2)))) : n.push(String.fromCodePoint(r)) } return n } var eo = class { constructor(n) { this.obeyspaces = !1; n = n.replace(/[\u200E\u200F\u2066-\u2069\u202A-\u202E]/g, ""), this.s = Rs(n), this.pos = 0 } end() { return this.pos >= this.s.length } get() { return this.pos < this.s.length ? this.s[this.pos++] : "" } peek() { return this.s[this.pos] } match(n) { let i; return typeof this.s == "string" ? i = n.exec(this.s.slice(this.pos)) : i = n.exec(this.s.slice(this.pos).join("")), i?.[0] ? (this.pos += i[0].length, i[0]) : null } next() { if (this.end()) return null; if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/)) return "<space>"; if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/)) return "<space>"; let n = this.get(); if (n === "\\") { if (!this.end()) { let i = this.match(/^[a-zA-Z*]+/); if (i) this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/); else if (i = this.get(), i === " ") return "<space>"; return "\\" + i } } else { if (n === "{") return "<{>"; if (n === "}") return "<}>"; if (n === "^") { if (this.peek() === "^") { this.get(); let i = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/); if (i) return String.fromCodePoint(parseInt(i.slice(i.lastIndexOf("^") + 1), 16)) } return n } else if (n === "#") { if (!this.end()) { let i = !1; if (/[0-9?]/.test(this.peek()) && (i = !0, this.pos + 1 < this.s.length)) { let t = this.s[this.pos + 1]; i = /[^0-9A-Za-z]/.test(t) } return i ? "#" + this.get() : "#" } } else if (n === "$") return this.peek() === "$" ? (this.get(), "<$$>") : "<$>" } return n } }; function cf(e, n) { let i = e.next(); if (!i) return []; let t = []; if (i !== "\\relax") { if (i === "\\noexpand") i = e.next(), i && t.push(i); else if (i === "\\obeyspaces") e.obeyspaces = !0; else if (i === "\\space" || i === "~") t.push("<space>"); else if (i === "\\bgroup") t.push("<{>"); else if (i === "\\egroup") t.push("<}>"); else if (i === "\\string") i = e.next(), i && (i[0] === "\\" ? Array.from(i).forEach(r => t.push(r === "\\" ? "\\backslash" : r)) : i === "<{>" ? t.push("\\{") : i === "<space>" ? t.push("~") : i === "<}>" && t.push("\\}")); else if (i === "\\csname") { for (; e.peek() === "<space>";)e.next(); let r = "", o = !1, s = []; do { if (s.length === 0) if (/^#[0-9?]$/.test(e.peek())) { let a = e.get().slice(1); s = $(n?.[a] ?? n?.["?"] ?? "\\placeholder{}", n), i = s[0] } else i = e.next(), s = i ? [i] : []; o = s.length === 0, !o && i === "\\endcsname" && (o = !0, s.shift()), o || (o = i === "<$>" || i === "<$$>" || i === "<{>" || i === "<}>" || !!i && i.length > 1 && i[0] === "\\"), o || (r += s.shift()) } while (!o); r && t.push("\\" + r), t = t.concat(s) } else if (i !== "\\endcsname") if (i.length > 1 && i[0] === "#") { let r = i.slice(1); t = t.concat($(n?.[r] ?? n?.["?"] ?? "\\placeholder{}", n)) } else t.push(i) } return t } function $(e, n) { let i = e.toString().split(/\r?\n/), t = "", r = ""; for (let a of i) { t += r, r = " "; let u = a.match(/((?:\\%)|[^%])*/); u !== null && (t += u[0]) } let o = new eo(t), s = []; do s.push(...cf(o, n)); while (!o.end()); return s } function zt(e) { return $(e, []).length } function N(e) { let n = "", i = ""; for (let t of e) t && (/[a-zA-Z*]/.test(t[0]) && (i += n), /\\[a-zA-Z]+\*?$/.test(t) ? n = " " : n = "", i += t); return i } function ln(e) { let n = []; if (Array.isArray(e)) for (let t of e) Array.isArray(t) ? n = [...n, ...t] : n.push(t); else n = [e]; return N(n.map(t => ({ "<space>": " ", "<$$>": "$$", "<$>": "$", "<{>": "{", "<}>": "}" })[t] ?? t)) } var Ls = [{ name: "To", latexTrigger: ["\\to"], kind: "infix", precedence: 270 }, { latexTrigger: ["\\rightarrow"], kind: "infix", precedence: 270, parse: "To" }]; var Yn = ["Error", "'missing'"]; function Fn(e) { return !!(typeof e == "number" || Qn(e) || typeof e == "string" && /^[+-]?[0-9\.]/.test(e)) } function Qn(e) { return e !== null && typeof e == "object" && "num" in e } function Wi(e) { return e !== null && typeof e == "object" && "sym" in e } function zs(e) { return e !== null && typeof e == "object" && "str" in e } function hi(e) { return e !== null && typeof e == "object" && "fn" in e } var no; function Us(e) { if (!no) { let i = `^[${["Zyyy", "Zinh", "Arab", "Armn", "Beng", "Bopo", "Cyrl", "Deva", "Ethi", "Geor", "Grek", "Gujr", "Guru", "Hang", "Hani", "Hebr", "Hira", "Kana", "Knda", "Khmr", "Laoo", "Latn", "Mlym", "Mymr", "Orya", "Sinh", "Taml", "Telu", "Thaa", "Thai", "Tibt"].map(t => `\\p{Script=${t}}`).join("")}]*$`; no = new RegExp(i, "u") } return no.test(e) } function Ee(e) { return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e) || gi.test(e) ? !0 : Us(e) ? /^[\p{XIDS}_]\p{XIDC}*$/u.test(e) : !1 } var mf = "\\u{FE0F}", pf = "\\u{20E3}", hf = "\\u{200D}", gf = "\\p{RI}\\p{RI}", xf = "(?:[\\u{E0020}-\\u{E007E}]+\\u{E007F})", qs = `(?:\\p{EMod}|${mf}${pf}?|${xf})`, bf = "(?:(?=\\P{XIDC})\\p{Emoji})", Vs = `(?:${bf}${qs}*|\\p{Emoji}${qs}+|${gf})`, Gs = `(?:${Vs})(${hf}${Vs})*`, yf = new RegExp(`(?:${Gs})+`, "u"), gi = new RegExp(`^(?:${Gs})+$`, "u"); function en(e) { return typeof e != "string" ? "not-a-string" : e === "" ? "empty-string" : e.normalize() !== e ? "expected-nfc" : /[\u200E\u200F\u2066-\u2069\u202A-\u202E]/.test(e) ? "unexpected-bidi-marker" : gi.test(e) ? "valid" : /\p{XIDC}/u.test(e) && yf.test(e) ? "unexpected-mixed-emoji" : Us(e) ? Ee(e) ? "valid" : Ee(e[0]) ? "invalid-char" : "invalid-first-char" : "unexpected-script" } function z(e) { return e == null ? null : typeof e == "object" && "str" in e ? e.str : typeof e != "string" || e.length < 2 || e[0] !== "'" || e[e.length - 1] !== "'" ? null : e.substring(1, e.length - 1) } function to(e) { if (e == null || z(e) !== null) return null; let n = b(e); return n == null ? e : [n, ...(B(e) ?? []).map(i => to(i)).filter(i => i !== null)] } function b(e) { return Array.isArray(e) ? typeof e[0] == "string" && !Ee(e[0]) ? (console.error(`Invalid identifier "${e[0]}": ${en(e[0])}`), null) : e[0] : e == null ? null : hi(e) ? e.fn[0] : null } function ro(e) { let n = b(e); return typeof n == "string" ? n : "" } function B(e) { return Array.isArray(e) ? e.slice(1) : e == null ? null : hi(e) ? e.fn.slice(1) : null } function p(e, n) { return Array.isArray(e) ? e[n] ?? null : e == null ? null : hi(e) ? e.fn[n] ?? null : null } function Be(e) { return p(e, 1) } function Ke(e) { return p(e, 2) } function G(e) { return e == null ? 0 : Array.isArray(e) ? Math.max(0, e.length - 1) : hi(e) ? Math.max(0, e.fn.length - 1) : 0 } function oo(e) { return e == null ? null : b(e) === "Hold" ? p(e, 1) : e } function V(e) { if (typeof e == "string") return /^[+-]?[0-9\.]/.test(e) || e.length >= 2 && e[0] === "'" && e[e.length - 1] === "'" ? null : e; if (e == null) return null; let n = Wi(e) ? e.sym : e; return typeof n != "string" ? null : n } function $s(e) { let n = b(e); if (n === "KeyValuePair" || n === "Tuple" || n === "Pair") { let i = z(Be(e)); return i ? [i, Ke(e) ?? "Nothing"] : null } return null } function Xn(e) { if (e === null) return null; if (typeof e == "object" && "dict" in e) return e.dict; let n = $s(e); if (n) return { [n[0]]: n[1] }; if (b(e) === "Dictionary") { let t = {}; for (let r = 1; r < G(e); r++) { let o = $s(p(e, r)); o && (t[o[0]] = o[1]) } return t } return null } function Ef(e) { if (e = e.toLowerCase().replace(/[nd]$/, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), e === "nan") return NaN; if (e === "infinity" || e === "+infinity") return 1 / 0; if (e === "-infinity") return -1 / 0; if (/\([0-9]+\)/.test(e)) { let [n, i, t, r] = e.match(/(.+)\(([0-9]+)\)(.*)$/) ?? []; e = i + t.repeat(Math.ceil(16 / t.length)) + (r ?? "") } return parseFloat(e) } function M(e) { return typeof e == "number" ? e : typeof e == "string" ? Ef(e) : e == null ? null : Qn(e) ? M(e.num) : null } function xi(e) { if (e == null) return null; if (V(e) === "Half") return [1, 2]; let n = b(e); if (!n) return null; let i = null, t = null; if (n === "Negate") { let r = xi(Be(e)); if (r) return [-r[0], r[1]] } if ((n === "Rational" || n === "Divide") && (i = M(Be(e)) ?? NaN, t = M(Ke(e)) ?? NaN), n === "Power") { let r = M(Ke(e)); r === 1 ? (i = M(Be(e)), t = 1) : r === -1 && (i = 1, t = M(Be(e))) } return n === "Multiply" && b(Ke(e)) === "Power" && M(Ke(Ke(e))) === -1 && (i = M(Be(e)), t = M(Be(Ke(e)))), i === null || t === null ? null : Number.isInteger(i) && Number.isInteger(t) ? [i, t] : null } function Ji(e, n) { let i = b(e); if (i !== null) return [Ji(i, n), ...(B(e) ?? []).map(o => Ji(o, n))]; let t = Xn(e); if (t !== null) { let o = Object.keys(t), s = {}; for (let a of o) s[a] = Ji(t[a], n); return { dict: s } } let r = V(e); return r && n[r] ? n[r] : e } function Yi(e, n) { let i = null; if (Array.isArray(e) && (i = e), hi(e) && (i = e.fn), i === null) return []; let t = 1, r = []; for (; t < i.length;)r.push(n(i[t])), t += 1; return r } function bi(e, n, i, t = "both") { if (t === "non") return [e, n, i]; let r = b(n), o = b(i); return t === "left" ? r === e ? [e, ...B(n) ?? [], i] : [e, n, i] : t === "right" ? o === e ? [e, n, ...B(i) ?? []] : [e, n, i] : r === e && o === e ? [e, ...B(n) ?? [], ...B(i) ?? []] : r === e ? [e, ...B(n) ?? [], i] : o === e ? [e, n, ...B(i) ?? []] : [e, n, i] } function Ut(e) { if (e === null) return null; let n = b(e); if (n === "Delimiter") { if (e = p(e, 1), e === null) return []; if (n = b(e), n !== "Sequence") return [e] } return n !== "Sequence" ? null : B(e) ?? [] } function oe(e) { return b(e) === "Sequence" && G(e) === 0 } function H(e) { return oe(e) ? Yn : e ?? Yn } function io(e) { return e[0] === "Square" ? io(e.slice(1)) + 2 : e.reduce((n, i) => n + Qi(i), 0) } function Qi(e) { if (e === null) return 0; if (typeof e == "number" || typeof e == "string" || Fn(e) || Wi(e) || zs(e)) return 1; if (Array.isArray(e)) return io(e); if ("fn" in e) return io(e.fn); let n = Xn(e); if (n) { let i = Object.keys(n); return 1 + i.length + i.reduce((t, r) => t + Qi(n[r]), 0) } return 0 } function vf(e) { if (b(e) !== "Multiply") return [[], []]; let n = [], i = [], t = B(e) ?? []; for (let r of t) if (b(r) === "Power") { let o = p(r, 1), s = p(r, 2); if (b(s) === "Negate") { let a = p(s, 1); o && a && i.push(["Power", o, a]) } else { let a = M(s) ?? NaN; a === -1 ? o && i.push(o) : a < 0 ? o && i.push(["Power", o, -a]) : n.push(r) } } else if (b(r) === "Rational" && G(r) === 2) { let o = p(r, 1), s = p(r, 2); M(o) !== 1 && n.push(o), M(s) !== 1 && i.push(s) } else { let o = xi(r); o !== null ? (o[0] !== 1 && n.push(o[0]), i.push(o[1])) : n.push(r) } return [n, i] } function Nf(e) { let n = e.parseOptionalGroup(), i = e.parseGroup() ?? e.parseToken(); return i === null || oe(i) ? n !== null ? ["Root", Yn, H(n)] : ["Sqrt", Yn] : n !== null ? ["Root", i, n] : ["Sqrt", i] } function Xi(e, n, i, t) { return i === null ? "\\sqrt{}" : (t = t ?? 2, n === "solidus" ? e.wrapShort(i) + "^{1\\/" + e.serialize(t) + "}" : n === "quotient" ? e.wrapShort(i) + "^{\\frac{1}{" + e.serialize(t) + "}}" : M(t) === 2 ? "\\sqrt{" + e.serialize(i) + "}" : "\\sqrt[" + e.serialize(t) + "]{" + e.serialize(i) + "}") } function _f(e, n) { e.level -= 1; let i = b(n), t = "", r = p(n, 1); if (i === "Negate") t = "-" + e.wrap(r, 276); else if (i === "Add") { if (e.canonical && G(n) === 2 && e.options.invisiblePlus !== "+") { let [a, u] = [p(n, 1), p(n, 2)], [l, f] = [a, u], d = M(l), c = xi(f); if ((d === null || c === null) && ([l, f] = [u, a], d = M(l), c = xi(f)), d !== null && c !== null && isFinite(d) && Number.isInteger(d) && d >= 0 && d <= 1e3 && isFinite(c[0]) && isFinite(c[1]) && c[0] > 0 && c[0] <= 100 && c[1] <= 100) return t = N([e.serialize(l), e.options.invisiblePlus, e.serialize(f)]), e.level += 1, t } let o = M(r) ?? NaN; t = e.serialize(r); let s = G(n) + 1; for (let a = 2; a < s; a++)if (r = p(n, a), o = M(r) ?? NaN, o < 0) t += e.serialize(r); else if (b(r) === "Negate") t += e.wrap(r, re); else { let u = e.wrap(r, re); u[0] === "-" || u[0] === "+" ? t += u : t += "+" + u } } else if (i === "Subtract") { t = e.wrap(r, re); let o = p(n, 2); if (o !== null) { let s = e.wrap(o, re); s[0] === "-" ? t += "+" + s.slice(1) : s[0] === "+" ? t += "-" + s.slice(1) : t = t + "-" + s } } return e.level += 1, t } function Ws(e, n) { if (n === null) return ""; e.level -= 1; let i = ""; if (e.canonical === !0) { let [a, u] = vf(n); u.length > 0 && (u.length === 1 && u[0] === 1 ? a.length === 0 ? i = "1" : a.length === 1 ? i = e.serialize(a[0]) : i = Ws(e, ["Multiply", ...a]) : i = e.serialize(["Divide", a.length === 1 ? a[0] : ["Multiply", ...a], u.length === 1 ? u[0] : ["Multiply", ...u]])) } if (i) return e.level += 1, i; let t = !1, r = null, o = G(n) + 1, s = !1; for (let a = 1; a < o; a++) { if (r = p(n, a), r === null) continue; let u; if (Fn(r)) { u = e.serialize(r), u === "-1" && !i ? (i = "", t = !t) : (u[0] === "-" && (u = u.slice(1), t = !t), i = i ? N([i, e.options.multiply, u]) : u), s = !0; continue } if (b(r) === "Power") { let l = xi(p(r, 2)); if (l) { let [f, d] = l; if (f === 1 && d !== null) { i += Xi(e, e.rootStyle(r, e.level), p(r, 1), d), s = !1; continue } } } if (b(r) === "Power" && !isNaN(M(p(r, 1)) ?? NaN)) { u = e.serialize(r), i = i ? N([i, e.options.multiply, u]) : u, s = !0; continue } if (b(r) === "Negate" && (r = p(r, 1), t = !t), u = e.wrap(r, ze), !i) i = u; else { let l = b(r); s && (l === "Divide" || l === "Rational") ? i = N([i, e.options.multiply, u]) : e.options.invisibleMultiply ? i = N([i, e.options.invisibleMultiply, u]) : i = N([i, u]) } s = !1 } return e.level += 1, t ? "-" + i : i } function Sf(e) { let n = e.parseGroup(), i = null; if (n === null ? (n = e.parseToken(), i = e.parseToken()) : i = e.parseGroup(), n = H(n), i = H(i), b(n) === "PartialDerivative" && (b(i) === "PartialDerivative" || b(i) === "Multiply" && b(p(i, 1)) === "PartialDerivative")) { let t = p(n, 3) ?? null, r = p(n, 1); r === null && (r = H(e.parseExpression())); let o = []; if (b(i) === "Multiply") { for (let s of B(i) ?? []) if (b(s) === "PartialDerivative") { let a = p(s, 2); a && o.push(a) } } else { let s = p(i, 2); s && o.push(s) } return o.length > 1 && (o = ["List", ...o]), ["PartialDerivative", r, ...o, t === null ? 1 : t] } return ["Divide", n, i] } function js(e, n) { if (n === null) return ""; let i = H(p(n, 1)), t = H(p(n, 2)), r = e.canonical ? e.fractionStyle(n, e.level) : "quotient"; if (r === "inline-solidus" || r === "nice-solidus") { let u = e.wrapShort(i), l = e.wrapShort(t); return r === "inline-solidus" ? `${u}\\/${l}` : `{}^{${u}}\\!\\!/\\!{}_{${l}}` } else { if (r === "reciprocal") return M(i) === 1 ? e.wrap(t) + "^{-1}" : e.wrap(i) + e.wrap(t) + "^{-1}"; if (r === "factor") return M(t) === 1 ? e.wrap(i) : "\\frac{1}{" + e.serialize(t) + "}" + e.wrapString(e.serialize(i), e.groupStyle(n, 1)) } let o = "\\frac"; r === "block-quotient" ? o = "\\dfrac" : r === "inline-quotient" && (o = "\\tfrac"); let s = e.serialize(i), a = e.serialize(t); return `${o}{${s}}{${a}}` } function so(e, n) { if (!n) return ""; let i = b(n), t = H(p(n, 1)); if (i === "Sqrt") return Xi(e, e.rootStyle(n, e.level - 1), t, 2); let r = H(p(n, 2)); if (i === "Root") return Xi(e, e.rootStyle(n, e.level - 1), t, r); if (e.canonical) { let o = M(r) ?? 1; if (o === -1) return e.serialize(["Divide", "1", t]); if (o < 0) return e.serialize(["Divide", "1", ["Power", t, -o]]); if (b(r) === "Divide" || b(r) === "Rational") { if (M(p(r, 1)) === 1) { let s = e.rootStyle(n, e.level); return Xi(e, s, t, p(r, 2)) } if (M(p(r, 2)) === 2) return `${e.serialize(["Sqrt", t])}^{${e.serialize(p(r, 1))}}` } else if (b(r) === "Power" && M(p(r, 2)) === -1) { let s = e.rootStyle(n, e.level); return Xi(e, s, t, p(r, 1)) } } return e.wrapShort(t) + "^{" + e.serialize(r) + "}" } var Ys = [{ name: "CatalanConstant", identifierTrigger: "G" }, { name: "GoldenRatio", latexTrigger: "\\varphi" }, { name: "EulerGamma", latexTrigger: "\\gamma" }, { name: "Degrees", latexTrigger: ["\\degree"], kind: "postfix", precedence: 880, parse: (e, n) => ["Degrees", n], serialize: (e, n) => N([e.serialize(p(n, 1)), "\\degree"]) }, { latexTrigger: ["\\degree"], kind: "postfix", precedence: 880, parse: (e, n) => ["Degrees", n] }, { latexTrigger: ["^", "<{>", "\\circ", "<}>"], kind: "postfix", parse: (e, n) => ["Degrees", n] }, { latexTrigger: ["^", "\\circ"], kind: "postfix", parse: (e, n) => ["Degrees", n] }, { latexTrigger: ["\xB0"], kind: "postfix", precedence: 880, parse: (e, n) => ["Degrees", n] }, { latexTrigger: ["\\ang"], parse: e => { let n = e.parseGroup(); return n === null ? ["Degrees"] : ["Degrees", n] } }, { latexTrigger: ["\\infty"], parse: { num: "+Infinity" } }, { name: "ComplexInfinity", latexTrigger: ["\\tilde", "\\infty"], serialize: "\\tilde\\infty" }, { latexTrigger: ["\\tilde", "<{>", "\\infty", "<}>"], parse: "ComplexInfinity" }, { name: "Pi", kind: "symbol", latexTrigger: ["\\pi"] }, { latexTrigger: ["\u03C0"], parse: "Pi" }, { name: "ExponentialE", latexTrigger: ["\\exponentialE"], parse: "ExponentialE", serialize: "\\exponentialE" }, { latexTrigger: "\\operatorname{e}", parse: "ExponentialE" }, { latexTrigger: "\\mathrm{e}", parse: "ExponentialE" }, { kind: "function", identifierTrigger: "exp", parse: "Exp" }, { latexTrigger: "\\exp", parse: "Exp" }, { name: "ImaginaryUnit", latexTrigger: ["\\imaginaryI"] }, { latexTrigger: "\\operatorname{i}", parse: "ImaginaryUnit" }, { latexTrigger: "\\mathrm{i}", parse: "ImaginaryUnit" }, { name: "Abs", kind: "matchfix", openTrigger: "|", closeTrigger: "|", parse: (e, n) => oe(n) ? null : ["Abs", n] }, { kind: "matchfix", openTrigger: "\\vert", closeTrigger: "\\vert", parse: (e, n) => oe(n) ? null : ["Abs", n] }, { identifierTrigger: "abs", kind: "function", parse: "Abs" }, { name: "Add", latexTrigger: ["+"], kind: "infix", associativity: "both", precedence: re, parse: (e, n, i) => { if (i && re < i.minPrec) return null; let t = e.parseExpression({ ...i, minPrec: re }); return t === null ? null : bi("Add", n, t) }, serialize: _f }, { kind: "prefix", latexTrigger: ["+"], precedence: re, parse: (e, n) => n && re < n.minPrec ? null : e.parseExpression({ ...n, minPrec: 400 }) }, { name: "Ceil", kind: "matchfix", openTrigger: "\\lceil", closeTrigger: "\\rceil", parse: (e, n) => oe(n) ? null : ["Ceil", n] }, { kind: "matchfix", openTrigger: ["\u2308"], closeTrigger: ["\u2309"], parse: (e, n) => oe(n) ? null : ["Ceil", n] }, { identifierTrigger: "ceil", kind: "function", parse: "Ceil" }, { name: "Chop", identifierTrigger: "chop", kind: "function", parse: "Chop" }, { name: "Complex", precedence: re - 1, serialize: (e, n) => { let i = e.serialize(p(n, 1)), t = M(p(n, 2)); if (t === 0) return i; let r = t === 1 ? "\\imaginaryI" : t === -1 ? "-\\imaginaryI" : N([e.serialize(p(n, 2)), "\\imaginaryI"]); return M(p(n, 1)) === 0 ? r : t !== null && t < 0 ? N([i, r]) : N([i, "+", r]) } }, { name: "Divide", latexTrigger: "\\frac", precedence: an, parse: Sf, serialize: js }, { kind: "infix", latexTrigger: "\\over", precedence: an, parse: "Divide" }, { latexTrigger: ["\\/"], kind: "infix", associativity: "non", precedence: an, parse: "Divide" }, { latexTrigger: ["/"], kind: "infix", associativity: "non", precedence: an, parse: "Divide" }, { latexTrigger: ["\\div"], kind: "infix", associativity: "non", precedence: an, parse: "Divide" }, { name: "Exp", serialize: (e, n) => { let i = p(n, 1); return V(i) || M(i) !== null ? N(["\\exponentialE^{", e.serialize(i), "}"]) : N(["\\exp", e.wrap(H(i))]) } }, { name: "Factorial", latexTrigger: ["!"], kind: "postfix", precedence: Ct }, { name: "Factorial2", latexTrigger: ["!", "!"], kind: "postfix", precedence: Ct }, { name: "Floor", kind: "matchfix", openTrigger: "\\lfloor", closeTrigger: "\\rfloor", parse: (e, n) => oe(n) ? null : ["Floor", n] }, { kind: "matchfix", openTrigger: ["\u230A"], closeTrigger: ["\u230B"], parse: (e, n) => oe(n) ? null : ["Floor", n] }, { identifierTrigger: "floor", kind: "function", parse: "Floor" }, { latexTrigger: ["\\Gamma"], parse: "Gamma" }, { name: "GCD", identifierTrigger: "gcd", kind: "function" }, { identifierTrigger: "GCD", kind: "function", parse: "GCD" }, { name: "Half", serialize: "\\frac12" }, { name: "Lg", latexTrigger: ["\\lg"], serialize: (e, n) => "\\log_{10}" + e.wrapArguments(n), parse: e => { let n = e.parseArguments("implicit"); return n === null ? "Lg" : ["Log", ...n, 10] } }, { name: "Lb", latexTrigger: "\\lb", parse: e => { let n = e.parseArguments("implicit"); return n === null ? "Log" : ["Log", ...n, 2] } }, { name: "Ln", latexTrigger: ["\\ln"], serialize: (e, n) => "\\ln" + e.wrapArguments(n), parse: e => Js("Ln", e) }, { name: "Log", latexTrigger: ["\\log"], parse: e => Js("Log", e), serialize: (e, n) => { let i = Ke(n); return i ? N(["\\log_{", i.toString(), "}", e.wrap(Be(n))]) : "\\log" + e.wrapArguments(n) } }, { name: "LCM", identifierTrigger: "lcm", kind: "function" }, { identifierTrigger: "LCM", kind: "function", parse: "LCM" }, { identifierTrigger: "max", kind: "function", parse: "Max" }, { identifierTrigger: "min", kind: "function", parse: "Min" }, { name: "Max", latexTrigger: "\\max", kind: "function" }, { name: "Min", latexTrigger: "\\min", kind: "function" }, { name: "Supremum", latexTrigger: "\\sup", kind: "function" }, { name: "Infimum", latexTrigger: "\\inf", kind: "function" }, { name: "Limit", latexTrigger: "\\lim", kind: "expression", parse: e => { if (!e.match("_")) return; let n = e.parseGroup(); if (b(n) !== "To") return; let i = e.parseArguments("implicit"); if (i) return ["Limit", ["Function", i[0], p(n, 1)], p(n, 2)] }, serialize: (e, n) => { let i = p(n, 1), t = p(i, 2), r = p(n, 2); return N(["\\lim_{", e.serialize(t), "\\to", e.serialize(r), "}", e.serialize(p(i, 1))]) } }, { name: "MinusPlus", latexTrigger: ["\\mp"], kind: "infix", associativity: "both", precedence: sn }, { name: "Multiply", latexTrigger: ["\\times"], kind: "infix", associativity: "both", precedence: ze, serialize: Ws }, { latexTrigger: ["\\cdot"], kind: "infix", associativity: "both", precedence: ze, parse: (e, n, i) => { let t = e.parseExpression({ ...i, minPrec: ze + 2 }); return t === null ? ["Multiply", n, Yn] : bi("Multiply", n, t) } }, { latexTrigger: ["*"], kind: "infix", associativity: "both", precedence: ze, parse: (e, n, i) => { let t = e.parseExpression({ ...i, minPrec: ze + 2 }); return t === null ? ["Multiply", n, Yn] : bi("Multiply", n, t) } }, { name: "Mod", latexTrigger: "\\bmod", kind: "infix", precedence: an, serialize: (e, n) => { if (G(n) !== 2) return ""; let i = e.serialize(p(n, 1)), t = e.serialize(p(n, 2)); return N([i, "\\bmod", t]) } }, { latexTrigger: "\\mod", kind: "infix", precedence: an, parse: "Mod" }, { latexTrigger: "\\pmod", kind: "prefix", precedence: A, parse: e => { let n = e.parseGroup() ?? e.parseToken(); return ["Mod", H(n)] } }, { name: "Congruent", serialize: (e, n) => { let i = e.serialize(p(n, 1)), t = e.serialize(p(n, 2)); if (p(n, 3) === null) return N([i, "\\equiv", t]); let r = e.serialize(p(n, 3)); return N([i, "\\equiv", t, "\\pmod{", r, "}"]) } }, { name: "Negate", latexTrigger: ["-"], kind: "prefix", precedence: re + 2, parse: (e, n) => { if (/\d/.test(e.peek)) return null; let i = e.index; if (e.parseNumber() !== null) return e.index = i, null; let t = e.parseExpression({ ...n, minPrec: re + 3 }); return ["Negate", H(t)] } }, { kind: "matchfix", openTrigger: "||", closeTrigger: "||", parse: (e, n) => oe(n) ? null : ["Norm", n] }, { name: "Norm", kind: "matchfix", openTrigger: ["\\left", "\\Vert"], closeTrigger: ["\\right", "\\Vert"], parse: (e, n) => oe(n) ? null : ["Norm", n] }, { name: "PlusMinus", latexTrigger: ["\\pm"], kind: "infix", associativity: "both", precedence: sn, serialize: (e, n) => { let i = p(n, 1); if (i === null) return "\\pm"; if (G(n) === 1) return N(["\\pm", e.serialize(i)]); let t = p(n, 2); return N([e.serialize(i), "\\pm", e.serialize(t)]) } }, { latexTrigger: ["\\pm"], kind: "prefix", precedence: sn, parse: (e, n) => { let i = e.parseExpression({ ...n, minPrec: 400 }); return ["PlusMinus", H(i)] } }, { latexTrigger: ["\\plusmn"], kind: "infix", associativity: "both", precedence: sn, parse: (e, n, i) => { let t = e.parseExpression({ ...i, minPrec: 400 }); return ["PlusMinus", n, H(t)] } }, { latexTrigger: ["\\plusmn"], kind: "prefix", precedence: sn, parse: (e, n) => { let i = e.parseExpression({ ...n, minPrec: 400 }); return ["PlusMinus", H(i)] } }, { name: "Power", latexTrigger: ["^"], kind: "infix", serialize: so }, { latexTrigger: "\\prod", precedence: ze, name: "Product", parse: Zs("Product", ze), serialize: Hs("\\prod") }, { name: "Rational", precedence: an, serialize: (e, n) => n && G(n) === 1 ? "\\operatorname{Rational}" + e.wrapArguments(n) : js(e, n) }, { name: "Root", serialize: so }, { name: "Round", identifierTrigger: "round", kind: "function" }, { name: "Square", precedence: 720, serialize: (e, n) => e.wrapShort(p(n, 1)) + "^2" }, { latexTrigger: ["\\sum"], precedence: re, name: "Sum", parse: Zs("Sum", re), serialize: Hs("\\sum") }, { name: "Sign", identifierTrigger: "sgn", kind: "function" }, { name: "Sqrt", latexTrigger: ["\\sqrt"], parse: Nf, serialize: so }, { name: "Subtract", latexTrigger: ["-"], kind: "infix", associativity: "both", precedence: re + 2, parse: (e, n, i) => { let t = e.parseExpression({ ...i, minPrec: re + 3 }); return ["Subtract", n, H(t)] }, serialize: (e, n) => { let i = e.wrap(p(n, 1), re + 2), t = e.wrap(p(n, 2), re + 3); return N([i, "-", t]) } }]; function Zs(e, n) { return i => { i.skipSpace(); let t = null, r = null; for (; !(r && t) && (i.peek === "_" || i.peek === "^");)i.match("_") ? r = i.parseGroup() ?? i.parseToken() : i.match("^") && (t = i.parseGroup() ?? i.parseToken()), i.skipSpace(); (r === "Nothing" || oe(r)) && (r = null), (t === "Nothing" || oe(t)) && (t = null); let o = null, s = null; b(r) === "Equal" ? (o = p(r, 1), s = p(r, 2)) : o = r; let a = i.parseExpression({ minPrec: n + 1 }); return a ? t ? [e, a, ["Tuple", o ?? "Nothing", s ?? 1, t]] : s ? [e, a, ["Tuple", o ?? "Nothing", s]] : o ? [e, a, ["Tuple", o]] : [e, a] : [e] } } function Hs(e) { return (n, i) => { if (!p(i, 1)) return e; let t = p(i, 2), r = b(t); r !== "Tuple" && r !== "Triple" && r !== "Pair" && r !== "Single" && (t = null); let o = p(t, 1); o && b(o) === "Hold" && (o = p(o, 1)); let s = p(i, 1); if (!t) return p(i, 2) ? N([e, "_{", n.serialize(p(i, 2)), "}", n.serialize(s)]) : N([e, n.serialize(s)]); let a = p(t, 2), u = []; o && V(o) !== "Nothing" && a ? u = [n.serialize(o), "=", n.serialize(a)] : o && V(o) !== "Nothing" ? u = [n.serialize(o)] : a && (u = [n.serialize(a)]), u.length > 0 && (u = ["_{", ...u, "}"]); let l = []; return p(t, 3) && (l = ["^{", n.serialize(p(t, 3)), "}"]), N([e, ...l, ...u, n.serialize(s)]) } } function Js(e, n) { let i = null, t = null; n.match("_") && (i = n.parseStringGroup()?.trim() ?? n.nextToken(), t = Number.parseFloat(i ?? "10")); let r = n.parseArguments("implicit"); return r === null ? e : t === 10 ? ["Log", r[0]] : t === 2 ? ["Lb", ...r] : i === null ? [e, ...r] : ["Log", ...r, i] } function ao(e, n, i, t, r) { if (n.minPrec >= t) return null; let o = i ? [i] : ["Nothing"], s = !1; for (; !s;) { for (s = !0, e.skipSpace(); e.match(r);)o.push("Nothing"), e.skipSpace(); if (e.atTerminator(n)) o.push("Nothing"); else { let a = e.parseExpression({ ...n, minPrec: t }); o.push(a ?? "Nothing"), s = a === null } s || (e.skipSpace(), s = !e.match(r)) } return o } function Gt(e = "") { return (n, i) => { if (!i) return ""; let t = B(i) ?? []; if (t.length === 0) return ""; if (t.length === 1) return n.serialize(t[0]); e = { "&": "\\&", ":": "\\colon", "|": "\\mvert", "-": "-", "\xB7": "\\cdot", "\u2012": "-", "\u2013": "--", "\u2014": "---", "\u2015": "-", "\u2022": "\\bullet", "\u2026": "\\ldots" }[e] ?? e; let r = t.reduce((o, s) => (o.push(n.serialize(s), e), o), []); return r.pop(), N(r) } } var Qs = [{ latexTrigger: ["\\placeholder"], kind: "symbol", parse: e => { for (; e.match("<space>");); if (e.match("[")) for (; !e.match("]") && !e.atBoundary;)e.nextToken(); for (; e.match("<space>");); if (e.match("<{>")) for (; !e.match("<}>") && !e.atBoundary;)e.nextToken(); return "Nothing" } }, { name: "Function", latexTrigger: ["\\mapsto"], kind: "infix", precedence: sn, parse: (e, n) => { let i = []; if (b(n) === "Delimiter" && (n = p(n, 1) ?? "Nothing"), b(n) === "Sequence") for (let r of B(n) ?? []) { if (!V(r)) return null; i.push(V(r)) } else { if (!V(n)) return null; i = [V(n)] } let t = e.parseExpression({ minPrec: sn }) ?? "Nothing"; return b(t) === "Delimiter" && (t = p(t, 1) ?? "Nothing"), b(t) === "Sequence" && (t = ["Block", ...B(t) ?? []]), ["Function", t, ...i] }, serialize: (e, n) => { let i = B(n); return i === null || i.length < 1 ? "()\\mapsto()" : i.length === 1 ? N(["()", "\\mapsto", e.serialize(p(n, 1))]) : i.length === 2 ? N([e.serialize(p(n, 2)), "\\mapsto", e.serialize(p(n, 1))]) : N([e.wrapString((B(n)?.slice(1) ?? []).map(t => e.serialize(t)).join(", "), "normal"), "\\mapsto", e.serialize(p(n, 1))]) } }, { name: "Apply", kind: "function", identifierTrigger: "apply", serialize: (e, n) => { if (typeof p(n, 1) == "string") { let t = n.slice(1); return e.serialize(t) } return e.serializeFunction(B(n)) } }, { latexTrigger: "\\lhd", kind: "infix", precedence: 20, parse: "Apply" }, { latexTrigger: "\\rhd", kind: "infix", precedence: 20, parse: (e, n) => ["Apply", e.parseExpression({ minPrec: 21 }) ?? "Nothing", n] }, { name: "Assign", latexTrigger: "\\coloneq", kind: "infix", associativity: "right", precedence: di, serialize: (e, n) => { let i = oo(p(n, 1)); if (b(p(n, 2)) === "Function") { let t = p(n, 2), r = oo(p(t, 1)), o = B(t)?.slice(1) ?? []; return N([e.serialize(i), e.wrapString(o.map(s => e.serialize(s)).join(", "), e.options.applyFunctionStyle(n, e.level)), "\\coloneq", e.serialize(r)]) } return N([e.serialize(i), "\\coloneq", e.serialize(p(n, 2))]) }, parse: jt }, { latexTrigger: "\\coloneqq", kind: "infix", associativity: "right", precedence: di, parse: jt }, { latexTrigger: "\\colonequals", kind: "infix", associativity: "right", precedence: di, parse: jt }, { latexTrigger: [":", "="], kind: "infix", associativity: "right", precedence: di, parse: jt }, { name: "BaseForm", serialize: (e, n) => { let i = M(p(n, 2)) ?? NaN; if (isFinite(i) && i >= 2 && i <= 36) { let t = M(p(n, 1)) ?? NaN; if (isFinite(t) && Number.isInteger(t)) { let r = Number(t).toString(i), o = 0; if (i === 2 || i === 10 ? o = 4 : i === 16 ? o = 2 : i > 16 && (o = 4), o > 0) { let s = r; r = ""; for (let a = 0; a < s.length; a++)a > 0 && a % o === 0 && (r = "\\, " + r), r = s[s.length - a - 1] + r } return `(\\text{${r}}_{${i}}` } } return "\\operatorname{BaseForm}(" + e.serialize(p(n, 1)) + ", " + e.serialize(p(n, 2)) + ")" } }, { name: "Sequence", serialize: Gt(" ") }, { name: "InvisibleOperator", serialize: Gt("") }, { name: "Delimiter", serialize: (e, n) => { let i = e.options.groupStyle(n, e.level + 1), t = p(n, 1), r = b(t), o = { Set: "{,}", List: "[,]", Tuple: "(,)", Single: "(,)", Pair: "(,)", Triple: "(,)", Sequence: "(,)", String: '""' }[typeof r == "string" ? r : ""], s = o ? t : ["Sequence", t]; if (o ?? (o = "(,)"), G(n) > 1) { let d = z(p(n, 2)); typeof d == "string" && d.length <= 3 && (o = d) } let [a, u, l] = ["", "", ""]; o.length === 3 ? [a, u, l] = o : o.length === 2 ? [a, l] = o : o.length === 1 && (u = o); let f = t ? s ? Gt(u)(e, s) : e.serialize(t) : ""; return e.wrapString(f, i, a + l) } }, { name: "Domain", serialize: (e, n) => b(n) === "Error" ? e.serialize(n) : `\\mathbf{${e.serialize(p(n, 1))}}` }, { latexTrigger: ["\\mathtip"], parse: e => { let n = e.parseGroup(); return e.parseGroup(), n } }, { latexTrigger: ["\\texttip"], parse: e => { let n = e.parseGroup(); return e.parseGroup(), n } }, { latexTrigger: ["\\error"], parse: e => ["Error", e.parseGroup()] }, { name: "Error", serialize: (e, n) => { let i = p(n, 1); if (z(i) === "missing") return `\\error{${e.options.missingSymbol ?? "\\placeholder{}"}}`; let t = Df(e, n) || "\\blacksquare", r = b(i) === "ErrorCode" ? z(p(i, 1)) : z(i); return r === "incompatible-domain" ? V(p(i, 3)) === "Undefined" ? `\\mathtip{\\error{${t}}}{\\notin ${e.serialize(p(i, 2))}}` : `\\mathtip{\\error{${t}}}{\\in ${e.serialize(p(i, 3))}\\notin ${e.serialize(p(i, 2))}}` : typeof r == "string" ? `\\error{${t}}` : `\\error{${t}}` } }, { name: "ErrorCode", serialize: (e, n) => { let i = z(p(n, 1)); return i === "missing" ? e.options.missingSymbol ?? "\\placeholder{}" : i === "unexpected-command" || i === "unexpected-operator" || i === "unexpected-token" || i === "invalid-identifier" || i === "unknown-environment" || i === "unexpected-base" || i === "incompatible-domain" || i === "invalid-domain" ? "" : `\\texttip{\\error{\\blacksquare}}{\\mathtt{${i}}}` } }, { name: "FromLatex", serialize: (e, n) => `\\texttt{${Bf(z(p(n, 1)))}}` }, { name: "Latex", serialize: (e, n) => n === null ? "" : N(Yi(n, i => z(i) ?? e.serialize(i))) }, { name: "LatexString", serialize: (e, n) => n === null ? "" : N(Yi(n, i => e.serialize(i))) }, { name: "LatexTokens", serialize: Tf }, { name: "List", kind: "matchfix", openTrigger: "[", closeTrigger: "]", parse: Xs, serialize: (e, n) => N(["\\bigl\\lbrack", Gt(", ")(e, n), "\\bigr\\rbrack"]) }, { kind: "matchfix", openTrigger: "(", closeTrigger: ")", parse: If }, { latexTrigger: [","], kind: "infix", precedence: 20, parse: (e, n, i) => { let t = ao(e, i, n, 20, ","); return t === null ? null : ["Delimiter", ["Sequence", ...t], { str: "," }] } }, { latexTrigger: [","], kind: "prefix", precedence: 20, parse: (e, n) => { let i = ao(e, n, null, 20, ","); return i === null ? null : ["Delimiter", ["Sequence", ...i], { str: "," }] } }, { name: "Range", latexTrigger: [".", "."], kind: "infix", precedence: 10, parse: kf, serialize: (e, n) => { let i = B(n); if (i === null) return ""; if (i.length === 1) return "1.." + e.serialize(p(n, 1)); if (i.length === 2) return e.wrap(p(n, 1), 10) + ".." + e.wrap(p(n, 2), 10); if (i.length === 3) { let t = M(p(n, 3)), r = M(p(n, 1)); return t !== null && r !== null ? e.wrap(p(n, 1), 10) + "," + e.wrap(r + t, 10) + ".." + e.wrap(p(n, 2), 10) : e.wrap(p(n, 1), 10) + "," + (e.wrap(p(n, 3), re) + "+" + e.wrap(p(n, 3), re)) + ".." + e.wrap(p(n, 2), 10) } return "" } }, { latexTrigger: [";"], kind: "infix", precedence: 19, parse: (e, n, i) => { let t = ao(e, i, n, 19, ";"); return t === null ? null : ["Delimiter", ["Sequence", ...t], "';'"] } }, { name: "String", latexTrigger: ["\\text"], parse: e => lo(e), serialize: (e, n) => { let i = B(n); return i === null || i.length === 0 ? "\\text{}" : N(["\\text{", i.map(t => e.serialize(t)).join(""), "}"]) } }, { name: "Subscript", latexTrigger: ["_"], kind: "infix", serialize: (e, n) => G(n) === 2 ? e.serialize(p(n, 1)) + "_{" + e.serialize(p(n, 2)) + "}" : "_{" + e.serialize(p(n, 1)) + "}" }, { name: "Superplus", latexTrigger: ["^", "+"], kind: "postfix" }, { name: "Subplus", latexTrigger: ["_", "+"], kind: "postfix" }, { name: "Superminus", latexTrigger: ["^", "-"], kind: "postfix" }, { name: "Subminus", latexTrigger: ["_", "-"], kind: "postfix" }, { latexTrigger: ["^", "*"], kind: "postfix", parse: (e, n) => ["Superstar", n] }, { latexTrigger: ["_", "*"], kind: "postfix", parse: (e, n) => ["Substar", n] }, { name: "Substar", latexTrigger: ["_", "\\star"], kind: "postfix" }, { name: "Superdagger", latexTrigger: ["^", "\\dagger"], kind: "postfix" }, { latexTrigger: ["^", "\\dag"], kind: "postfix", parse: (e, n) => ["Superdagger", n] }, { name: "Prime", latexTrigger: ["^", "\\prime"], kind: "postfix", parse: (e, n) => vn(e, n, 1), serialize: (e, n) => { let i = M(p(n, 2)) ?? 1, t = e.serialize(p(n, 1)); return i === 1 ? t + "^\\prime" : i === 2 ? t + "^\\doubleprime" : i === 3 ? t + "^\\tripleprime" : t + "^{(" + e.serialize(p(n, 2)) + ")}" } }, { latexTrigger: "^{\\prime\\prime}", kind: "postfix", parse: (e, n) => vn(e, n, 2) }, { latexTrigger: "^{\\prime\\prime\\prime}", kind: "postfix", parse: (e, n) => vn(e, n, 3) }, { latexTrigger: ["^", "\\doubleprime"], kind: "postfix", parse: (e, n) => vn(e, n, 2) }, { latexTrigger: ["^", "\\tripleprime"], kind: "postfix", parse: (e, n) => vn(e, n, 3) }, { latexTrigger: "'", kind: "postfix", precedence: 810, parse: (e, n) => vn(e, n, 1) }, { latexTrigger: "\\prime", kind: "postfix", precedence: 810, parse: (e, n) => vn(e, n, 1) }, { latexTrigger: "\\doubleprime", kind: "postfix", precedence: 810, parse: (e, n) => vn(e, n, 2) }, { latexTrigger: "\\tripleprime", kind: "postfix", precedence: 810, parse: (e, n) => vn(e, n, 3) }, { latexTrigger: ["^", "<{>", "("], kind: "postfix", parse: (e, n) => { if (!e.computeEngine?.box(n)?.domain?.isFunction) return null; let i = e.index; e.addBoundary([")"]); let t = e.parseExpression(); return !e.matchBoundary() || !e.match("<}>") ? (e.index = i, null) : ["Derivative", n, t] } }, { name: "InverseFunction", latexTrigger: "^{-1", kind: "postfix", parse: (e, n) => { if (!e.computeEngine?.box(n)?.domain?.isFunction) return null; let i = 0, t = e.index; for (; !e.atEnd && !e.match("<}>");)if (e.match("'")) i++; else if (e.match("\\prime")) i++; else if (e.match("\\doubleprime")) i += 2; else if (e.match("\\tripleprime")) i += 3; else return e.index = t, null; return i === 1 ? ["Derivative", ["InverseFunction", n]] : i > 0 ? ["Derivative", ["InverseFunction", n], i] : ["InverseFunction", n] }, serialize: (e, n) => e.serialize(p(n, 1)) + "^{-1}" }, { name: "Derivative", serialize: (e, n) => { let i = M(p(n, 2)) ?? 1, t = e.serialize(p(n, 1)); return i === 1 ? t + "^{\\prime}" : i === 2 ? t + "^{\\doubleprime}" : i === 3 ? t + "^{\\tripleprime}" : t + "^{(" + e.serialize(p(n, 2)) + ")}" } }, { kind: "environment", name: "Which", identifierTrigger: "cases", parse: uo, serialize: (e, n) => { let i = [], t = B(n); if (t) for (let r = 0; r <= t.length - 2; r += 2) { let o = []; o.push(e.serialize(t[r + 1])), o.push(e.serialize(t[r])), i.push(o.join("&")) } return N(["\\begin{cases}", i.join("\\\\"), "\\end{cases}"]) } }, { kind: "environment", identifierTrigger: "dcases", parse: uo }, { kind: "environment", identifierTrigger: "rcases", parse: uo }]; function lo(e, n) { if (!e.match("<{>")) return "''"; let i = [], t = "", r = null; for (; !e.atEnd && !e.match("<}>");)if (e.peek === "<{>") i.push(lo(e)); else if (e.match("\\textbf") && e.match("<{>")) i.push(lo(e, { "font-weight": "bold" })); else if (e.match("\\color")) { let s = e.parseStringGroup(); s !== null && (r !== null && t ? i.push(["Style", t, { dict: r }]) : t && i.push(["String", t]), t = "", r = { color: s }) } else if (e.match("<space>")) t += " "; else if (e.match("<$>")) { let s = e.index, a = e.parseExpression() ?? ["Sequence"]; e.skipSpace(), e.match("<$>") ? i.push(a) : (t += "$", e.index = s) } else if (e.match("<$$>")) { let s = e.index, a = e.parseExpression() ?? ["Sequence"]; e.skipSpace(), e.match("<$$>") ? i.push(a) : (t += "$$", e.index = s) } else { let s = e.matchChar() ?? e.nextToken(); t += { "\\enskip": "\u2002", "\\enspace": "\u2002", "\\quad": "\u2003", "\\qquad": "\u2003\u2003", "\\space": "\u2003", "\\ ": "\u2003", "\\;": "\u2004", "\\,": "\u2009", "\\:": "\u205F", "\\!": "", "\\{": "{", "\\}": "}", "\\$": "$", "\\&": "&", "\\#": "#", "\\%": "%", "\\_": "_", "\\textbackslash": "\\", "\\textasciitilde": "~", "\\textasciicircum": "^", "\\textless": "<", "\\textgreater": ">", "\\textbar": "|", "\\textunderscore": "_", "\\textbraceleft": "{", "\\textbraceright": "}", "\\textasciigrave": "`", "\\textquotesingle": "'", "\\textquotedblleft": "\u201C", "\\textquotedblright": "\u201D", "\\textquotedbl": '"', "\\textquoteleft": "\u2018", "\\textquoteright": "\u2019", "\\textbullet": "\u2022", "\\textdagger": "\u2020", "\\textdaggerdbl": "\u2021", "\\textsection": "\xA7", "\\textparagraph": "\xB6", "\\textperiodcentered": "\xB7", "\\textellipsis": "\u2026", "\\textemdash": "\u2014", "\\textendash": "\u2013", "\\textregistered": "\xAE", "\\texttrademark": "\u2122", "\\textdegree": "\xB0" }[s] ?? s } r !== null && t ? i.push(["Style", `'${t}'`, { dict: r }]) : t && i.push(`'${t}'`); let o; return i.length === 1 ? o = i[0] : i.every(s => z(s) !== null) ? o = "'" + i.map(s => z(s)).join() + "'" : o = ["String", ...i], n ? ["Style", o, { dict: n }] : o } function Tf(e, n) { return n === null ? "" : N(Yi(n, i => { let t = z(i); return t === null ? e.serialize(i) : t === "<{>" ? "{" : t === "<}>" ? "}" : t === "<$>" ? "$" : t === "<$$>" ? "$$" : t === "<space>" ? " " : t })) } function Bf(e) { return e === null ? "" : e.replace(/[{}\[\]\\:\-\$%]/g, n => ({ "{": "\\lbrace ", "}": "\\rbrace ", "[": "\\lbrack ", "]": "\\rbrack ", ":": "\\colon ", "\\": "\\backslash " })[n] ?? "\\" + n) } function Df(e, n) { let i = p(n, 2); return i ? b(i) === "LatexString" ? z(p(i, 1)) ?? "" : b(i) === "Hold" ? e.serialize(p(i, 1)) : e.serialize(i) : "" } function vn(e, n, i) { let t = b(n); if (t === "Derivative" || t === "Prime") { let r = M(p(n, 2)) ?? 1; return [t, H(p(n, 1)), r + i] } return e.computeEngine?.box(n)?.domain?.isFunction ? i === 1 ? ["Derivative", n] : ["Derivative", n, i] : i === 1 ? ["Prime", H(n)] : ["Prime", H(n), i] } function If(e, n) { if (n === null || oe(n)) return ["Delimiter"]; let i = b(n); if (i === "Delimiter" && p(n, 2)) { let t = z(p(n, 2)); if (t?.length === 1) return ["Delimiter", p(n, 1) ?? ["Sequence"], { str: `(${t})` }] } return i === "Sequence" ? G(n) === 0 ? ["Delimiter"] : G(n) === 1 ? ["Delimiter", p(n, 1)] : ["Delimiter", n] : i === "Matrix" && (z(p(n, 2)) ?? "..") === ".." ? ["Matrix", p(n, 1)] : ["Delimiter", n] } function Xs(e, n) { if (n === null || oe(n)) return ["List"]; let i = b(n); if (i === "Range" || i === "Linspace") return n; if (i === "Sequence") return ["List", ...B(n) ?? []]; if (i === "Delimiter") { let t = z(p(n, 2)) ?? "..."; if (t === ";" || t === ".;.") return ["List", ...(B(p(n, 1)) ?? []).map(r => Xs(e, r))]; if (t === "," || t === ".,.") return n = p(n, 1), b(n) === "Sequence" ? ["List", ...B(n) ?? []] : ["List", n ?? ["Sequence"]] } return ["List", n] } function kf(e, n) { let i = e.index; if (!n) return null; let t = null, r = null; if (b(n) === "Sequence") { if (G(n) !== 2) return null; if (t = p(n, 1), r = p(n, 2), r === null) return e.index = i, null } else t = p(n, 1); if (t === null) return null; let o = e.parseExpression({ minPrec: 0 }); if (!o) return e.index = i, null; if (r) { let s = M(r), a = M(t); return s !== null && a !== null ? ["Range", t, o, s - a] : ["Range", t, o, ["Subtract", r, t]] } return ["Range", t, o] } var yi = { "(": "(", ")": ")", "[": "\\lbrack", "]": "\\rbrack", "\u27E6": "\\llbrack", "\u27E7": "\\rrbrack", "{": "\\lbrace", "}": "\\rbrace", "<": "\\langle", ">": "\\rangle", "\u2016": "\\Vert", "\\": "\\backslash", "\u2308": "\\lceil", "\u2309": "\\rceil", "\u230A": "\\lfloor", "\u230B": "\\rfloor", "\u231C": "\\ulcorner", "\u231D": "\\urcorner", "\u231E": "\\llcorner", "\u231F": "\\lrcorner", "\u23B0": "\\lmoustache", "\u23B1": "\\rmoustache" }; function jt(e, n) { let i = e.index; if (b(n) === "InvisibleOperator" && G(n) === 2 && b(p(n, 2)) === "Delimiter") { let r = V(p(n, 1)); if (!r) return null; let o = e.parseExpression({ minPrec: 0 }); if (o === null) return e.index = i, null; let s = p(p(n, 2), 1), a = []; return b(s) === "Sequence" ? a = B(s) ?? [] : s && (a = [s]), ["Assign", r, ["Function", o, ...a ?? []]] } if (typeof b(n) == "string") { let r = b(n), o = B(n) ?? [], s = e.parseExpression({ minPrec: 0 }); return s === null ? (e.index = i, null) : ["Assign", r, ["Function", s, ...o]] } if (!V(n)) return null; let t = e.parseExpression({ minPrec: 0 }); return t === null ? (e.index = i, null) : ["Assign", n, t] } function uo(e) { let n = e.parseTabular(); if (!n) return ["Which"]; let i = ["Which"]; for (let t of n) if (t.length === 1) i.push("True"), i.push(t[0]); else if (t.length === 2) { let r = z(t[1]); i.push(r ? "True" : to(t[1]) ?? "True"), i.push(t[0]) } return i } var fo = [{ latexTrigger: ["\\not", "<"], kind: "infix", associativity: "right", precedence: 246, parse: "NotLess" }, { name: "NotLess", latexTrigger: ["\\nless"], kind: "infix", associativity: "right", precedence: 246 }, { latexTrigger: ["<"], kind: "infix", associativity: "right", precedence: 245, parse: "Less" }, { name: "Less", latexTrigger: ["\\lt"], kind: "infix", associativity: "right", precedence: 245 }, { latexTrigger: ["<", "="], kind: "infix", associativity: "right", precedence: 241, parse: "LessEqual" }, { name: "LessEqual", latexTrigger: ["\\le"], kind: "infix", associativity: "right", precedence: 241 }, { latexTrigger: ["\\leq"], kind: "infix", associativity: "right", precedence: 241, parse: "LessEqual" }, { latexTrigger: ["\\leqslant"], kind: "infix", associativity: "right", precedence: A + 5, parse: "LessEqual" }, { name: "LessNotEqual", latexTrigger: ["\\lneqq"], kind: "infix", associativity: "right", precedence: A }, { name: "NotLessNotEqual", latexTrigger: ["\\nleqq"], kind: "infix", associativity: "right", precedence: A }, { name: "LessOverEqual", latexTrigger: ["\\leqq"], kind: "infix", associativity: "right", precedence: A + 5 }, { name: "GreaterOverEqual", latexTrigger: ["\\geqq"], kind: "infix", associativity: "right", precedence: A + 5, parse: "GreaterEqual" }, { name: "Equal", latexTrigger: ["="], kind: "infix", associativity: "right", precedence: A }, { latexTrigger: ["*", "="], kind: "infix", associativity: "right", precedence: A, parse: "StarEqual" }, { name: "StarEqual", latexTrigger: ["\\star", "="], kind: "infix", associativity: "right", precedence: A }, { name: "PlusEqual", latexTrigger: ["+", "="], kind: "infix", associativity: "right", precedence: A }, { name: "MinusEqual", latexTrigger: ["-", "="], kind: "infix", associativity: "right", precedence: A }, { name: "SlashEqual", latexTrigger: ["/", "="], kind: "infix", associativity: "right", precedence: A }, { name: "EqualEqual", latexTrigger: ["=", "="], kind: "infix", associativity: "right", precedence: A }, { name: "EqualEqualEqual", latexTrigger: ["=", "=", "="], kind: "infix", associativity: "right", precedence: A + 5 }, { name: "TildeFullEqual", latexTrigger: ["\\cong"], kind: "infix", associativity: "right", precedence: A }, { name: "NotTildeFullEqual", latexTrigger: ["\\ncong"], kind: "infix", associativity: "right", precedence: A }, { name: "Approx", latexTrigger: ["\\approx"], kind: "infix", associativity: "right", precedence: 247 }, { name: "NotApprox", latexTrigger: ["\\not", "\\approx"], kind: "infix", associativity: "right", precedence: 247 }, { name: "ApproxEqual", latexTrigger: ["\\approxeq"], kind: "infix", associativity: "right", precedence: A }, { name: "NotApproxEqual", latexTrigger: ["\\not", "\\approxeq"], kind: "infix", associativity: "right", precedence: 250 }, { name: "NotEqual", latexTrigger: ["\\ne"], kind: "infix", associativity: "right", precedence: 255 }, { name: "Unequal", latexTrigger: ["!", "="], kind: "infix", associativity: "right", precedence: A }, { name: "GreaterEqual", latexTrigger: ["\\ge"], kind: "infix", associativity: "right", precedence: 242 }, { latexTrigger: ["\\geq"], kind: "infix", associativity: "right", precedence: 242, parse: "GreaterEqual" }, { latexTrigger: [">", "="], kind: "infix", associativity: "right", precedence: 243, parse: "GreaterEqual" }, { latexTrigger: ["\\geqslant"], kind: "infix", associativity: "right", precedence: A + 5, parse: "GreaterEqual" }, { name: "GreaterNotEqual", latexTrigger: ["\\gneqq"], kind: "infix", associativity: "right", precedence: A }, { name: "NotGreaterNotEqual", latexTrigger: ["\\ngeqq"], kind: "infix", associativity: "right", precedence: A }, { latexTrigger: [">"], kind: "infix", associativity: "right", precedence: 245, parse: "Greater" }, { name: "Greater", latexTrigger: ["\\gt"], kind: "infix", associativity: "right", precedence: 245 }, { name: "NotGreater", latexTrigger: ["\\ngtr"], kind: "infix", associativity: "right", precedence: 244 }, { latexTrigger: ["\\not", ">"], kind: "infix", associativity: "right", precedence: 244, parse: "NotGreater" }, { name: "RingEqual", latexTrigger: ["\\circeq"], kind: "infix", associativity: "right", precedence: A }, { name: "TriangleEqual", latexTrigger: ["\\triangleq"], kind: "infix", associativity: "right", precedence: A }, { name: "DotEqual", latexTrigger: ["\\doteq"], kind: "infix", associativity: "right", precedence: A + 5 }, { name: "DotEqualDot", latexTrigger: ["\\doteqdot"], kind: "infix", associativity: "right", precedence: A + 5 }, { name: "FallingDotEqual", latexTrigger: ["\\fallingdotseq"], kind: "infix", associativity: "right", precedence: A + 5 }, { name: "RisingDotEqual", latexTrigger: ["\\fallingdotseq"], kind: "infix", associativity: "right", precedence: A + 5 }, { name: "QuestionEqual", latexTrigger: ["\\questeq"], kind: "infix", associativity: "right", precedence: A }, { name: "MuchLess", latexTrigger: ["\\ll"], kind: "infix", associativity: "right", precedence: A }, { name: "MuchGreater", latexTrigger: ["\\gg"], kind: "infix", associativity: "right", precedence: A }, { name: "Precedes", latexTrigger: ["\\prec"], kind: "infix", associativity: "right", precedence: A }, { name: "Succeeds", latexTrigger: ["\\succ"], kind: "infix", associativity: "right", precedence: A }, { name: "PrecedesEqual", latexTrigger: ["\\preccurlyeq"], kind: "infix", associativity: "right", precedence: A }, { name: "SucceedsEqual", latexTrigger: ["\\curlyeqprec"], kind: "infix", associativity: "right", precedence: A }, { name: "NotPrecedes", latexTrigger: ["\\nprec"], kind: "infix", associativity: "right", precedence: A }, { name: "NotSucceeds", latexTrigger: ["\\nsucc"], kind: "infix", associativity: "right", precedence: A }, { name: "Between", latexTrigger: ["\\between"], kind: "infix", associativity: "right", precedence: A + 5 }]; function Ki(e) { return typeof e != "string" ? !1 : fo.some(n => n.name === e) } var ea = [{ name: "Matrix", serialize: (e, n) => { let i = B(p(n, 1)) ?? []; return Ks(e, i, z(p(n, 2)), z(p(n, 3))) } }, { name: "Vector", serialize: (e, n) => { let i = B(n) ?? []; return Ks(e, i.map(t => ["List", t]), z(p(n, 2)), z(p(n, 3))) } }, { kind: "environment", identifierTrigger: "pmatrix", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: "()" }, { str: n }] : [i, t] } }, { kind: "environment", identifierTrigger: "bmatrix", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: "[]" }, { str: n }] : [i, t, { str: "[]" }] } }, { kind: "environment", identifierTrigger: "Bmatrix", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: "{}" }, { str: n }] : [i, t, { str: "{}" }] } }, { kind: "environment", identifierTrigger: "vmatrix", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: "||" }, { str: n }] : [i, t, { str: "||" }] } }, { kind: "environment", identifierTrigger: "Vmatrix", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: "\u2016\u2016" }, { str: n }] : [i, t, { str: "\u2016\u2016" }] } }, { kind: "environment", identifierTrigger: "smallmatrix", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: "()" }, { str: n }] : [i, t] } }, { kind: "environment", identifierTrigger: "array", parse: e => { let n = _n(e, !1), [i, t] = Nn(e); return n ? [i, t, { str: ".." }, { str: n }] : [i, t, { str: ".." }] } }, { kind: "environment", identifierTrigger: "matrix", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: ".." }, { str: n }] : [i, t, { str: ".." }] } }, { kind: "environment", identifierTrigger: "matrix*", parse: e => { let n = _n(e), [i, t] = Nn(e); return n ? [i, t, { str: ".." }, { str: n }] : [i, t, { str: ".." }] } }, { name: "ConjugateTranspose", kind: "postfix", latexTrigger: ["^", "\\star"] }, { kind: "postfix", latexTrigger: ["^", "\\H"], parse: "ConjugateTranspose" }, { kind: "postfix", latexTrigger: ["^", "\\dagger"], parse: (e, n) => ["ConjugateTranspose", n] }, { kind: "postfix", latexTrigger: ["^", "\\ast"], parse: (e, n) => ["ConjugateTranspose", n] }, { kind: "postfix", latexTrigger: ["^", "\\top"], parse: (e, n) => ["Transpose", n] }, { kind: "postfix", latexTrigger: ["^", "\\intercal"], parse: (e, n) => ["Transpose", n] }, { name: "Transpose", kind: "postfix", latexTrigger: ["^", "T"] }, { name: "PseudoInverse", kind: "postfix", latexTrigger: ["^", "+"] }, { name: "Trace", kind: "function", identifierTrigger: "tr" }, { name: "Determinant", kind: "function", identifierTrigger: "det" }]; function Nn(e) { let n = e.parseTabular(); return n ? ["Matrix", ["List", ...n.map(i => ["List", ...i])]] : ["", null] } function _n(e, n = !0) { let i = e.parseStringGroup(n)?.trim(); if (!i) return ""; let t = ""; for (let r of i) r === "c" && (t += "="), r === "l" && (t += "<"), r === "r" && (t += ">"), r === "|" && (t += "|"), r === ":" && (t += ":"); return t } function Ks(e, n, i, t) {
      i ?? (i = "()"); let [r, o] = ["", ""]; typeof i == "string" && i.length === 2 && ([r, o] = i); let s = ""; if (t) for (let f of t) f === "<" ? s += "l" : f === ">" ? s += "r" : f === "=" ? s += "c" : f === "|" ? s += "|" : f === ":" && (s += ":"); let a = []; for (let f of n ?? []) { let d = []; for (let c of B(f) ?? []) d.push(e.serialize(c)); a.push(d.join(" & ")) } let u = a.join(`\\\\
`), l = s.length > 0 ? `[${s}]` : ""; return r === "(" && o === ")" ? N(["\\begin{pmatrix}", l, u, "\\end{pmatrix}"]) : r === "[" && o === "]" ? N(["\\begin{bmatrix}", l, u, "\\end{bmatrix}"]) : r === "{" && o === "}" ? N(["\\begin{Bmatrix}", l, u, "\\end{Bmatrix}"]) : r === "|" && o === "|" ? N(["\\begin{vmatrix}", l, u, "\\end{vmatrix}"]) : r === "\u2016" && o === "\u2016" ? N(["\\begin{Vmatrix}", l, u, "\\end{Vmatrix}"]) : r === "{" && o === "." ? N(["\\begin{dcases}", l, u, "\\end{dcases}"]) : r === "." && o === "}" ? N(["\\begin{rcases}", l, u, "\\end{rcases}"]) : s || r !== "." || o !== "." ? N(["\\left", yi[r] ?? r, "\\begin{array}", `{${s}}`, u, "\\end{array}", "\\right", yi[o] ?? o]) : N(["\\begin{matrix}", u, "\\end{matrix}"])
    } var na = [{ name: "True", kind: "symbol", latexTrigger: ["\\top"] }, { kind: "symbol", latexTrigger: "\\mathrm{True}", parse: "True" }, { kind: "symbol", latexTrigger: "\\operator{True}", parse: "True" }, { kind: "symbol", latexTrigger: "\\mathsf{T}", parse: "True" }, { name: "False", kind: "symbol", latexTrigger: ["\\bot"] }, { kind: "symbol", latexTrigger: "\\operator{False}", parse: "False" }, { kind: "symbol", latexTrigger: "\\mathsf{F}", parse: "False" }, { name: "And", kind: "infix", latexTrigger: ["\\land"], precedence: 317 }, { kind: "infix", latexTrigger: ["\\wedge"], parse: "And", precedence: 317 }, { kind: "infix", latexTrigger: "\\&", parse: "And", precedence: 317 }, { kind: "infix", latexTrigger: "\\operatorname{and}", parse: "And", precedence: 317 }, { name: "Or", kind: "infix", latexTrigger: ["\\lor"], precedence: 310 }, { kind: "infix", latexTrigger: ["\\vee"], parse: "Or", precedence: 310 }, { kind: "infix", latexTrigger: "\\parallel", parse: "Or", precedence: 310 }, { kind: "infix", latexTrigger: "\\operatorname{or}", parse: "Or", precedence: 310 }, { name: "Xor", kind: "infix", latexTrigger: ["\\veebar"], precedence: 315 }, { name: "Not", kind: "prefix", latexTrigger: ["\\lnot"], precedence: 880 }, { kind: "prefix", latexTrigger: ["\\neg"], parse: "Not", precedence: 880 }, { name: "Nand", kind: "infix", latexTrigger: ["\\barwedge"], precedence: 315 }, { name: "Nor", kind: "infix", latexTrigger: ["\u22BD"], precedence: 315 }, { kind: "function", identifierTrigger: "and", parse: "And" }, { kind: "function", identifierTrigger: "or", parse: "Or" }, { kind: "function", identifierTrigger: "not", parse: "Not" }, { name: "Implies", kind: "infix", precedence: 220, associativity: "right", latexTrigger: ["\\implies"], serialize: "\\implies" }, { latexTrigger: ["\\Rightarrow"], kind: "infix", precedence: 220, associativity: "right", parse: "Implies" }, { name: "Equivalent", latexTrigger: ["\\iff"], kind: "infix", associativity: "right", precedence: 219 }, { latexTrigger: ["\\Leftrightarrow"], kind: "infix", associativity: "right", precedence: 219, parse: "Equivalent" }, { latexTrigger: ["\\equiv"], kind: "infix", associativity: "right", precedence: 219, parse: (e, n, i) => { let t = e.parseExpression({ ...i, minPrec: 219 }), r = e.index, o = e.parseExpression({ ...i, minPrec: 219 }); return o && b(o) === "Mod" ? ["Congruent", n, t, H(p(o, 1))] : (e.index = r, ["Equivalent", n, H(t)]) } }, { name: "Proves", kind: "infix", latexTrigger: ["\\vdash"], precedence: 220, associativity: "right", serialize: "\\vdash" }, { name: "Entails", kind: "infix", latexTrigger: ["\\vDash"], precedence: 220, associativity: "right", serialize: "\\vDash" }, { name: "Satisfies", kind: "infix", latexTrigger: ["\\models"], precedence: 220, associativity: "right", serialize: "\\models" }]; function Ae(e) { return n => { let i = n.parseGroup(); return i === null ? [e] : [e, i] } } var ia = [{ name: "Overscript", latexTrigger: ["\\overset"], kind: "infix", precedence: 700 }, { name: "Underscript", latexTrigger: ["\\underset"], kind: "infix", precedence: 700 }, { name: "Increment", latexTrigger: ["+", "+"], kind: "postfix", precedence: 880 }, { name: "Decrement", latexTrigger: ["-", "-"], kind: "postfix", precedence: 880 }, { name: "PreIncrement", latexTrigger: ["+", "+"], kind: "prefix", precedence: 880 }, { name: "PreDecrement", latexTrigger: ["-", "-"], kind: "prefix", precedence: 880 }, { name: "Ring", latexTrigger: ["\\circ"], kind: "infix", precedence: 265 }, { name: "StringJoin", latexTrigger: ["\\lt", "\\gt"], kind: "infix", precedence: 780 }, { name: "Starstar", latexTrigger: ["\\star", "\\star"], kind: "infix", precedence: 780 }, { name: "PartialDerivative", latexTrigger: ["\\partial"], kind: "prefix", parse: e => { let n = !1, i = "Nothing", t = "Nothing"; for (; !n;)e.skipSpace(), e.match("_") ? t = e.parseGroup() ?? e.parseToken() : e.match("^") ? i = e.parseGroup() ?? e.parseToken() : n = !0; let r = Ut(t); if (r && (t = ["List", ...r]), t === null || i === null) return null; let o = e.parseGroup() ?? "Nothing"; if (o !== "Nothing" && !oe(o)) { let s = e.parseArguments() ?? ["Nothing"]; o = [o, ...s] } return ["PartialDerivative", o, t, i] }, serialize: (e, n) => { let i = "\\partial", t = p(n, 1), r = p(n, 2), o = p(n, 3); return r !== null && r !== "Nothing" && (b(r) === "List" ? i += "_{" + e.serialize(["Sequence", ...B(r) ?? []]) + "}" : i += "_{" + e.serialize(r) + "}"), o !== null && o !== "Nothing" && (i += "^{" + e.serialize(o) + "}"), t !== null && t !== "Nothing" && (i += e.serialize(t)), i }, precedence: 740 }, { name: "OverBar", latexTrigger: ["\\overline"], parse: Ae("OverBar") }, { name: "UnderBar", latexTrigger: ["\\underline"], parse: Ae("UnderBar") }, { name: "OverVector", latexTrigger: ["\\vec"], parse: Ae("OverVector") }, { name: "OverTilde", latexTrigger: ["\\tilde"], parse: Ae("OverTilde") }, { name: "OverHat", latexTrigger: ["\\hat"], parse: Ae("OverHat") }, { name: "OverRightArrow", latexTrigger: ["\\overrightarrow"], parse: Ae("OverRightArrow") }, { name: "OverLeftArrow", latexTrigger: ["\\overleftarrow"], parse: Ae("OverLeftArrow") }, { name: "OverRightDoubleArrow", latexTrigger: ["\\Overrightarrow"], parse: Ae("OverRightDoubleArrow") }, { name: "OverLeftHarpoon", latexTrigger: ["\\overleftharpoon"], parse: Ae("OverLeftHarpoon") }, { name: "OverRightHarpoon", latexTrigger: ["\\overrightharpoon"], parse: Ae("OverRightHarpoon") }, { name: "OverLeftRightArrow", latexTrigger: ["\\overleftrightarrow"], parse: Ae("OverLeftRightArrow") }, { name: "OverBrace", latexTrigger: ["\\overbrace"], parse: Ae("OverBrace") }, { name: "OverLineSegment", latexTrigger: ["\\overlinesegment"], parse: Ae("OverLineSegment") }, { name: "OverGroup", latexTrigger: ["\\overgroup"], parse: Ae("OverGroup") }, { latexTrigger: ["\\displaystyle"], parse: () => ["Sequence"] }, { latexTrigger: ["\\textstyle"], parse: () => ["Sequence"] }, { latexTrigger: ["\\scriptstyle"], parse: () => ["Sequence"] }, { latexTrigger: ["\\scriptscriptstyle"], parse: () => ["Sequence"] }, { latexTrigger: ["\\tiny"], parse: () => ["Sequence"] }, { latexTrigger: ["\\scriptsize"], parse: () => ["Sequence"] }, { latexTrigger: ["\\footnotesize"], parse: () => ["Sequence"] }, { latexTrigger: ["\\small"], parse: () => ["Sequence"] }, { latexTrigger: ["\\normalsize"], parse: () => ["Sequence"] }, { latexTrigger: ["\\large"], parse: () => ["Sequence"] }, { latexTrigger: ["\\Large"], parse: () => ["Sequence"] }, { latexTrigger: ["\\LARGE"], parse: () => ["Sequence"] }, { latexTrigger: ["\\huge"], parse: () => ["Sequence"] }, { latexTrigger: ["\\Huge"], parse: () => ["Sequence"] }, { name: "Style", serialize: (e, n) => { let i = e.serialize(p(n, 1)), t = Xn(p(n, 2)); if (t === null) return i; z(t.display) === "block" ? i = N(["{\\displaystyle", i, "}"]) : z(t.display) === "inline" ? i = N(["{\\textstyle", i, "}"]) : z(t.display) === "script" ? i = N(["{\\scriptstyle", i, "}"]) : z(t.display) === "scriptscript" && (i = N(["{\\scriptscriptstyle", i, "}"])); let r = M(t.size); return r !== null && r >= 1 && r <= 10 && (i = N(["{", { 1: "\\tiny", 2: "\\scriptsize", 3: "\\footnotesize", 4: "\\small", 5: "\\normalsize", 6: "\\large", 7: "\\Large", 8: "\\LARGE", 9: "\\huge", 10: "\\Huge" }[r], i, "}"])), i } }, { latexTrigger: ["\\!"], parse: () => ["HorizontalSpacing", -3] }, { latexTrigger: ["\\ "], parse: () => ["HorizontalSpacing", 6] }, { latexTrigger: ["\\:"], parse: () => ["HorizontalSpacing", 4] }, { latexTrigger: ["\\enskip"], parse: () => ["HorizontalSpacing", 9] }, { latexTrigger: ["\\quad"], parse: () => ["HorizontalSpacing", 18] }, { latexTrigger: ["\\qquad"], parse: () => ["HorizontalSpacing", 36] }, { latexTrigger: ["\\,"], parse: () => ["HorizontalSpacing", 3] }, { latexTrigger: ["\\;"], parse: () => ["HorizontalSpacing", 5] }, { latexTrigger: ["\\enspace"], parse: () => ["HorizontalSpacing", 9] }, { name: "HorizontalSpacing", serialize: (e, n) => { if (p(n, 2)) return e.serialize(p(n, 1)); let i = M(p(n, 1)); return i === null ? "" : { "-3": "\\!", 6: "\\ ", 3: "\\,", 4: "\\:", 5: "\\;", 9: "\\enspace", 18: "\\quad", 36: "\\qquad" }[i] ?? "" } }]; function Y(e) { return (n, i) => { let t = { "\\arcsin": "Arcsin", "\\arccos": "Arccos", "\\arctan": "Arctan", "\\arctg": "Arctan", "\\arcctg": "Arctan", "\\arcsec": "Arcsec", "\\arccsc": " Arccsc", "\\arsinh": "Arsinh", "\\arcosh": "Arcosh", "\\artanh": "Artanh", "\\arcsech": "Arcsech", "\\arccsch": "Arcsch", "\\ch": "Cosh", "\\cos": "Cos", "\\cosec": "Csc", "\\cosh": "Csch", "\\cot": "Cot", "\\cotg": "Cot", "\\coth": "Coth", "\\csc": "Csc", "\\ctg": "Cot", "\\cth": "Coth", "\\sec": "Sec", "\\sin": "Sin", "\\sinh": "Sinh", "\\sh": "Sinh", "\\tan": "Tan", "\\tanh": "Tanh", "\\tg": "Tan", "\\th": "Tanh" }[e ?? ""] ?? e ?? ""; if (n.atTerminator(i)) return t; let r = t; do { let u = n.parsePostfixOperator(r, i); if (u === null) break; r = u } while (!0); let o = null; n.match("^") && (o = n.parseGroup() ?? n.parseToken()); let s = n.parseArguments("implicit", i), a = s === null ? r : typeof r == "string" ? [r, ...s] : ["Apply", r, ...s]; return o === null ? a : ["Power", a, o] } } var ta = [{ name: "Arcsin", latexTrigger: ["\\arcsin"], parse: Y("Arcsin") }, { name: "Arccos", latexTrigger: ["\\arccos"], parse: Y("Arccos") }, { name: "Arctan", latexTrigger: ["\\arctan"], parse: Y("Arctan") }, { latexTrigger: ["\\arctg"], parse: Y("Arctan") }, { name: "Arccot", latexTrigger: ["\\arcctg"], parse: Y("Arccot") }, { name: "Arcsec", latexTrigger: "arcsec", parse: Y("Arcsec") }, { name: "Arccsc", latexTrigger: ["\\arccsc"], parse: Y("Arccsc") }, { name: "Arsinh", latexTrigger: ["\\arsinh"], parse: Y("Arsinh") }, { name: "Arcosh", latexTrigger: ["\\arcosh"], parse: Y("Arcosh") }, { name: "Artanh", latexTrigger: ["\\artanh"], parse: Y("Artanh") }, { name: "Arsech", latexTrigger: ["\\arsech"], parse: Y("Arsech") }, { name: "Arcsch", latexTrigger: ["\\arcsch"], parse: Y("Arcsch") }, { latexTrigger: ["\\ch"], parse: Y("Cosh") }, { name: "Cosec", latexTrigger: ["\\cosec"], parse: Y("Cosec") }, { name: "Cosh", latexTrigger: ["\\cosh"], parse: Y("Cosh") }, { name: "Cot", latexTrigger: ["\\cot"], parse: Y("Cot") }, { latexTrigger: ["\\cotg"], parse: Y("Cot") }, { name: "Coth", latexTrigger: ["\\coth"], parse: Y("Coth") }, { name: "Csc", latexTrigger: ["\\csc"], parse: Y("Csc") }, { latexTrigger: ["\\ctg"], parse: Y("Cot") }, { latexTrigger: ["\\cth"], parse: Y("Cotanh") }, { name: "Sec", latexTrigger: ["\\sec"], parse: Y("Sec") }, { name: "Sinh", latexTrigger: ["\\sinh"], parse: Y("Sinh") }, { latexTrigger: ["\\sh"], parse: Y("Sinh") }, { name: "Tan", latexTrigger: ["\\tan"], parse: Y("Tan") }, { latexTrigger: ["\\tg"], parse: Y("Tan") }, { name: "Tanh", latexTrigger: ["\\tanh"], parse: Y("Tanh") }, { latexTrigger: ["\\th"], parse: Y("Tanh") }, { name: "Cos", latexTrigger: ["\\cos"], parse: Y("Cos") }, { name: "Sin", latexTrigger: ["\\sin"], parse: Y("Sin") }]; var oa = [{ name: "AlgebraicNumbers", latexTrigger: "\\bar\\Q" }, { name: "ComplexNumbers", latexTrigger: ["\\C"] }, { latexTrigger: "\\mathbb{C}", parse: "ComplexNumbers" }, { name: "ImaginaryNumbers", latexTrigger: ["\\imaginaryI", "\\R"] }, { name: "ExtendedComplexNumbers", latexTrigger: ["\\bar", "\\C"] }, { name: "EmptySet", latexTrigger: ["\\emptyset"] }, { latexTrigger: ["\\varnothing"], parse: "EmptySet" }, { name: "Integers", latexTrigger: ["\\Z"] }, { latexTrigger: "\\mathbb{Z}", parse: "Integers" }, { name: "RationalNumbers", latexTrigger: ["\\Q"] }, { name: "RealNumbers", latexTrigger: ["\\R"] }, { latexTrigger: "\\mathbb{R}", parse: "RealNumbers" }, { name: "ExtendedRealNumbers", latexTrigger: ["\\bar", "\\R"] }, { name: "TranscendentalNumberss", latexTrigger: "\\R-\\bar\\Q" }, { latexTrigger: "\\R\\backslash\\bar\\Q", parse: "TranscendentalNumbers" }, { name: "NegativeNumbers", latexTrigger: "\\R^-" }, { latexTrigger: "\\R^{-}", parse: "NegativeNumbers" }, { latexTrigger: "\\R_-", parse: "NegativeNumbers" }, { latexTrigger: "\\R_{-}", parse: "NegativeNumbers" }, { latexTrigger: "\\R^{\\lt}", parse: "NegativeNumbers" }, { name: "PositiveNumbers", latexTrigger: "\\R^+" }, { latexTrigger: "\\R^{+}", parse: "PositiveNumbers" }, { latexTrigger: "\\R_+", parse: "PositiveNumbers" }, { latexTrigger: "\\R_{+}", parse: "PositiveNumbers" }, { latexTrigger: "\\R^{\\gt}", parse: "PositiveNumbers" }, { name: "NonPositiveNumbers", latexTrigger: "\\R^{0-}" }, { latexTrigger: "\\R^{-0}", parse: "NonPositiveNumbers" }, { latexTrigger: "\\R^{\\leq}", parse: "NonPositiveNumbers" }, { name: "NegativeIntegers", latexTrigger: "\\Z^-" }, { latexTrigger: "\\Z^-", parse: "NegativeIntegers" }, { latexTrigger: "\\Z^{-}", parse: "NegativeIntegers" }, { latexTrigger: "\\Z_-", parse: "NegativeIntegers" }, { latexTrigger: "\\Z_{-}", parse: "NegativeIntegers" }, { latexTrigger: "\\Z^{\\lt}", parse: "NegativeIntegers" }, { name: "PositiveIntegers", latexTrigger: "\\Z^+" }, { latexTrigger: "\\Z^{+}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z_+", parse: "PositiveIntegers" }, { latexTrigger: "\\Z_{+}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z^{\\gt}", parse: "PositiveIntegers" }, { latexTrigger: "\\Z^{\\gt0}", parse: "PositiveIntegers" }, { latexTrigger: "\\N^+", parse: "PositiveIntegers" }, { latexTrigger: "\\N^{+}", parse: "PositiveIntegers" }, { latexTrigger: "\\N^*", parse: "PositiveIntegers" }, { latexTrigger: "\\N^{*}", parse: "PositiveIntegers" }, { latexTrigger: "\\N^\\star", parse: "PositiveIntegers" }, { latexTrigger: "\\N^{\\star}", parse: "PositiveIntegers" }, { latexTrigger: "\\N_1", parse: "PositiveIntegers" }, { latexTrigger: "\\N_{1}", parse: "PositiveIntegers" }, { name: "NonNegativeIntegers", latexTrigger: ["\\N"] }, { latexTrigger: "\\Z^{+0}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\Z^{\\geq}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\Z^{\\geq0}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\Z^{0+}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\mathbb{N}", parse: "NonNegativeIntegers" }, { latexTrigger: "\\N_0", parse: "NonNegativeIntegers" }, { latexTrigger: "\\N_{0}", parse: "NonNegativeIntegers" }, { name: "CartesianProduct", latexTrigger: ["\\times"], kind: "infix", associativity: "right", precedence: 390, parse: (e, n, i) => { if (390 < i.minPrec) return null; let t = e.computeEngine; if (!t || !t.box(n).domain.isCompatible("Sets")) return null; let r = e.index, o = e.parseExpression({ ...i, minPrec: 390 }); return o === null || t.box(n).domain.isCompatible("Sets") !== !0 ? (e.index = r, null) : ["CartesianProduct", n, o] } }, { latexTrigger: ["^", "\\complement"], kind: "postfix", parse: (e, n) => ["Complement", n] }, { name: "Complement", latexTrigger: ["^", "<{>", "\\complement", "<}>"], kind: "postfix" }, { name: "Intersection", latexTrigger: ["\\cap"], kind: "infix", precedence: 350 }, { name: "Interval", serialize: ra }, { name: "Multiple", serialize: ra }, { name: "Union", latexTrigger: ["\\cup"], kind: "infix", precedence: 350 }, { name: "Set", kind: "matchfix", openTrigger: "{", closeTrigger: "}", precedence: 20, parse: (e, n) => n === null || oe(n) ? "EmptySet" : (b(n) == "Delimiter" && z(p(n, 2)) === "," && (n = p(n, 1)), b(n) !== "Sequence" ? ["Set", n] : ["Set", ...B(n) ?? []]), serialize: (e, n) => N(["\\lbrace", (B(n) ?? []).map(i => e.serialize(i)).join(", "), "\\rbrace"]) }, { name: "SetMinus", latexTrigger: ["\\setminus"], kind: "infix", precedence: 650 }, { name: "SymmetricDifference", latexTrigger: ["\\triangle"], kind: "infix", precedence: A }, { latexTrigger: ["\\ni"], kind: "infix", associativity: "right", precedence: 160, parse: (e, n, i) => { let t = e.parseExpression(i); return t === null ? null : ["Element", t, n] } }, { name: "Element", latexTrigger: ["\\in"], kind: "infix", precedence: 240 }, { name: "NotElement", latexTrigger: ["\\notin"], kind: "infix", precedence: 240 }, { name: "NotSubset", latexTrigger: ["\\nsubset"], kind: "infix", associativity: "right", precedence: 240 }, { name: "NotSuperset", latexTrigger: ["\\nsupset"], kind: "infix", associativity: "right", precedence: 240 }, { name: "NotSubsetNotEqual", latexTrigger: ["\\nsubseteq"], kind: "infix", associativity: "right", precedence: 240 }, { name: "NotSupersetNotEqual", latexTrigger: ["\\nsupseteq"], kind: "infix", associativity: "right", precedence: 240 }, { name: "SquareSubset", latexTrigger: ["\\sqsubset"], kind: "infix", associativity: "right", precedence: 265 }, { name: "SquareSubsetEqual", latexTrigger: ["\\sqsubseteq"], kind: "infix", associativity: "right", precedence: 265 }, { name: "SquareSuperset", latexTrigger: ["\\sqsupset"], kind: "infix", associativity: "right", precedence: 265 }, { name: "SquareSupersetEqual", latexTrigger: ["\\sqsupseteq"], kind: "infix", associativity: "right", precedence: 265 }, { name: "Subset", latexTrigger: ["\\subset"], kind: "infix", associativity: "right", precedence: 240 }, { latexTrigger: ["\\subsetneq"], kind: "infix", associativity: "right", precedence: 240, parse: "Subset" }, { latexTrigger: ["\\varsubsetneqq"], kind: "infix", associativity: "right", precedence: 240, parse: "Subset" }, { name: "SubsetEqual", latexTrigger: ["\\subseteq"], kind: "infix", precedence: 240 }, { name: "Superset", latexTrigger: ["\\supset"], kind: "infix", associativity: "right", precedence: 240 }, { latexTrigger: ["\\supsetneq"], kind: "infix", associativity: "right", precedence: 240, parse: "Superset" }, { latexTrigger: ["\\varsupsetneq"], kind: "infix", associativity: "right", precedence: 240, parse: "Superset" }, { name: "SupersetEqual", latexTrigger: ["\\supseteq"], kind: "infix", associativity: "right", precedence: 240 }]; function ra(e, n) { if (n === null) return ""; let i = b(n); if (i === null) return ""; if (i === "Set") return G(n) === 0 ? "\\emptyset" : G(n) === 2 && b(p(n, 2)) === "Condition" ? N(["\\left\\lbrace", e.serialize(p(n, 1)), "\\middle\\mid", e.serialize(p(n, 2)), "\\right\\rbrace"]) : N(["\\left\\lbrace", ...(B(n) ?? []).map(r => e.serialize(r) + " ,"), "\\right\\rbrace"]); if (i === "Range") return N(["\\mathopen\\lbrack", e.serialize(p(n, 1)), ", ", e.serialize(p(n, 2)), "\\mathclose\\rbrack"]); if (i === "Interval") { let r = p(n, 1), o = p(n, 2), s = !1, a = !1; return b(r) === "Open" && (r = p(r, 1), s = !0), b(o) === "Open" && (o = p(o, 1), a = !0), N([`\\mathopen${s ? "\\rbrack" : "\\lbrack"}`, e.serialize(r), ", ", e.serialize(o), `\\mathclose${a ? "\\lbrack" : "\\rbrack"}`]) } let t = e.numericSetStyle(n, e.level); return "" } function Ei(e, n = 1) { return i => { i.skipSpace(); let t = null, r = null; for (; !(r !== null && t !== null) && (i.peek === "_" || i.peek === "^");)i.match("_") ? r = i.parseGroup() ?? i.parseToken() : i.match("^") && (t = i.parseGroup() ?? i.parseToken()), i.skipSpace(); (r === "Nothing" || oe(r)) && (r = null), (t === "Nothing" || oe(t)) && (t = null); let [o, s] = Cf(i, n); if (o && !s) { if (b(o) === "Add" || b(o) === "Subtract") { let a = [], u = []; for (let l of B(o) ?? []) if (s) u.push(l); else { let f;[f, s] = fn(l), a.push(f ?? l) } if (s !== null && u.length > 0) return ["Add", sa(i, e, ["Add", ...a], [{ index: s, sub: r, sup: t }]), ...u] } else if (b(o) === "Divide") { let a;[a, s] = fn(p(o, 1)), a !== null && s !== null && (o = ["Divide", a, p(o, 2)]) } } return sa(i, e, o, [{ index: s, sub: r, sup: t }]) } } function sa(e, n, i, t) { if (i && t.length === 0) return [n, i]; if (i ?? (i = "Nothing"), e.computeEngine) { let r = e.computeEngine, o = !1, s = {}; for (let a of t) a.index && (o = !0, s[a.index] = { domain: "ExtendedRealNumbers" }); o && r.pushScope().declare(s), i = r.box(i).json, o && r.popScope() } return [n, i, ...t.map(r => wf(r))] } function wf(e) { let n = e.index ? ["Hold", e.index] : "Nothing"; return e.sup !== null ? ["Tuple", n, e.sub ?? "Nothing", e.sup] : e.sub !== null ? ["Tuple", n, e.sub] : n } function Cf(e, n = 1) { let i = e.index, t = !1, r = e.parseExpression({ minPrec: 266, condition: () => ((e.matchAll(["\\mathrm", "<{>", "d", "<}>"]) || e.matchAll(["\\operatorname", "<{>", "d", "<}>"])) && (t = !0), t) }); if (t || (e.index = i, r = e.parseExpression({ minPrec: 266, condition: () => (e.match("d") && (t = !0), t) })), r && !t) return fn(r); let o = Mf(e, n); return [r, o[0] ?? null] } function Mf(e, n = 1) { e.skipSpace(); let i = [], t = V(e.parseSymbol()); return t === null ? [] : (i.push(t), i) } function fn(e) { let n = b(e), i = p(e, 1); if (!i) return [e, null]; if (n === "Sequence" && G(e) === 1) return fn(i); if (n === "Multiply" || n === "InvisibleOperator") { let t = B(e); if (t && t.length > 1) { let r = V(t[t.length - 2]); if (r === "d" || r === "d_upright") return t.length === 2 ? [null, V(t[1])] : t.length === 3 ? [t[0], V(t[2])] : [["Multiply", ...t.slice(0, -2)], V(t[t.length - 1])]; let [o, s] = fn(t[t.length - 1]); if (o) return [["Multiply", ...t.slice(0, -1), o], s] } } else if (n === "Delimiter") { let [t, r] = fn(i); if (r) return t ? [["Delimiter", ["Sequence", t], ...B(e).slice(1)], r] : [null, r] } else if (n === "Add") { let t = B(e); if (t && t.length > 0) { let [r, o] = fn(t[t.length - 1]); if (o) { if (r) return [["Add", ...t.slice(0, -1), r], o]; if (t.length > 2) return [["Add", ...t.slice(0, -1)], o]; if (t.length > 2) return [t[0], o] } } } else if (n === "Negate") { let [t, r] = fn(i); if (r) return [t ? ["Negate", t] : null, r] } else if (n === "Divide") { let [t, r] = fn(i); if (r) return [["Divide", t ?? 1, p(e, 2)], r] } else { let t = B(e); if (t?.length === 1) { let [r, o] = fn(t[0]); if (o) return [[b(e), r], o] } } return [e, null] } function aa(e) { return (n, i) => { if (!p(i, 1)) return e; let t = p(i, 2), r = b(t), o = null; r === "Tuple" || r === "Triple" || r === "Pair" || r === "Single" ? o = p(t, 1) : r === "Hold" ? o = p(t, 1) : (o = p(t, 1) ?? "x", t = null), b(o) === "Hold" && (o = p(o, 1)); let s = o !== null ? V(o) : null, a = p(i, 1); if (b(a) === "Lambda" && p(a, 1) && (a = Ji(p(a, 1), { _: s ?? "x", _1: s ?? "x" })), !t) return !s || s === "Nothing" ? N([e, "\\!", n.serialize(a)]) : N([e, "\\!", n.serialize(a), "\\,\\operatorname{d}", n.serialize(s)]); let u = p(t, 2) ? V(p(t, 2)) : null, l = t && u !== "Nothing" ? n.serialize(p(t, 2)) : ""; l.length > 0 && (l = `_{${l}}`); let f = "", d = p(t, 3) ? V(p(t, 3)) : null; return p(t, 3) && d !== "Nothing" && (f = `^{${n.serialize(p(t, 3))}}`), N([e, f, l, "\\!", n.serialize(a), ...s && V(s) !== "Nothing" ? ["\\,\\operatorname{d}", n.serialize(s)] : []]) } } var ua = [{ kind: "expression", name: "Integrate", latexTrigger: ["\\int"], parse: Ei("Integrate"), serialize: aa("\\int") }, { kind: "expression", latexTrigger: ["\\iint"], parse: Ei("Integrate", 2) }, { kind: "expression", latexTrigger: ["\\iiint"], parse: Ei("Integrate", 3) }, { kind: "expression", name: "CircularIntegrate", latexTrigger: ["\\oint"], parse: Ei("CircularIntegrate"), serialize: aa("\\oint") }, { kind: "expression", latexTrigger: ["\\oiint"], parse: Ei("CircularIntegrate", 2) }, { kind: "expression", latexTrigger: ["\\oiiint"], parse: Ei("CircularIntegrate", 3) }]; var nn = [["alpha", "\\alpha", 945], ["beta", "\\beta", 946], ["gamma", "\\gamma", 947], ["delta", "\\delta", 948], ["epsilon", "\\epsilon", 949], ["epsilonSymbol", "\\varepsilon", 1013], ["zeta", "\\zeta", 950], ["eta", "\\eta", 951], ["theta", "\\theta", 952], ["thetaSymbol", "\\vartheta", 977], ["iota", "\\iota", 953], ["kappa", "\\kappa", 954], ["kappaSymbol", "\\varkappa", 1008], ["lambda", "\\lambda", 955], ["mu", "\\mu", 956], ["nu", "\\nu", 957], ["xi", "\\xi", 958], ["omicron", "\\omicron", 959], ["pi", "\\pi", 960], ["piSymbol", "\\varpi", 982], ["rho", "\\rho", 961], ["rhoSymbol", "\\varrho", 1009], ["sigma", "\\sigma", 963], ["finalSigma", "\\varsigma", 962], ["tau", "\\tau", 964], ["phi", "\\phi", 981], ["phiLetter", "\\varphi", 966], ["upsilon", "\\upsilon", 965], ["chi", "\\chi", 967], ["psi", "\\psi", 968], ["omega", "\\omega", 969], ["Alpha", "\\Alpha", 913], ["Beta", "\\Beta", 914], ["Gamma", "\\Gamma", 915], ["Delta", "\\Delta", 916], ["Epsilon", "\\Epsilon", 917], ["Zeta", "\\Zeta", 918], ["Eta", "\\Eta", 919], ["Theta", "\\Theta", 920], ["Iota", "\\Iota", 921], ["Kappa", "\\Kappa", 922], ["Lambda", "\\Lambda", 923], ["Mu", "\\Mu", 924], ["Nu", "\\Nu", 925], ["Xi", "\\Xi", 926], ["Omicron", "\\Omicron", 927], ["Rho", "\\Rho", 929], ["Sigma", "\\Sigma", 931], ["Tau", "\\Tau", 932], ["Phi", "\\Phi", 934], ["Upsilon", "\\Upsilon", 933], ["Chi", "\\Chi", 935], ["Psi", "\\Psi", 936], ["Omega", "\\Omega", 937], ["digamma", "\\digamma", 989], ["aleph", "\\aleph", 8501], ["bet", "\\beth", 8502], ["gimel", "\\gimel", 8503], ["dalet", "\\daleth", 8504], ["ell", "\\ell", 8499], ["turnedCapitalF", "\\Finv", 8498], ["turnedCapitalG", "\\Game", 8513], ["weierstrass", "\\wp", 8472], ["eth", "\\eth", 240], ["invertedOhm", "\\mho", 8487], ["hBar", "\\hbar", 295], ["hSlash", "\\hslash", 8463], ["blackClubSuit", "\\clubsuit", 9827], ["whiteHeartSuit", "\\heartsuit", 9825], ["blackSpadeSuit", "\\spadesuit", 9824], ["whiteDiamondSuit", "\\diamondsuit", 9826], ["sharp", "\\sharp", 9839], ["flat", "\\flat", 9837], ["natural", "\\natural", 9838]], la = [...nn.map(([e, n, i]) => ({ kind: "symbol", name: e, latexTrigger: [n], parse: e })), ...nn.map(([e, n, i]) => ({ kind: "symbol", latexTrigger: [String.fromCodePoint(i)], parse: e }))]; var fa = [{ name: "Real", kind: "function", latexTrigger: ["\\Re"] }, { name: "Imaginary", kind: "function", latexTrigger: ["\\Im"] }, { name: "Argument", kind: "function", latexTrigger: ["\\arg"] }, { name: "Conjugate", latexTrigger: ["^", "\\star"], kind: "postfix" }]; var da = [{ name: "Mean", kind: "function", identifierTrigger: "mean" }, { name: "Median", kind: "function", identifierTrigger: "median" }, { name: "StandarDeviation", kind: "function", identifierTrigger: "stddev" }, { latexTrigger: ["\\bar"], kind: "expression", parse: (e, n) => { let i = e.parseGroup() ?? e.parseToken(); return !i || !V(i) ? null : ["Mean", i] } }]; var ca = { "(": "(", ")": ")", "[": "\\lbrack", "]": "\\rbrack", "{": "\\lbrace", "}": "\\rbrace", "<": "\\langle", ">": "\\rangle", "|": "\\vert", "||": "\\Vert", "\\lceil": "\\lceil", "\\lfloor": "\\lfloor", "\\rceil": "\\rceil", "\\rfloor": "\\rfloor" }; function ma(e, n, i) { let t = Af(n, i); if (t === null) return; let r = "kind" in n ? n.kind : "expression", o = t.latexTrigger; typeof o == "string" && (e.lookahead = Math.max(e.lookahead, zt(o))); let s = $(o ?? "", []); if (s.length === 2 && /[_^]/.test(s[0]) && s[1] !== "<{>" && r !== "function" && r !== "environment" && r !== "matchfix") { let a = n.parse; !a && n.name && (r === "postfix" || r === "prefix" ? a = (u, l) => [n.name, l] : a = n.name), ma(e, { ...n, kind: r, name: void 0, serialize: void 0, parse: a, latexTrigger: [s[0], "<{>", s[1], "<}>"] }, i) } e.defs.push(t), t.name !== void 0 && (e.ids.has(t.name) && i({ severity: "warning", message: ["invalid-dictionary-entry", t.name, "Duplicate definition. The name (MathJSON identifier) must be unique, but triggers can be shared by multiple definitions."] }), e.ids.set(t.name, t)) } function co(e, n) { let i = { lookahead: 1, ids: new Map, defs: [] }; for (let t of e) ma(i, t, n); return i } function Af(e, n) { if (!Ff(e, n)) return null; let i = { kind: "kind" in e ? e.kind : "expression" }, t = null; "latexTrigger" in e && (typeof e.latexTrigger == "string" ? t = $(e.latexTrigger, []) : t = e.latexTrigger); let r = null; "identifierTrigger" in e && (r = e.identifierTrigger), t !== null && (i.latexTrigger = ln(t)), r !== null && (i.identifierTrigger = r), e.name && (i.name = e.name, i.serialize = Of(e, t, r)), i.kind === "matchfix" && ci(e) && (i.openTrigger = e.openTrigger, i.closeTrigger = e.closeTrigger), i.kind === "symbol" && jr(e) && (i.precedence = e.precedence ?? 1e4), i.kind === "expression" && Gr(e) && (i.precedence = e.precedence ?? 1e4), (i.kind === "prefix" || i.kind === "postfix") && (Zi(e) || At(e)) && (t && (t[0] === "^" || t[0] === "_") ? (i.precedence = 720, e.precedence) : i.precedence = e.precedence ?? 1e4), i.kind === "infix" && Mt(e) && (!t || t[0] !== "^" && t[0] !== "_" || !e.associativity || e.associativity, i.associativity = e.associativity ?? "non", i.precedence = e.precedence ?? 1e4); let o = Pf(e, t, r); return o && (i.parse = o), i } function Of(e, n, i) { if (typeof e.serialize == "function") return e.serialize; let t = e.kind ?? "expression"; if (t === "environment") { let s = e.identifierTrigger ?? e.name ?? "unknown"; return (a, u) => N([`\\begin{${s}}`, a.serialize(p(u, 1)), `\\end{${s}}`]) } if (ci(e)) { let s = typeof e.openTrigger == "string" ? ca[e.openTrigger] : ln(e.openTrigger), a = typeof e.closeTrigger == "string" ? ca[e.closeTrigger] : ln(e.closeTrigger); return (u, l) => N([s, u.serialize(p(l, 1)), a]) } let r = e.serialize; if (r === void 0 && n && (r = ln(n)), r) return t === "postfix" ? (s, a) => N([s.serialize(p(a, 1)), r]) : t === "prefix" ? (s, a) => N([r, s.serialize(p(a, 1))]) : t === "infix" ? (s, a) => { let u = G(a); if (u === 0) return ""; let l = e.precedence ?? 1e4; return N(B(a).flatMap((f, d) => { let c = s.wrap(f, l + 1); return d < u - 1 ? [c, r] : [c] })) } : (s, a) => b(a) ? N([r, s.wrapArguments(a)]) : r; let o = i ?? e.name ?? "unknown"; return t === "postfix" ? (s, a) => N([s.serialize(p(a, 1)), s.serializeSymbol(o)]) : t === "prefix" ? (s, a) => N([s.serializeSymbol(o), s.serialize(p(a, 1))]) : t === "infix" ? (s, a) => N([s.serialize(p(a, 1)), s.serializeSymbol(o), s.serialize(p(a, 2))]) : (s, a) => b(a) ? N([s.serializeSymbol(o), s.wrapArguments(a)]) : s.serializeSymbol(o) } function Pf(e, n, i) { if ("parse" in e && typeof e.parse == "function") return e.parse; let t = "kind" in e ? e.kind : "expression"; if (t === "environment") { let r = e.parse ?? e.name ?? i; if (r) return (o, s) => { let a = o.parseTabular(); return a === null ? null : [r, ["List", a.map(u => ["List", ...u])]] } } if (t === "function") { let r = e.parse ?? e.name ?? i; if (r) return (o, s) => { let a = o.parseArguments("enclosure", s); return a === null ? r : [r, ...a] } } if (t === "symbol") { let r = e.parse ?? e.name ?? i; if (r) return (o, s) => r } if (t === "prefix") { let r = e.parse ?? e.name ?? i; if (r) { let o = e.precedence ?? 1e4; return (s, a) => { let u = s.parseExpression({ ...a ?? [], minPrec: o }); return u === null ? null : [r, u] } } } if (t === "postfix") { let r = e.parse ?? e.name; if (r) return (o, s) => s === null ? null : [r, s] } if (t === "infix") { if (/[_^]/.test(n?.[0] ?? "")) { let a = e.name ?? e.parse; return (u, l) => [a, H(p(l, 1)), H(p(l, 2))] } let r = e.parse ?? e.name ?? i, o = e.precedence ?? 1e4, s = e.associativity ?? "non"; if (r) return (a, u, l) => { if (u === null || o < l.minPrec) return null; let f = H(a.parseExpression({ ...l, minPrec: o })); return typeof r == "string" ? bi(r, u, f, s) : [r, u, f] } } if (t === "matchfix") { let r = e.parse ?? e.name; if (r) return (o, s) => s === null || oe(s) ? null : [r, s] } if (t === "expression") { let r = e.parse ?? e.name ?? i; if (r) return () => r } if ("parse" in e) { let r = e.parse; return () => r } } function Ff(e, n) { let i = e.name ?? e.latexTrigger ?? e.identifierTrigger ?? e.openTrigger; if (!i) try { i = JSON.stringify(e) } catch { i = "???" } if (Array.isArray(i) && (i = ln(i)), "trigger" in e && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'trigger' property is deprecated. Use 'latexTrigger' or 'identifierTrigger' instead"] }), "kind" in e && !["expression", "symbol", "function", "infix", "postfix", "prefix", "matchfix", "environment"].includes(e.kind) && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'kind' property must be one of 'expression', 'symbol', 'function', 'infix', 'postfix', 'prefix', 'matchfix', 'environment'"] }), e.serialize !== void 0 && !e.name) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "A 'name' property must be provided if a 'serialize' handler is provided"] }), !1; if ("identifierTrigger" in e && (!("kind" in e) || e.kind !== "environment") && (typeof e.identifierTrigger != "string" || !Ee(e.identifierTrigger)) && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'identifierTrigger' property must be a valid identifier"] }), "name" in e && (typeof e.name != "string" ? e.name !== void 0 && n({ severity: "warning", message: ["invalid-dictionary-entry", i, "The 'name' property must be a string"] }) : Ee(e.name) || n({ severity: "warning", message: ["invalid-dictionary-entry", e.name, "The 'name' property must be a valid identifier"] })), ci(e)) { if ("latexTrigger" in e || "identifierTrigger" in Zi) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "'matchfix' operators use a 'openTrigger' and 'closeTrigger' instead of a 'latexTrigger' or 'identifierTrigger'. "] }), !1; if (!e.openTrigger || !e.closeTrigger) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected `openTrigger` and a `closeTrigger` for matchfix operator"] }), !1; if (typeof e.openTrigger != typeof e.closeTrigger) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected `openTrigger` and `closeTrigger` to both be strings or array of LatexToken"] }), !1 } if (Mt(e) || At(e) || Zi(e)) { if (Array.isArray(e.latexTrigger) && (e.latexTrigger[0] === "_" || e.latexTrigger[0] === "^") || typeof e.latexTrigger == "string" && (e.latexTrigger.startsWith("^") || e.latexTrigger.startsWith("_"))) { if (e.precedence !== void 0 || e.associativity !== void 0) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, 'Unexpected "precedence" or "associativity" for superscript/subscript operator'] }), !1 } else if (e.precedence === void 0) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, `Expected a "precedence" for ${e.kind} operator`] }), !1 } else if (e.associativity !== void 0) return n({ severity: "warning", message: ["invalid-dictionary-entry", i, 'Unexpected "associativity" operator'] }), !1; return !ci(e) && !Zr(e) && !e.latexTrigger && !e.identifierTrigger && !e.name ? (n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected a 'name', a 'latexTrigger' or a 'identifierTrigger'"] }), !1) : e.parse === void 0 && e.name === void 0 ? (n({ severity: "warning", message: ["invalid-dictionary-entry", i, "Expected a 'parse' or 'name'"] }), !1) : !0 } var vi = { algebra: Ls, arithmetic: Ys, calculus: ua, complex: fa, core: Qs, "linear-algebra": ea, logic: na, relop: fo, other: ia, physics: [{ name: "mu0", kind: "symbol", latexTrigger: "\\mu_0" }], sets: oa, statistics: da, symbols: la, trigonometry: ta }; var Rf = { "\\mathord": "", "\\mathop": "", "\\mathbin": "", "\\mathrel": "", "\\mathopen": "", "\\mathclose": "", "\\mathpunct": "", "\\mathinner": "", "\\operatorname": "", "\\mathrm": "_upright", "\\mathit": "_italic", "\\mathbf": "_bold", "\\mathscr": "_script", "\\mathcal": "_calligraphic", "\\mathfrak": "_fraktur", "\\mathsf": "_sansserif", "\\mathtt": "_monospace", "\\mathbb": "_doublestruck" }, Lf = { "\\mathring": "_ring", "\\hat": "_hat", "\\tilde": "_tilde", "\\vec": "_vec", "\\overline": "_bar", "\\underline": "_underbar", "\\dot": "_dot", "\\ddot": "_ddot", "\\dddot": "_dddot", "\\ddddot": "_ddddot", "\\acute": "_acute", "\\grave": "_grave", "\\breve": "_breve", "\\check": "_check" }; function pa(e, n) { if (e.atEnd) return null; let i = e.peek, t = { "\\_": "_", "\\#": "hash" }[i]; if (!t && !n.toplevel && (t = { "+": "plus", "-": "minus", "\\plusmn": "pm", "\\pm": "pm", "\\ast": "ast", "\\dag": "dag", "\\ddag": "ddag", "\\bot": "bottom", "\\top": "top", "\\bullet": "bullet", "\\cir": "circle", "\\diamond": "diamond", "\\times": "times", "\\square": "square", "\\star": "star" }[i]), t) return e.nextToken(), t; let r = nn.findIndex(o => o[1] === i); return r >= 0 ? (e.nextToken(), nn[r][0]) : e.matchChar() ?? e.nextToken() } function Zt(e) { let n = mo(e), i = e.index, t = Lf[e.peek] ?? null; if (t) { if (e.nextToken(), !e.match("<{>")) return e.index = i, null; let s = Zt(e); if (s === null || !e.match("<}>")) return e.index = i, null; n = `${s}${t}` } if (n === null) { for (n = ""; !e.atEnd;) { let s = e.peek; if (s === "<}>" || s === "_" || s === "^") break; let a = pa(e, { toplevel: !1 }); if (a === null) return e.index = i, null; n += a } for (; !e.atEnd && /\d/.test(e.peek);)n += e.nextToken() } for (; !e.atEnd;)if (e.match("\\degree")) n += "_deg"; else if (e.matchAll(["^", "\\prime"])) n += "_prime"; else if (e.matchAll(["^", "<{>", "\\prime", "<}>"])) n += "_prime"; else if (e.matchAll(["^", "<{>", "\\doubleprime", "<}>"])) n += "_dprime"; else if (e.matchAll(["^", "<{>", "\\prime", "\\prime", "<}>"])) n += "_dprime"; else break; let r = [], o = []; for (; !e.atEnd;)if (e.match("_")) { let s = e.match("<{>"), a = Zt(e); if (s && !e.match("<}>") || a === null) return e.index = i, null; o.push(a) } else if (e.match("^")) { let s = e.match("<{>"), a = Zt(e); if (s && !e.match("<}>") || a === null) return e.index = i, null; r.push(a) } else break; return r.length > 0 && (n += "__" + r.join("")), o.length > 0 && (n += "_" + o.join("")), n } function mo(e) { let n = e.index, i = Rf[e.peek] ?? null; if (i === null) return null; if (e.nextToken(), e.match("<{>")) { let t = "", r = { 0: "zero", 1: "one", 2: "two", 3: "three", 4: "four", 5: "five", 6: "six", 7: "seven", 8: "eight", 9: "nine" }[e.peek] ?? ""; return r && (t = r, e.nextToken()), t += Zt(e), t === null || !e.match("<}>") ? (e.index = n, null) : i === "_upright" && t.length > 1 ? t : t + i } return e.index = n, null } function po(e) { let n = e.index, i = mo(e); return i === null || Ee(i) ? (e.index = n, null) : e.error(["invalid-identifier", { str: en(i) }], n) } function et(e) { if (/^[a-zA-Z]$/.test(e.peek) || /^\p{XIDS}$/u.test(e.peek)) return e.nextToken(); let n = e.index, i = mo(e); if (!i) { for (i = ""; !e.atEnd && gi.test(i + e.peek);)i += e.nextToken(); i || (i = null) } return i ?? (i = pa(e, { toplevel: !0 })), i && (i = i.normalize(), Ee(i)) ? i : (e.index = n, null) } var ha = { "(": ["\\lparen", "("], ")": ["\\rparen", ")"], "[": ["\\lbrack", "\\[", "["], "]": ["\\rbrack", "\\]", "]"], "<": ["<", "\\langle"], ">": [">", "\\rangle"], "{": ["\\{", "\\lbrace"], "}": ["\\}", "\\rbrace"], ":": [":", "\\colon"], "|": ["|", "\\|", "\\lvert", "\\rvert"], "||": ["||", "\\Vert", "\\lVert", "\\rVert"], "\\lfloor": ["\\lfloor"], "\\rfloor": ["\\rfloor"], "\\lceil": ["\\lceil"], "\\rceil": ["\\rceil"], "\\ulcorner": ["\\ulcorner"], "\\urcorner": ["\\urcorner"], "\\llcorner": ["\\llcorner"], "\\lrcorner": ["\\lrcorner"], "\\lgroup": ["\\lgroup"], "\\rgroup": ["\\rgroup"], "\\lmoustache": ["\\lmoustache"], "\\rmoustache": ["\\rmoustache"] }, Ht = { "\\left": "\\right", "\\bigl": "\\bigr", "\\Bigl": "\\Bigr", "\\biggl": "\\biggr", "\\Biggl": "\\Biggr", "\\big": "\\big", "\\Big": "\\Big", "\\bigg": "\\bigg", "\\Bigg": "\\Bigg" }, nt = { "(": ")", "[": "]", "|": "|", "\\{": "\\}", "\\[": "\\]", "\\lbrace": "\\rbrace", "\\lparen": "\\rparen", "\\langle": "\\rangle", "\\lfloor": "\\rfloor", "\\lceil": "\\rceil", "\\vert": "\\vert", "\\lvert": "\\rvert", "\\Vert": "\\Vert", "\\lVert": "\\rVert", "\\lbrack": "\\rbrack", "\\ulcorner": "\\urcorner", "\\llcorner": "\\lrcorner", "\\lgroup": "\\rgroup", "\\lmoustache": "\\rmoustache" }, ho = { precision: 6, positiveInfinity: "\\infty", negativeInfinity: "-\\infty", notANumber: "\\operatorname{NaN}", decimalMarker: ".", groupSeparator: "\\,", exponentProduct: "\\cdot", beginExponentMarker: "10^{", endExponentMarker: "}", notation: "auto", truncationMarker: "\\ldots", beginRepeatingDigits: "\\overline{", endRepeatingDigits: "}", imaginaryUnit: "\\imaginaryI", avoidExponentsInRange: [-7, 20] }, go = { skipSpace: !0, parseArgumentsOfUnknownLatexCommands: !0, parseNumbers: "auto", parseUnknownIdentifier: (e, n) => n.computeEngine?.lookupFunction(e) !== void 0 ? "function" : "symbol", preserveLatex: !1 }, Jt = class { constructor(n, i, t, r) { this.index = 0; this._boundaries = []; this._lastPeek = ""; this._peekCounter = 0; this._tokens = n, this.options = { ...ho, ...go, ...i }, this._dictionary = t, this.computeEngine = r, this._positiveInfinityTokens = $(this.options.positiveInfinity, []), this._negativeInfinityTokens = $(this.options.negativeInfinity, []), this._notANumberTokens = $(this.options.notANumber, []), this._decimalMarkerTokens = $(this.options.decimalMarker, []), this._groupSeparatorTokens = $(this.options.groupSeparator, []), this._exponentProductTokens = $(this.options.exponentProduct, []), this._beginExponentMarkerTokens = $(this.options.beginExponentMarker, []), this._endExponentMarkerTokens = $(this.options.endExponentMarker, []), this._truncationMarkerTokens = $(this.options.truncationMarker, []), this._beginRepeatingDigitsTokens = $(this.options.beginRepeatingDigits, []), this._endRepeatingDigitsTokens = $(this.options.endRepeatingDigits, []), this._imaginaryNumberTokens = $(this.options.imaginaryUnit, []) } updateOptions(n) { for (let [i, t] of Object.entries(n)) if (i in this.options) this.options[i] = t, typeof t == "string" && (i === "positiveInfinity" && (this._positiveInfinityTokens = $(t, [])), i === "negativeInfinity" && (this._negativeInfinityTokens = $(t, [])), i === "notANumber" && (this._notANumberTokens = $(t, [])), i === "decimalMarker" && (this._decimalMarkerTokens = $(t, [])), i === "groupSeparator" && (this._groupSeparatorTokens = $(t, [])), i === "exponentProduct" && (this._exponentProductTokens = $(t, [])), i === "beginExponentMarker" && (this._beginExponentMarkerTokens = $(t, [])), i === "endExponentMarker" && (this._endExponentMarkerTokens = $(t, [])), i === "truncationMarker" && (this._truncationMarkerTokens = $(t, [])), i === "beginRepeatingDigits" && (this._beginRepeatingDigitsTokens = $(t, [])), i === "endRepeatingDigits" && (this._endRepeatingDigitsTokens = $(t, [])), i === "imaginaryNumber" && (this._imaginaryNumberTokens = $(t, []))); else throw Error(`Unexpected option "${i}"`) } get atEnd() { return this.index >= this._tokens.length } get peek() { let n = this._tokens[this.index]; if (n === this._lastPeek ? this._peekCounter += 1 : this._peekCounter = 0, this._peekCounter >= 1024) { let i = `Infinite loop detected while parsing "${this.latex(0)}" at "${this._lastPeek}" (index ${this.index})`; throw console.error(i), new Error(i) } return this._lastPeek = n, n } nextToken() { return this._tokens[this.index++] } atTerminator(n) { return this.atBoundary || ((n?.condition && n.condition(this)) ?? !1) } get atBoundary() { if (this.atEnd) return !0; let n = this.index; for (let i of this._boundaries) if (this.matchAll(i.tokens)) return this.index = n, !0; return !1 } addBoundary(n) { this._boundaries.push({ index: this.index, tokens: n }) } removeBoundary() { this._boundaries.pop() } matchBoundary() { let n = this._boundaries[this._boundaries.length - 1], i = n && this.matchAll(n.tokens); return i && this._boundaries.pop(), i } boundaryError(n) { let i = this._boundaries[this._boundaries.length - 1]; return this._boundaries.pop(), this.error(n, i.index) } latex(n, i) { return ln(this._tokens.slice(n, i)) } latexAhead(n) { return this.latex(this.index, this.index + n) } lookAhead() { let n = Math.min(this._dictionary.lookahead, this._tokens.length - this.index); if (n <= 0) return []; let i = []; for (; n > 0;)i.push([n, this.latexAhead(n--)]); return i } peekDefinitions(n) { if (this.atEnd) return []; let i = [], t = [...this.getDefs(n)]; for (let r of t) r.latexTrigger === "" && i.push([r, 0]); for (let [r, o] of this.lookAhead()) for (let s of t) s.latexTrigger === o && i.push([s, r]); for (let r of t) if (r.identifierTrigger) { let o = qf(this, r.identifierTrigger); o > 0 && i.push([r, o]) } return i } skipSpaceTokens() { for (; this.match("<space>");); } skipSpace() { if (!this.atEnd && this.peek === "<{>") { let i = this.index; for (this.nextToken(); this.match("<space>");); if (this.nextToken() === "<}>") return this.skipSpace(), !0; this.index = i } if (!this.options.skipSpace) return !1; let n = !1; for (; this.match("<space>");)n = !0; return n && this.skipSpace(), n } skipVisualSpace() { this.options.skipSpace && (this.skipSpace(), ["\\!", "\\,", "\\:", "\\;", "\\enskip", "\\enspace", "\\space", "\\quad", "\\qquad"].includes(this.peek) && (this.nextToken(), this.skipVisualSpace()), this.skipSpace()) } match(n) { return this._tokens[this.index] === n ? (this.index++, !0) : !1 } matchAll(n) { if (Array.isArray(n), n.length === 0) return !1; let i = !0, t = 0; do i = this._tokens[this.index + t] === n[t++]; while (i && t < n.length); return i && (this.index += t), i } matchAny(n) { return n.includes(this._tokens[this.index]) ? this._tokens[this.index++] : "" } matchChar() { let n = this.index, i = 0; for (; this.match("^");)i += 1; if (i < 2 && (this.index = n), i >= 2) { let t = "", r = 0; for (; r != i;) { let o = this.matchAny(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]); if (!o) break; t += o, r += 1 } if (t.length === i) return String.fromCodePoint(Number.parseInt(t, 16)) } else if (this.match("\\char")) { let t = Math.floor(this.matchLatexNumber() ?? Number.NaN); return (!Number.isFinite(t) || t < 0 || t > 1114111) && (t = 10067), String.fromCodePoint(t) } else if (this.match("\\unicode")) if (this.skipSpaceTokens(), this.match("<{>")) { let t = this.matchLatexNumber(); if (this.match("<}>") && t !== null && t >= 0 && t <= 1114111) return String.fromCodePoint(t) } else { let t = this.matchLatexNumber(); if (t !== null && t >= 0 && t <= 1114111) return String.fromCodePoint(t) } return this.index = n, null } matchDelimiter(n, i) { if (this.peek === "[") return !1; if (Array.isArray(n)) return Array.isArray(i), this.matchAll(n) ? (this.addBoundary(i), !0) : !1; Array.isArray(i); let t = this.index, r = Ht[this.peek]; return r && this.nextToken(), n === "||" && this.matchAll(["|", "|"]) ? (this.addBoundary(["|", "|"]), !0) : (ha[n] ?? [n]).includes(this.peek) ? (n = this.nextToken(), i = nt[n] ?? i, this.addBoundary(r ? [r, i] : [i]), !0) : (this.index = t, !1) } parseGroup() { let n = this.index; if (this.skipSpaceTokens(), this.match("<{>")) { this.addBoundary(["<}>"]); let i = this.parseExpression(); if (this.skipSpace(), this.matchBoundary()) return i ?? ["Sequence"]; for (; !this.matchBoundary() && !this.atEnd;)this.nextToken(); if (b(i) === "Error") return i; let t = this.error("expected-closing-delimiter", n); return i ? ["InvisibleOperator", i, t] : t } return this.index = n, null } parseToken() { if (this.skipSpace(), [...'!"#$%&(),/;:?@[]\\`|~'.split(""), "\\left", "\\bigl"].includes(this.peek)) return null; if (/^[0-9]$/.test(this.peek)) return parseInt(this.nextToken()); let i = this.parseGenericExpression() ?? this.parseSymbol(); return i || null } parseOptionalGroup() { let n = this.index; if (this.skipSpaceTokens(), this.match("[")) { this.addBoundary(["]"]); let i = this.parseExpression(); return this.skipSpace(), this.matchBoundary() ? i : this.boundaryError("expected-closing-delimiter") } return this.index = n, null } parseTabular() { let n = [], i = [], t = null; for (; !this.atBoundary;)if (this.skipSpace(), this.match("&")) i.push(t ?? "Nothing"), t = null; else if (this.match("\\\\") || this.match("\\cr")) this.skipSpace(), this.parseOptionalGroup(), t !== null && i.push(t), n.push(i), i = [], t = null; else { let r = [], o = this.peek; for (; o !== "&" && o !== "\\\\" && o !== "\\cr" && !this.atBoundary;)t = this.parseExpression({ minPrec: 0, condition: s => { let a = s.peek; return a === "&" || a === "\\\\" || a === "\\cr" } }), t ? r.push(t) : (r.push(["Error", ["'unexpected-token'", o]]), this.nextToken()), this.skipSpace(), o = this.peek; r.length > 1 ? t = ["Sequence", ...r] : t = r[0] ?? "Nothing" } return t !== null && i.push(t), i.length > 0 && n.push(i), n } parseStringGroup(n) { n === void 0 && (n = !1); let i = this.index; for (; this.match("<space>");); if (this.match(n ? "[" : "<{>")) { this.addBoundary([n ? "]" : "<}>"]); let t = this.parseStringGroupContent(); if (this.matchBoundary()) return t; this.removeBoundary() } return this.index = i, null } parseEnvironment(n) { let i = this.index; if (!this.match("\\begin")) return null; let t = this.parseStringGroup()?.trim(); if (!t) return this.error("expected-environment-name", i); this.addBoundary(["\\end", "<{>", ...t.split(""), "<}>"]); for (let r of this.getDefs("environment")) if (r.identifierTrigger === t) { let o = r.parse(this, n); return this.skipSpace(), this.matchBoundary() ? o !== null ? this.decorate(o, i) : (this.index = i, null) : this.boundaryError("unbalanced-environment") } return this.parseTabular(), this.skipSpace(), this.matchBoundary() ? this.error(["unknown-environment", { str: t }], i) : this.boundaryError("unbalanced-environment") } parseOptionalSign() { let n = !!this.matchAny(["-", "\u2212"]); for (; this.matchAny(["+", "\uFE62"]) || this.skipSpace();)this.matchAny(["-", "\u2212"]) && (n = !n); return n ? "-" : "+" } parseDecimalDigits(n) { n ?? (n = {}), n.withGrouping ?? (n.withGrouping = !0); let i = [], t = !1; for (; !t;) { for (; /^[0-9]$/.test(this.peek);)i.push(this.nextToken()), this.skipVisualSpace(); if (t = !0, n.withGrouping && this.options.groupSeparator) { let r = this.index; this.skipVisualSpace(), this.matchAll(this._groupSeparatorTokens) && (this.skipVisualSpace(), /^[0-9]$/.test(this.peek) ? t = !1 : this.index = r) } } return i.join("") } parseSignedInteger(n) { n ?? (n = {}), n.withGrouping ?? (n.withGrouping = !0); let i = this.index, t = this.parseOptionalSign(), r = this.parseDecimalDigits(n); return r ? t === "-" ? "-" + r : r : (this.index = i, "") } parseExponent() { let n = this.index; if (this.matchAny(["e", "E"])) { let i = this.parseSignedInteger({ withGrouping: !1 }); if (i) return i } if (this.index = n, this.match("\\times") && (this.skipSpaceTokens(), this.match("1") && this.match("0") && this.match("^"))) { if (/^[0-9]$/.test(this.peek)) return this.nextToken(); if (this.match("<{>")) { this.skipSpaceTokens(); let i = this.parseSignedInteger(); if (this.skipSpaceTokens(), this.match("<}>") && i) return i } } if (this.index = n, this.skipSpaceTokens(), this.match("\\%")) return "-2"; if (this.index = n, this.matchAll(this._exponentProductTokens) && (this.skipSpaceTokens(), this.matchAll(this._beginExponentMarkerTokens))) { this.skipSpaceTokens(); let i = this.parseSignedInteger({ withGrouping: !1 }); if (this.skipSpaceTokens(), this.matchAll(this._endExponentMarkerTokens) && i) return i } return this.index = n, "" } parseRepeatingDecimal() { let n = this.index, i = ""; return this.match("(") ? (i = this.parseDecimalDigits(), i && this.match(")") ? "(" + i + ")" : (this.index = n, "")) : (this.index = n, this.matchAll(["\\left", "("]) ? (i = this.parseDecimalDigits(), i && this.matchAll(["\\right", ")"]) ? "(" + i + ")" : (this.index = n, "")) : (this.index = n, this.matchAll(["\\overline", "<{>"]) ? (i = this.parseDecimalDigits(), i && this.match("<}>") ? "(" + i + ")" : (this.index = n, "")) : (this.index = n, this.matchAll(this._beginRepeatingDigitsTokens) ? (i = this.parseDecimalDigits(), i && this.matchAll(this._endRepeatingDigitsTokens) ? "(" + i + ")" : (this.index = n, "")) : (this.index = n, "")))) } parseNumber() { if (this.options.parseNumbers === !1 || this.options.parseNumbers === "never") return null; let n = this.index; this.skipVisualSpace(); let i = 1; for (; this.peek === "-" || this.peek === "+";)this.match("-") ? i *= -1 : this.match("+"), this.skipVisualSpace(); let t = "", r = "", o = !1; if (this.match(".") || this.matchAll(this._decimalMarkerTokens)) { let f = this.peek; (f === "\\overline" || f === this._beginRepeatingDigitsTokens[0] || /[0-9\(]/.test(f)) && (o = !0, t = "0") } else t = this.parseDecimalDigits(); if (!t) return this.index = n, null; let s = this.index, a = !1; (o || this.match(".") || this.matchAll(this._decimalMarkerTokens)) && (r = this.parseDecimalDigits(), a = !0); let u = !1; if (a) { let f = this.parseRepeatingDecimal(); f ? (r += f, u = !0) : this.match("\\ldots") || this.matchAll(this._truncationMarkerTokens) } if (a && !r) return this.index = s, { num: i < 0 ? "-" + t : t }; this.skipVisualSpace(); let l = this.parseExponent(); if (!u && this.options.parseNumbers === "rational") { let f = parseInt(t, 10); if (!r) return l ? ["Multiply", i * f, ["Power", 10, l]] : i * f; let d = parseInt(r, 10), c = r.length, m = f * Math.pow(10, c) + d, g = Math.pow(10, c); return l ? ["Multiply", ["Rational", i * m, g], ["Power", 10, l]] : ["Rational", i * m, g] } return { num: (i < 0 ? "-" : "") + t + (a ? "." + r : "") + (l ? "e" + l : "") } } matchLatexNumber(n = !0) { let i = !1, t = this.peek; for (; t === "<space>" || t === "+" || t === "-";)t === "-" && (i = !i), this.nextToken(), t = this.peek; let r = 10, o = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]; if (this.match("'")) r = 8, o = ["0", "1", "2", "3", "4", "5", "6", "7"], n = !0; else if (this.match('"') || this.match("x")) r = 16, o = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"], n = !0; else if (this.match("`")) return t = this.nextToken(), t ? t.startsWith("\\") && t.length === 2 ? (i ? -1 : 1) * (t.codePointAt(1) ?? 0) : (i ? -1 : 1) * (t.codePointAt(0) ?? 0) : null; let s = ""; for (; o.includes(this.peek);)s += this.nextToken(); if (!n && this.match(".")) for (s += "."; o.includes(this.peek);)s += this.nextToken(); let a = n ? Number.parseInt(s, r) : Number.parseFloat(s); return Number.isNaN(a) ? null : i ? -a : a } parsePrefixOperator(n) { n || (n = { minPrec: 0 }), n.minPrec || (n = { ...n, minPrec: 0 }); let i = this.index; for (let [t, r] of this.peekDefinitions("prefix")) { this.index = i + r; let o = t.parse(this, { ...n, minPrec: t.precedence + 1 }); if (o) return o } return this.index = i, null } parseInfixOperator(n, i) { i ?? (i = { minPrec: 0 }), i.minPrec, i.minPrec === void 0 && (i = { ...i, minPrec: 0 }); let t = this.index; for (let [r, o] of this.peekDefinitions("infix")) if (r.precedence >= i.minPrec) { this.index = t + o; let s = r.parse(this, n, i); if (s) return s } return this.index = t, null } parseArguments(n = "enclosure", i) { if (this.atTerminator(i)) return null; let t = this.index, r = this.parseEnclosure(); if (n === "enclosure") return r === null ? null : Ut(r) ?? []; if (n === "implicit") { if (b(r) === "Delimiter") { if (b(Be(r)) === "Sequence") { let s = Be(Be(r)); return s ? [s] : [] } return Be(r) ? [Be(r)] : [] } if (r !== null) return [r]; let o = this.parseExpression({ ...i, minPrec: 390 }); return o === null ? null : [o] } return this.index = t, null } matchOpenDelimiter(n, i) { let t = this.index, r = Ht[this.peek]; r && this.nextToken(); let o = ha[n] ?? [n], s = r ? [r] : []; return o.includes("||") && this.matchAll(["|", "|"]) ? (s.push("|"), s.push("|"), s) : o.includes(this.peek) ? (nt[n] === i ? s.push(nt[this.peek]) : s.push(i), this.nextToken(), s) : (this.index = t, null) } parseEnclosure() { let n = this.getDefs("matchfix"), i = this.index; for (let t of n) { if (this.index = i, !this.matchDelimiter(t.openTrigger, t.closeTrigger)) continue; let r = this.index; this.skipSpace(); let o = this.parseExpression(); if (this.skipSpace(), !this.matchBoundary()) { let a = this._boundaries[this._boundaries.length - 1].tokens; if (this.removeBoundary(), this.index = r, this.skipSpace(), o = this.parseExpression(), this.skipSpace(), !this.matchAll(a)) { if (!this.atEnd) continue; return this.index = i, null } } let s = t.parse(this, o ?? ["Sequence"]); if (s !== null) return s } return this.index = i, null } parseGenericExpression(n) { if (this.atTerminator(n)) return null; let i = this.index, t = null, r = this.peekDefinitions("expression") ?? []; for (let [o, s] of r) if (this.index = i + s, typeof o.parse == "function") { if (t = o.parse(this, n), t !== null) return t } else return o.name; return this.index = i, null } parseFunction(n) { if (this.atTerminator(n)) return null; let i = this.index, t = null; for (let [o, s] of this.peekDefinitions("function")) if (this.index = i + s, typeof o.parse == "function") { if (t = o.parse(this, n), t !== null) return t } else { t = o.name; break } if (t === null && (this.index = i, t = et(this), !this.isFunctionHead(t))) return this.index = i, null; do { let o = this.parsePostfixOperator(t, n); if (o === null) break; t = o } while (!0); let r = this.parseArguments("enclosure", n); return r === null ? t : typeof t == "string" ? [t, ...r] : ["Apply", t, ...r] } parseSymbol(n) { if (this.atTerminator(n)) return null; let i = this.index; for (let [r, o] of this.peekDefinitions("symbol")) if (this.index = i + o, typeof r.parse == "function") { let s = r.parse(this, n); if (s) return s } else return r.name; this.index = i; let t = et(this); return t === null ? null : this.options.parseUnknownIdentifier?.(t, this) === "symbol" ? t : (this.index = i, null) } parseSupsub(n) { if (this.atEnd) return n; let i = this.index; this.skipSpace(); let t = [], r = [], o = i; for (; this.peek === "_" || this.peek === "^";) { if (this.match("_")) if (o = this.index, this.match("_") || this.match("^")) r.push(this.error("syntax-error", o)); else { let a = this.parseGroup() ?? this.parseToken() ?? this.parseStringGroup(); if (a === null) return this.error("missing", i); r.push(a) } else if (this.match("^")) if (o = this.index, this.match("_") || this.match("^")) t.push(this.error("syntax-error", o)); else { let a = this.parseGroup() ?? this.parseToken(); if (a === null) return this.error("missing", i); t.push(a) } o = this.index, this.skipSpace() } if (t.length === 0 && r.length === 0) return this.index = i, n; let s = n; if (r.length > 0) { let a = [...this.getDefs("infix")].filter(u => u.latexTrigger === "_"); if (a) { let u = ["Subscript", s, r.length === 1 ? r[0] : ["List", ...r]]; for (let l of a) if (typeof l.parse == "function" ? s = l.parse(this, u, { minPrec: 0 }) : s = u, s) break } } if (t.length > 0) { let a = [...this.getDefs("infix")].filter(u => u.latexTrigger === "^"); if (a) { let u = t.filter(l => !(b(l) === "Sequence" && G(l) === 0)); if (u.length !== 0) { let l = u.length === 1 ? u[0] : ["List", ...u], f = ["Superscript", s, l]; for (let d of a) if (typeof d.parse == "function" ? s = d.parse(this, f, { minPrec: 0 }) : s = f, s) break } } } return s === null && (this.index = i), s } parsePostfixOperator(n, i) { if (n === null || this.atEnd) return null; let t = this.index; for (let [r, o] of this.peekDefinitions("postfix")) { this.index = t + o; let s = r.parse(this, n, i); if (s !== null) return s } return this.index = t, null } parseStringGroupContent() { let n = this.index, i = "", t = 0; for (; !this.atBoundary || t > 0;) { let r = this.nextToken(); if (r === "<$>" || r === "<$$>") return this.index = n, ""; r === "<{>" ? (t += 1, i += "\\{") : r === "<}>" ? (t -= 1, i += "\\}") : r === "<space>" ? i += " " : (r[0], i += r) } return i } parseSyntaxError() { let n = this.index; if (this.peek === "^") return this.index += 1, ["Superscript", this.error("missing", n), H(this.parseGroup())]; let i = this.peekDefinitions("operator"); if (i.length > 0) { if (i = this.peekDefinitions("postfix"), i.length > 0) { let [a, u] = i[0]; if (this.index += u, typeof a.parse == "function") { let l = a.parse(this, this.error("missing", n)); if (l) return l } return a.name ? [a.name, this.error("missing", n)] : this.error("unexpected-operator", n) } if (i = this.peekDefinitions("prefix"), i.length > 0) { let [a, u] = i[0]; if (this.index += u, typeof a.parse == "function") { let l = a.parse(this, { minPrec: 0 }); if (l) return l } return a.name ? [a.name, this.parseExpression() ?? this.error("missing", n)] : this.error("unexpected-operator", n) } if (i = this.peekDefinitions("infix"), i.length > 0) { let [a, u] = i[0]; this.index += u; let l = a.parse(this, this.error("missing", n), { minPrec: 0 }); return l || this.error("unexpected-operator", n) } } let t = this.index, r = po(this); if (r) return r; if (r = et(this), r) return this.error(["unexpected-identifier", r], t); let o = this.peek; if (!o) return this.error("syntax-error", n); if (o[0] !== "\\") return this.error(["unexpected-token", { str: ln(o) }], n); if (Vf(this)) return this.error("unexpected-delimiter", n); let s = this.nextToken(); if (this.skipSpaceTokens(), s === "\\end") { let a = this.parseStringGroup(); return a === null ? this.error("expected-environment-name", n) : this.error(["unbalanced-environment", { str: a }], n) } for (; this.match("[");) { let a = 0; for (; !this.atEnd && a === 0 && this.peek !== "]";)this.peek === "[" && (a += 1), this.peek === "]" && (a -= 1), this.nextToken(); this.match("]") } for (; this.match("<{>");) { let a = 0; for (; !this.atEnd && a === 0 && this.peek !== "<}>";)this.peek === "<{>" && (a += 1), this.peek === "<}>" && (a -= 1), this.nextToken(); this.match("<}>") } return this.error(["unexpected-command", { str: ln(s) }], n) } parsePrimary(n) { if (this.atBoundary || this.atTerminator(n)) return null; let i = null, t = this.index; if (this.match("<}>")) return this.error("unexpected-closing-delimiter", t); if (i ?? (i = this.parseGroup()), i ?? (i = this.parseNumber()), i ?? (i = this.parseEnclosure()), i ?? (i = this.parseEnvironment(n)), i === null && this.matchAll(this._positiveInfinityTokens) && (i = { num: "+Infinity" }), i === null && this.matchAll(this._negativeInfinityTokens) && (i = { num: "-Infinity" }), i === null && this.matchAll(this._notANumberTokens) && (i = { num: "NaN" }), i ?? (i = this.parseGenericExpression(n) ?? this.parseFunction(n) ?? this.parseSymbol(n) ?? po(this)), i !== null) { i = this.decorate(i, t); let r = null, o = this.index; do { if (r = this.parsePostfixOperator(i, n), i = r ?? i, this.index === o && r !== null) { this.index; break } o = this.index } while (r !== null) } return i !== null && (i = this.parseSupsub(i)), this.decorate(i, t) } parseExpression(n) { this.skipSpace(); let i = this.index; if (this.atBoundary) return this.index = i, null; n ?? (n = { minPrec: 0 }), n.minPrec, n.minPrec === void 0 && (n = { ...n, minPrec: 0 }); let t = this.parsePrefixOperator({ ...n, minPrec: 0 }); if (t === null && (t = this.parsePrimary(n), b(t) === "Sequence" && G(t) === 0 && (t = null)), t) { let r = !1; for (; !r && !this.atTerminator(n);) { this.skipSpace(); let o = this.parseInfixOperator(t, n); if (o === null && this.peekDefinitions("operator").length === 0) { let s = this.parseExpression({ ...n, minPrec: ze }); s !== null && (b(t) === "InvisibleOperator" ? b(s) === "InvisibleOperator" ? o = ["InvisibleOperator", ...B(t), ...B(s)] : o = ["InvisibleOperator", ...B(t), s] : b(s) === "InvisibleOperator" ? o = ["InvisibleOperator", t, ...B(s)] : o = ["InvisibleOperator", t, s]) } o !== null ? t = o : r = !0 } } return this.decorate(t, i) } decorate(n, i) { if (n === null) return null; if (!this.options.preserveLatex) return n; let t = this.latex(i, this.index); return Array.isArray(n) ? n = { latex: t, fn: n } : typeof n == "number" ? n = { latex: t, num: Number(n).toString() } : typeof n == "string" ? n = { latex: t, sym: n } : typeof n == "object" && n !== null && (n.latex = t), n } error(n, i) { let t; typeof n == "string" ? (n.startsWith("'"), t = { str: n }) : (n[0].startsWith("'"), t = ["ErrorCode", { str: n[0] }, ...n.slice(1)]); let r = this.latex(i, this.index); return r ? ["Error", t, ["LatexString", { str: r }]] : ["Error", t] } isFunctionHead(n) { if (n === null) return !1; let i = V(n); return i ? this.computeEngine?.lookupFunction(i) !== void 0 || this.options.parseUnknownIdentifier?.(i, this) === "function" : !1 } *getDefs(n) { if (n === "operator") for (let i of this._dictionary.defs) /^prefix|infix|postfix/.test(i.kind) && (yield i); else for (let i of this._dictionary.defs) i.kind === n && (yield i) } }; function qf(e, n) { let i = e.index, t = et(e)?.trim(); if (t === null) return 0; let r = t !== n ? 0 : e.index - i; return e.index = i, r } function Vf(e) { let n = e.peek; return Object.values(nt).includes(n) || nt[n] ? (e.nextToken(), !0) : Ht[n] || Object.values(Ht).includes(n) ? (e.nextToken(), e.nextToken(), !0) : !1 } function ga(e, n) { let i = e.length, t = e; if (n.beginRepeatingDigits && n.endRepeatingDigits) { e = e.slice(0, -1); for (let o = 0; o < e.length - 16; o++) { let s = e.substring(0, o); for (let a = 0; a < 17; a++) { let u = e.substring(o, o + a + 1), l = Math.floor((e.length - s.length) / u.length); if (l <= 3) break; if ((s + u.repeat(l + 1)).startsWith(e)) return u === "0" ? s.replace(/(\d{3})/g, "$1" + n.groupSeparator) : s.replace(/(\d{3})/g, "$1" + n.groupSeparator) + n.beginRepeatingDigits + u + n.endRepeatingDigits } } } let r = i > n.precision - 1; return e = t, r && (e = e.substring(0, n.precision - 1)), n.groupSeparator && (e = e.replace(/(\d{3})/g, "$1" + n.groupSeparator), e.endsWith(n.groupSeparator) && (e = e.slice(0, -n.groupSeparator.length))), r ? e + n.truncationMarker : e } function xa(e, n) { return e ? n.beginExponentMarker ? n.beginExponentMarker + e + (n.endExponentMarker ?? "") : "10^{" + e + "}" : "" } function ba(e, n) { if (e === null) return ""; let i; if (typeof e == "number" || typeof e == "string") i = e; else if (typeof e == "object" && "num" in e) i = e.num; else return ""; if (typeof i == "number") { if (i === 1 / 0) return n.positiveInfinity; if (i === -1 / 0) return n.negativeInfinity; if (Number.isNaN(i)) return n.notANumber; let o; return n.notation === "engineering" ? o = Wt(i.toExponential(), n, 3) : n.notation === "scientific" && (o = Wt(i.toExponential(), n)), o ?? xo(i.toString(), n) } if (i = i.toLowerCase().replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), i === "infinity" || i === "+infinity") return n.positiveInfinity; if (i === "-infinity") return n.negativeInfinity; if (i === "nan") return n.notANumber; if (!/^[-+\.]?[0-9]/.test(i)) return ""; if (i = i.replace(/[nd]$/, ""), /\([0-9]+\)/.test(i)) { let [o, s, a, u] = i.match(/(.+)\(([0-9]+)\)(.*)$/) ?? []; i = s + a.repeat(Math.ceil(n.precision / a.length)) + u } let t = ""; for (i[0] === "-" ? (t = "-", i = i.substring(1)) : i[0] === "+" && (i = i.substring(1)); i[0] === "0";)i = i.substring(1); i.length === 0 ? i = "0" : i[0] === "." && (i = "0" + i); let r; return n.notation === "engineering" ? r = Wt(i, n, 3) : n.notation === "scientific" && (r = Wt(i, n)), t + (r ?? xo(i, n)) } function Wt(e, n, i = 1) { let t = e.match(/^(.*)[e|E]([-+]?[0-9]+)$/); if (!t) { let f = ""; if (e[0] === "-" ? (f = "-", e = e.substring(1)) : e[0] === "+" && (e = e.substring(1)), e.indexOf(".") < 0) e.length === 1 ? e = f + e + "e+0" : e = f + e[0] + "." + e.slice(1) + "e+" + (e.length - 1).toString(); else { let [d, c, m] = e.match(/^(.*)\.(.*)$/); for (m || (m = ""); c.startsWith("0");)c = c.substring(1); c ? e = f + c[0] + "." + c.slice(1) + m + "e+" + (c.length - 1).toString() : e = f + "0." + m + "e+0" } t = e.match(/^(.*)[e|E]([-+]?[0-9]+)$/) } if (!t) return xo(e, n); let r = parseInt(t[2]), o = t[1]; if (Math.abs(r) % i !== 0) { let f = r > 0 ? r % i : -((i + r) % i); r = r >= 0 ? r - f : r + f; let [d, c, m] = o.match(/^(.*)\.(.*)$/) ?? ["", o, ""]; o = c + (m + "00000000000000000").slice(0, Math.abs(f)) + "." + m.slice(Math.abs(f)) } let s = n.avoidExponentsInRange; if (s && r >= s[0] && r <= s[1]) return; let a = "", u = o; t = u.match(/^(.*)\.(.*)$/), t && (u = t[1], a = t[2]); let l = r !== 0 ? xa(Number(r).toString(), n) : ""; return n.groupSeparator && (u = u.replace(/\B(?=(\d{3})+(?!\d))/g, n.groupSeparator), a = ga(a, n)), a && (a = n.decimalMarker + a), l ? u === "1" && !a ? l : u + a + n.exponentProduct + l : u + a } function xo(e, n) { let i = e.match(/^(.*)[e|E]([-+]?[0-9]+)$/i), t; i?.[1] && i[2] && (t = xa(i[2], n)); let r = i?.[1] ?? e, o = ""; return i = (t ? i[1] : e).match(/^(.*)\.(.*)$/), i?.[1] && i[2] && (r = i[1], o = i[2]), n.groupSeparator && (r = r.replace(/\B(?=(\d{3})+(?!\d))/g, n.groupSeparator), o = ga(o, n)), o && (o = n.decimalMarker + o), t ? r === "1" && !o ? t : r + o + n.exponentProduct + t : r + o } var yo = { deg: e => `${e}\\degree`, prime: e => `${e}^{\\prime}`, dprime: e => `${e}^{\\doubleprime}`, ring: e => `\\mathring{${e}}`, hat: e => `\\hat{${e}}`, tilde: e => `\\tilde{${e}}`, vec: e => `\\vec{${e}}`, bar: e => `\\overline{${e}}`, underbar: e => `\\underline{${e}}`, dot: e => `\\dot{${e}}`, ddot: e => `\\ddot{${e}}`, tdot: e => `\\dddot{${e}}`, qdot: e => `\\ddddot{${e}}`, acute: e => `\\acute{${e}}`, grave: e => `\\grave{${e}}`, breve: e => `\\breve{${e}}`, check: e => `\\check{${e}}` }, Eo = { upright: e => `\\mathrm{${e}}`, italic: e => `\\mathit{${e}}`, bold: e => `\\mathbf{${e}}`, script: e => `\\mathscr{${e}}`, fraktur: e => `\\mathfrak{${e}}`, doublestruck: e => `\\mathbb{${e}}`, blackboard: e => `\\mathbb{${e}}`, calligraphic: e => `\\mathcal{${e}}`, gothic: e => `\\mathfrak{${e}}`, sansserif: e => `\\mathsf{${e}}`, monospace: e => `\\mathtt{${e}}` }, Yt = class { constructor(n, i, t) { this.level = -1; this.options = n, n.invisibleMultiply && (!/#1/.test(n.invisibleMultiply) || !/#2/.test(n.invisibleMultiply)) && t([{ severity: "warning", message: ["expected-argument", "invisibleMultiply"] }]), this.onError = t, this.dictionary = i, this.canonical = void 0 } updateOptions(n) { for (let i of Object.keys(this.options)) i in n && (this.options[i] = n[i]) } wrap(n, i) { if (n === null) return ""; if (i === void 0) return this.wrapString(this.serialize(n), this.options.groupStyle(n, this.level + 1)); if (typeof n == "number" || Qn(n)) { let r = M(n); return r !== null && r < 0 && i > re ? this.wrap(n) : this.serialize(n) } let t = b(n); if (typeof t == "string" && t !== "Delimiter" && t !== "Subscript") { let r = this.dictionary.ids.get(t); if (r && (r.kind === "symbol" || r.kind === "expression" || r.kind === "prefix" || r.kind === "infix" || r.kind === "postfix") && r.precedence < i) return this.wrapString(this.serialize(n), this.options.applyFunctionStyle(n, this.level)) } return this.serialize(n) } wrapShort(n) { if (n === null) return ""; let i = this.serialize(n); if (V(n) !== null || b(n) === "Delimiter" && G(n) === 1 || Fn(n) && !/^(-|\.)/.test(i)) return i; let r = b(n); return r !== "Add" && r !== "Negate" && r !== "Subtract" && r !== "PlusMinus" && r !== "Multiply" ? i : this.wrapString(i, this.options.groupStyle(n, this.level + 1)) } wrapString(n, i, t) { if (i === "none") return n; t ?? (t = "()"); let r = t?.[0] ?? ".", o = t?.[1] ?? "."; return r === '"' ? r = "``" : r === "|" ? r = "\\lvert" : r = yi[r] ?? r, o === '"' ? o = "''" : o === "|" ? o = "\\rvert" : o = yi[o] ?? o, r === "." && o === "." ? n : ((r === "." || o === ".") && i === "normal" && (i = "scaled"), i === "scaled" ? `\\left${r}${n}\\right${o}}` : i === "big" ? `${`\\Bigl${r}`}${n}${`\\Bigr${o}`})` : r + n + o) } wrapArguments(n) { return this.wrapString((B(n) ?? []).map(i => this.serialize(i)).join(", "), this.options.applyFunctionStyle(n, this.level)) } serializeSymbol(n, i) { return typeof n == "string" || Wi(n), i?.kind === "function" ? bo(V(n) ?? "") ?? "" : i?.serialize?.(this, n) ?? bo(V(n)) ?? "" } serializeFunction(n, i) { if (i?.serialize) return i.serialize(this, n); let t = b(n); if (typeof t == "string") return bo(t, "auto") + this.wrapArguments(n); if (b(t) === "InverseFunction" || b(t) === "Derivative") return this.serializeFunction(t, this.dictionary.ids.get(b(t))) + this.wrapArguments(n); let r = B(n) ?? []; if (r.length === 1) return N([this.serialize(r[0]), "\\rhd", this.wrapString(this.serialize(t), this.options.applyFunctionStyle(n, this.level))]); let o = this.options.applyFunctionStyle(n, this.level); return N(["\\operatorname{apply}", this.wrapString(this.serialize(t) + ", " + this.serialize(["List", ...r]), o)]) } serializeDictionary(n) { return `\\left\\lbrack\\begin{array}{lll}${Object.keys(n).map(i => `\\textbf{${i}} & \\rightarrow & ${this.serialize(n[i])}`).join("\\\\")}\\end{array}\\right\\rbrack` } serialize(n, i) { if (n == null) return ""; i ?? (i = {}), i = { ...i }, "canonical" in i || (i.canonical = !0); let t = this.canonical; this.canonical === void 0 && (this.canonical = i.canonical), this.level += 1; try { let r = (() => { let o = ba(n, this.options); if (o) return o; let s = z(n); if (s !== null) return `\\text{${s}}`; let a = Xn(n); if (a !== null) return this.serializeDictionary(a); let u = V(n); if (u !== null) return this.serializeSymbol(n, this.dictionary.ids.get(u)); let l = ro(n); if (l) return this.serializeFunction(n, this.dictionary.ids.get(l)); if (b(n) !== null) return this.serializeFunction(n); this.onError([{ severity: "warning", message: ["syntax-error", n ? JSON.stringify(n) : "undefined"] }]) })(); return this.level -= 1, this.canonical = t, r ?? "" } catch { } return this.level -= 1, this.canonical = t, "" } applyFunctionStyle(n, i) { return this.options.applyFunctionStyle(n, i) } groupStyle(n, i) { return this.options.groupStyle(n, i) } rootStyle(n, i) { return this.options.rootStyle(n, i) } fractionStyle(n, i) { return this.options.fractionStyle(n, i) } logicStyle(n, i) { return this.options.logicStyle(n, i) } powerStyle(n, i) { return this.options.powerStyle(n, i) } numericSetStyle(n, i) { return this.options.numericSetStyle(n, i) } }; function $f(e) { let n = e.match(/^([^_]+)/)?.[1] ?? "", i = nn.findIndex(s => n === s[0]); if (i >= 0) return [nn[i][1], e.substring(nn[i][0].length)]; let t = { zero: "0", one: "1", two: "2", three: "3", four: "4", five: "5", six: "6", seven: "7", eight: "8", nine: "9", ten: "10" }; if (i = Object.keys(t).findIndex(s => e.startsWith(s)), i >= 0) { let s = Object.keys(t)[i]; return [t[s], e.substring(s.length)] } let r = e.codePointAt(0); if (i = nn.findIndex(s => s[2] === r), i >= 0) return [nn[i][1], e.substring(1)]; let o = { plus: "+", minus: "-", pm: "\\pm", ast: "\\ast", dag: "\\dag", ddag: "\\ddag", hash: "\\#", bottom: "\\bot", top: "\\top", bullet: "\\bullet", circle: "\\circ", diamond: "\\diamond", times: "\\times", square: "\\square", star: "\\star" }; if (i = Object.keys(o).findIndex(s => n === s), i >= 0) { let s = Object.keys(o)[i]; return [o[s], e.substring(s.length)] } return [n, e.substring(n.length)] } function zf(e) { let [n, i] = $f(e), t = []; for (; i.length > 0;) { let o = i.match(/^_([a-zA-Z]+)(.*)/); if (!o || !yo[o[1]]) break; t.push(o[1]), i = o[2] } let r = []; for (; i.length > 0;) { let o = i.match(/^_([a-zA-Z]+)(.*)/); if (!o || !Eo[o[1]]) break; r.push(o[1]), i = o[2] } return [n, t, r, i] } function Qt(e, n = !0, i = "auto") { let [t, r, o, s] = zf(e); for (let a of r) yo[a] && (t = yo[a](t)); if (n) { let a = [], u = [], l = t.match(/^([^\d].*?)(\d+)$/); for (l && (u.push(l[2]), t = l[1]); s.length > 0;)if (s.startsWith("__")) { let [f, d] = Qt(s.substring(2), !1, "none"); a.push(f), s = d } else if (s.startsWith("_")) { let [f, d] = Qt(s.substring(1), !1, "none"); u.push(f), s = d } else break; a.length > 0 && (t = `${t}^{${a.join(",")}}`), u.length > 0 && (t = `${t}_{${u.join(",")}}`) } for (let a of o) Eo[a] && (t = Eo[a](t)); if (o.length === 0 && i !== "none") switch (i) { case "auto": zt(t) > 1 && (t = `\\mathrm{${t}}`); break; case "operator": t = `\\operatorname{${t}}`; break; case "italic": t = `\\mathit{${t}}`; break; case "upright": t = `\\mathrm{${t}}`; break }return [t, s] } function bo(e, n = "auto") { if (e === null) return null; if (gi.test(e)) return e; let i = e.match(/^(_+)(.*)/); if (i) { let [o, s] = Qt(i[2], !0, "none"); return `\\operatorname{${"\\_".repeat(i[1].length) + o + s}}` } let [t, r] = Qt(e, !0, n); return r.length > 0 ? `\\operatorname{${e}}` : t } function ya(e, n) { return "normal" } function Ea(e, n) { return "normal" } function va(e, n) { return n > 2 ? "solidus" : "radical" } function Na(e, n) { if (n > 3) return "inline-solidus"; if (b(e) === "Divide") { let [i, t] = [Qi(Be(e)), Qi(Ke(e))]; if (t <= 2 && i > 5) return "factor"; if (i <= 2 && t > 5) return "reciprocal" } return "quotient" } function _a(e, n) { return "boolean" } function Sa(e, n) { return "solidus" } function Ta(e, n) { return "compact" } var Uf = { invisibleMultiply: "", invisiblePlus: "", multiply: "\\times", missingSymbol: "\\blacksquare", applyFunctionStyle: ya, groupStyle: Ea, rootStyle: va, fractionStyle: Na, logicStyle: _a, powerStyle: Sa, numericSetStyle: Ta }, it = class e { constructor(n) { let i = r => { if (typeof window < "u") for (let o of r) console.warn(o.message) }; this.onError = n.onError ?? i, this.computeEngine = n.computeEngine; let t = { ...n }; delete t.dictionary, delete t.onError, this.options = { ...ho, ...go, ...Uf, ...t }, this._dictionaryInput = n.dictionary ?? e.getDictionary(), this._dictionary = co(this._dictionaryInput, r => this.onError([r])) } get dictionary() { return this._dictionaryInput } set dictionary(n) { this._dictionaryInput = n, this._dictionary = co(n, i => this.onError([i])) } updateOptions(n) { for (let i of Object.keys(this.options)) i in n && (this.options[i] = n[i]); this.serializer.updateOptions(n) } static getDictionary(n = "all") { if (n === "all") { let i = []; for (let t of Object.keys(vi)) vi[t] && i.push(...vi[t]); return i } return vi[n] ? Object.freeze([...vi[n]]) : [] } parse(n) { let i = new Jt($(n, []), this.options, this._dictionary, this.computeEngine), t = i.parseExpression(); if (!i.atEnd) { let r = i.parseSyntaxError(); for (t = t ? ["Sequence", t, r] : r; !i.atEnd;)i.nextToken() } return t ?? (t = ["Sequence"]), this.options.preserveLatex && (Array.isArray(t) ? t = { latex: n, fn: t } : typeof t == "number" ? t = { latex: n, num: Number(t).toString() } : typeof t == "string" ? t = { latex: n, sym: t } : typeof t == "object" && t !== null && (t.latex = n)), t ?? ["Sequence"] } serialize(n, i) { return this.serializer.serialize(n, i) } get serializer() { return this._serializer ? this._serializer : (this._serializer = new Yt(this.options, this._dictionary, this.onError), this._serializer) } }; var Va = pe(ce(), 1); var nr = pe(ce(), 1); var Rn = pe(ce(), 1); function vo(e, n, i = {}) { let { contract: t = .125, step: r = 1, power: o = 2, atol: s = 1e-16, rtol: a = s > 0 ? 0 : Math.sqrt(Number.EPSILON), maxeval: u = 1e6, breaktol: l = 2 } = i; if (!isFinite(n)) return vo(x => e(1 / x), 1 / n, { rtol: a, atol: s, maxeval: u, contract: Math.abs(t) > 1 ? 1 / t : t, step: 1 / r, power: o }); let f = r, d = Math.pow(1 / t, o), c = e(n + f), m = [c], g = 1 / 0, h = 1; for (; h < u;) { h += 1, f *= t, m.push(e(n + f)); let x = d, S = 1 / 0; for (let T = m.length - 2; T >= 0; T--) { let _ = m[T]; m[T] = m[T + 1] + (m[T + 1] - m[T]) / (x - 1); let w = Math.abs(m[T] - _); S = Math.min(S, w), w < g && (c = m[T], g = w), x *= d } if (S > l * g || !isFinite(S) || g <= Math.max(a * Math.abs(c), s)) break } return [c, g] } var Ia = 53, ei = Math.log10(Math.pow(2, Ia)), Gf = 7, cp = Math.pow(2, -(Ia - Gf)), tt = Math.pow(10, -10), Ni = 1e6, Xt = 1e6, rt = 200; var No = new Set([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919]), ka = 7919; function _o(e) { if (Number.isInteger(e) && e >= 0 && e < Number.MAX_SAFE_INTEGER, e <= 3) return { [e]: 1 }; let n = {}, i = 0; for (; e % 2 === 0;)i += 1, e /= 2; for (i > 0 && (n[2] = i), i = 0; e % 3 === 0;)i += 1, e /= 3; i > 0 && (n[3] = i); let t = !1; for (; !t;) { if (e === 1) return n; let r = Math.sqrt(e); t = !0; for (let o = 6; o <= r + 6; o += 6) { if (e % (o - 1) === 0) { n[o - 1] = (n[o - 1] ?? 0) + 1, e /= o - 1, t = !1; break } if (e % (o + 1) === 0) { n[o + 1] = (n[o + 1] ?? 0) + 1, e /= o + 1, t = !1; break } } } return n[e] !== void 0 ? n[e] += 1 : n[e] = 1, n } function Ln(e, n) { if (e >= Number.MAX_SAFE_INTEGER) return [1, e]; if (e === 0) return [0, 0]; Number.isInteger(e) && e > 0 && e < Number.MAX_SAFE_INTEGER; let i = _o(e), t = 1, r = 1; for (let o of Object.keys(i)) { let s = parseInt(o); t = t * Math.pow(s, Math.floor(i[o] / n)), r = r * Math.pow(s, i[o] % n) } return [t, r] } function Sn(e, n) { if (e === 0) return n; if (n === 0 || e === n) return e; if (!Number.isInteger(e) || !Number.isInteger(n)) return NaN; for (; n !== 0;) [e, n] = [n, e % n]; return e < 0 ? -e : e } function Kt(e, n) { return e * n / Sn(e, n) } function er(e) { if (!Number.isInteger(e) || e < 0) return NaN; let n = 1; for (let i = 2; i <= e; i++)n = n * i; return n } function wa(e) { if (!Number.isInteger(e) || e < 0) return NaN; if (e < 0) return NaN; if (e <= 1) return 1; let n = e; for (; e > 2;)e -= 2, n *= e; return n } var Ba = 7, Da = [.9999999999998099, 676.5203681218851, -1259.1392167224028, 771.3234287776531, -176.6150291621406, 12.507343278686905, -.13857109526572012, 9984369578019572e-21, 15056327351493116e-23]; function ot(e) { if (e < 0) return NaN; let n = Math.PI, i = e * e * e; return e * Math.log(e) - e - .5 * Math.log(e) + .5 * Math.log(2 * n) + 1 / (12 * e) - 1 / (360 * i) + 1 / (1260 * i * e * e) } function Ti(e) { if (e < .5) return Math.PI / (Math.sin(Math.PI * e) * Ti(1 - e)); if (e > 100) return Math.exp(ot(e)); e -= 1; let n = Da[0]; for (let t = 1; t < Ba + 2; t++)n += Da[t] / (e + t); let i = e + Ba + .5; return Math.sqrt(2 * Math.PI) * Math.pow(i, e + .5) * Math.exp(-i) * n } function E(e) { if (e == null) return null; let n = e.numericValue; if (n === null) return null; if (typeof n == "number") return n; if (n instanceof v) return n.toNumber(); if (Array.isArray(n)) { let [i, t] = n; return typeof i == "number" && typeof t == "number" ? i / t : Number(i) / Number(t) } return !(n instanceof Rn.Complex) || n.im, null } function Ge(e) { if (e == null) return null; let n = e.numericValue; if (n === null) return null; if (n instanceof v) return n; if (typeof n == "number") return e.engine.bignum(n); if (Array.isArray(n)) { let [i, t] = n; return typeof i == "number" && typeof t == "number" ? e.engine.bignum(i / t) : e.engine.bignum(i).div(t.toString()) } return !(n instanceof Rn.Complex) || n.im, null } function q(e) { if (e == null) return null; let n = e.numericValue; if (n === null) return null; if (typeof n == "number") return Number.isInteger(n) && n >= -Ni && n <= Ni ? n : null; if (n instanceof v) { if (n.isInteger()) { let t = n.toNumber(); if (t >= -Ni && t <= Ni) return t } return null } if (e.isCanonical) return null; let i = n; if (Array.isArray(i)) { let [t, r] = i, o; return typeof t == "number" && typeof r == "number" ? o = t / r : o = Number(t) / Number(r), Number.isInteger(o) && o >= -Ni && o <= Ni ? o : null } return null } function _i(e, n) { return typeof e == "number" && Math.abs(e) <= n || e instanceof v && e.abs().lte(n) || e instanceof Rn.Complex && Math.abs(e.re) <= n && Math.abs(e.im) <= n ? 0 : e } function So(e) { let n = .254829592, i = -.284496736, t = 1.421413741, r = -1.453152027, o = 1.061405429, s = .3275911, a = e < 0 ? -1 : 1; e = Math.abs(e); let u = 1 / (1 + s * e), l = ((((o * u + r) * u + t) * u + i) * u + n) * u; return a * (1 - l * Math.exp(-e * e)) } function Ca(e) { let n = Math.PI, i = n * n, t = i * n, r = e * e, o = e * r, s = o * r, a = s * r; return Math.sqrt(n) / 2 * (e + n / 12 * o + 7 * i / 480 * s + 127 * t / 40320 * a + 4369 * i * i / 5806080 * a * r + 34807 * t * i / 182476800 * a * r * r) } function Ma(e, n, i = .1) { return (e(n - 4 * i) / 280 - 4 * e(n - 3 * i) / 105 + e(n - 2 * i) / 5 - 4 * e(n - i) / 5 + 4 * e(n + i) / 5 - e(n + 2 * i) / 5 + 4 * e(n + 3 * i) / 105 - e(n + 4 * i) / 280) / i } function Aa(e, n, i, t = 1e5) { let r = 0; if (n === -1 / 0 && i === 1 / 0) for (let o = 0; o < t; o++) { let s = Math.random(), a = Math.tan(Math.PI * (s - .5)), u = Math.PI * (1 + a * a); r += e(a) / u } else if (n === -1 / 0) for (let o = 0; o < t; o++) { let s = Math.random(), a = i - Math.log(1 - s), u = 1 / (1 - s); r += e(a) / u } else if (i === 1 / 0) for (let o = 0; o < t; o++) { let s = Math.random(), a = n + Math.log(s), u = 1 / s; r += e(a) / u } else for (let o = 0; o < t; o++)r += e(n + Math.random() * (i - n)); return r / t * (i - n) } function Kn(e, n, i = 1) { if (i === 0) { let o = Kn(e, n, -1), s = Kn(e, n, 1); return o === void 0 || s === void 0 ? NaN : Math.abs(o - s) > 1e-5 ? NaN : (o + s) / 2 } let [t, r] = vo(e, n, { step: i > 0 ? 1 : -1 }); return t } function jf(e) { if (e === "N") return [0, ""]; let n = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1e3 }, i = 0, t = 0; e = e.toUpperCase(); for (let r = e.length - 1; r >= 0; r--) { let o = n[e[r]]; if (o === void 0) return [i, e.slice(r)]; o < t ? i -= o : i += o, t = o } return [i, ""] } function Si(e, n) { if (e = e.trim(), e.length === 0) return [NaN, ""]; if (e.startsWith("+")) return Si(e.slice(1), n); if (e.startsWith("-")) { let [r, o] = Si(e.slice(1), n); return [-r, o] } let i = 10; if (typeof n == "string" && (n = n.toLowerCase()), e.startsWith("0x")) i = 16, e = e.slice(2); else if (e.startsWith("0b")) i = 2, e = e.slice(2); else { if (n === "roman") return jf(e); if (n === "base64" || n === "base-64") try { return [parseInt(btoa(e)), ""] } catch { return [NaN, ""] } else typeof n == "number" ? i = n : typeof n == "string" && (i = parseInt(n)) } let t = 0; for (let r = 0; r < e.length; r++) { let o = { " ": -1, "\xA0": -1, "\u2000": -1, "\u2001": -1, "\u2002": -1, "\u2003": -1, "\u2004": -1, "\u2005": -1, "\u2006": -1, "\u2007": -1, "\u2008": -1, "\u2009": -1, "\u200A": -1, "\u200B": -1, "\u202F": -1, "\u205F": -1, _: -1, ",": -1, 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15, g: 16, h: 17, i: 18, j: 19, k: 20, l: 21, m: 22, n: 23, o: 24, p: 25, q: 26, r: 27, s: 28, t: 29, u: 30, v: 31, w: 32, x: 33, y: 34, z: 35 }[e[r]]; if (o !== -1) { if (o === void 0) return [t, e.substring(r)]; if (o >= i) return [t, e.substring(r)]; t = t * i + o } } return [t, ""] } function ni(e, n, i) { if (e === n) return 0; let t = e.N(), r = n.N(), o = t.numericValue, s = r.numericValue; if (o === null || s === null) { let l = t.sgn, f = r.sgn; return typeof l != "number" || typeof f != "number" ? void 0 : l === 0 && f === 0 ? 0 : l < 0 && f > 0 ? -1 : l > 0 && f < 0 ? 1 : void 0 } if (i ?? (i = e.engine.tolerance), o instanceof Rn.Complex && s instanceof Rn.Complex) return _i(o.re - s.re, i) === 0 && _i(o.im - s.im, i) === 0 ? 0 : void 0; if (o instanceof Rn.Complex || s instanceof Rn.Complex) return; if (!U(o) && U(s), typeof o == "number" && typeof s == "number") return _i(s - o, i) === 0 ? 0 : o < s ? -1 : 1; let a = e.engine, u = a.bignum(s).sub(a.bignum(o)); return _i(u, i) === 0 ? 0 : u.isPos() ? 1 : -1 } function To(e) { if (typeof e == "number") return Number.isInteger(e) ? BigInt(e) : null; if (e == null || !Fn(e)) return null; let n = Qn(e) ? e.num : e; if (typeof n == "number") return Number.isInteger(n) ? BigInt(n) : null; if (typeof n != "string") return null; let i = n.toLowerCase().replace(/[nd]$/, "").replace(/[\u0009-\u000d\u0020\u00a0]/g, ""); return i === "nan" || i === "infinity" || i === "+infinity" || i === "-infinity" || i.includes(".") ? null : P(i) } function P(e) { if (typeof e == "bigint") return e; if (e instanceof Ue) return P(e.toString()); let n = e.toString(), i = n.match(/([^\.]+)(?:\.([0-9]+))?e(.+)$/); return i && (n = i[1] + (i[2] ?? "") + "0".repeat(parseInt(i[3]) - (i[2] ? i[2].length : 0))), BigInt(n) } function Oa(e, n) { for (; n !== BigInt(0);) [e, n] = [n, e % n]; return e < 0 ? -e : e } var Zf = [BigInt(4), BigInt(2), BigInt(4), BigInt(2), BigInt(4), BigInt(6), BigInt(2), BigInt(6)]; function Hf(e) { if (e < Number.MAX_SAFE_INTEGER) { let f = _o(Number(e)), d = new Map; for (let c of Object.keys(f)) d.set(P(c), f[c]); return d } let n = e, i = new Map, t = 0, r = 0, o = 0, s = BigInt(10); for (; n % s === BigInt(0);)t += 1, o += 1, n = n / s; for (s = BigInt(5); n % s === BigInt(0);)o += 1, n = n / s; for (s = BigInt(3); n % s === BigInt(0);)r += 1, n = n / s; for (s = BigInt(2); n % s === BigInt(0);)t += 1, n = n / s; t > 0 && i.set("2", t), r > 0 && i.set("3", r), o > 0 && i.set("5", o), s = BigInt(7); let a = "", u = 0; for (; s * s < n;)n % s === BigInt(0) ? (a || (a = s.toString()), i.set(a, (i.get(a) ?? 0) + 1), n = n / s) : (s = s + Zf[u], a = "", u = u < 7 ? u + 1 : 0); n !== BigInt(1) && i.set(n.toString(), (i.get(n.toString()) ?? 0) + 1); let l = new Map; for (let [f, d] of i) l.set(P(f), d); return l } function ii(e, n) { let i = Hf(e), t = BigInt(1), r = BigInt(1), o = P(n); for (let [s, a] of i) { let u = P(a); t = t * s ** (u / o), r = r * s ** (u % o) } return [t, r] } function U(e) { return e !== null && Array.isArray(e) } function J(e) { return e !== null && Array.isArray(e) && typeof e[0] == "number" } function K(e) { return e !== null && Array.isArray(e) && typeof e[0] == "bigint" } function Ze(e) { return e[0] == 0 } function ie(e) { return e[0] === e[1] } function Pa(e) { return e[1] === 1 || e[1] === BigInt(1) } function Bi(e) { return e[0] === -e[1] } function Oe(e) { return Number(e[0]) } function dn(e) { return Number(e[1]) } function Bo(e) { return e[0] < 0 } function _e(e) { return [-e[0], e[1]] } function Tn(e) { return e[0] < 0 ? [-e[1], -e[0]] : [e[1], e[0]] } function W(e) { let n = e.numericValue; if (Array.isArray(n)) return n; if (n !== null) { if (typeof n == "number" && Number.isInteger(n)) return n > 1e9 || n < -1e9 ? [P(n), BigInt(1)] : [n, 1]; if (n instanceof v && n.isInteger()) return [P(n), BigInt(1)] } } function st(e, n) { if (Array.isArray(n) || n.numericValue !== null && n.numericValue instanceof nr.Complex, typeof e[0] == "number" && !Number.isFinite(e[0])) return e; let i = Array.isArray(n) ? n : n.numericValue; if (i === null) return e; if (Array.isArray(i)) { if (K(i)) return e = [BigInt(e[0]), BigInt(e[1])], [i[1] * e[0] + i[0] * e[1], i[1] * e[1]]; if (!Number.isFinite(i[0])) return i; if (K(e)) { let t = [BigInt(i[0]), BigInt(i[1])]; return [t[1] * e[0] + t[0] * e[1], t[1] * e[1]] } return [i[1] * e[0] + i[0] * e[1], i[1] * e[1]] } return i instanceof v ? i.isNaN() ? [Number.NaN, 1] : i.isFinite() ? (i.isInteger(), J(e) && (e = [BigInt(e[0]), BigInt(e[1])]), [e[0] + e[1] * P(i.toString()), e[1]]) : [i.isNegative() ? -1 / 0 : 1 / 0, 1] : i instanceof nr.Complex ? [Number.NaN, 1] : (!Number.isFinite(i) || Number.isInteger(i), Number.isFinite(i) ? J(e) ? [e[0] + e[1] * i, e[1]] : [e[0] + e[1] * P(i), e[1]] : [i, 1]) } function Q(e, n) { if (Array.isArray(n) || n.numericValue !== null && n instanceof nr.Complex, Array.isArray(n)) return J(e) && J(n) ? [e[0] * n[0], e[1] * n[1]] : (J(e) && (e = [P(e[0]), P(e[1])]), J(n) && (n = [P(n[0]), P(n[1])]), [e[0] * n[0], e[1] * n[1]]); let i = n.numericValue; return i !== null && typeof i == "number" ? (Number.isInteger(i), J(e) ? [e[0] * i, e[1]] : [e[0] * P(i), e[1]]) : i instanceof v ? (i.isInteger(), J(e) ? [P(i.toString()) * P(e[0]), P(e[1])] : [P(i.toString()) * e[0], e[1]]) : Array.isArray(i) ? K(i) ? [i[0] * P(e[0]), i[1] * P(e[1])] : J(e) ? [e[0] * i[0], e[1] * i[1]] : [e[0] * P(i[0]), e[1] * P(i[1])] : e } function Fa(e, n) { return Q(e, Tn(n)) } function ir(e, n) { if (Number.isInteger(n), n === 0) return [1, 1]; if (n < 0 && (e = Tn(e), n = -n), n === 1) return e; if (J(e)) return [Math.pow(e[0], n), Math.pow(e[1], n)]; let i = P(n); return [e[0] ** i, e[1] ** i] } function Ra(e) { let n = Math.sqrt(Number(e[0])), i = Math.sqrt(Number(e[1])); if (Number.isInteger(n) && Number.isInteger(i)) return [n, i] } function je(e) { if (J(e)) { if (e[0] === 1 || e[1] === 1) return e; if (e[1] < 0 && (e = [-e[0], -e[1]]), !Number.isFinite(e[1])) return [0, 1]; let i = Sn(e[0], e[1]); return i <= 1 ? e : [e[0] / i, e[1] / i] } if (e[0] === BigInt(1) || e[1] === BigInt(1)) return e; e[1] < 0 && (e = [-e[0], -e[1]]); let n = Oa(e[0], e[1]); return n <= 1 ? e : [e[0] / n, e[1] / n] } function La(e) { if (!Number.isFinite(e) || e % 1 === 0) return e; let i = 1e-15, t = Math.floor(e), r = 1, o = 0, s = t, a = 1; for (; e - t > i * a * a;) { e = 1 / (e - t), t = Math.floor(e); let u = r; r = s; let l = o; o = a, s = u + t * r, a = l + t * o } return [s, a] } function qa(e) { if (K(e)) { let [a, u] = e, [l, f] = ii(a, 2), [d, c] = ii(u, 2); return [je([l, d]), je([f, c])] } let [n, i] = e, [t, r] = Ln(n, 2), [o, s] = Ln(i, 2); return [je([t, o]), je([r, s])] } function $a(e) { if (typeof e == "number" && !isNaN(e)) return isFinite(e) ? Number.isInteger(e) ? e > 0 ? "PositiveIntegers" : e < 0 ? "NegativeIntegers" : "Integers" : e > 0 ? "PositiveNumbers" : e < 0 ? "NegativeNumbers" : "RealNumbers" : "ExtendedRealNumbers"; if (e instanceof v) return e.isNaN() ? "Numbers" : e.isFinite() ? e.isInteger() ? e.isPositive() ? "PositiveIntegers" : e.isNegative() ? "NegativeIntegers" : "Integers" : e.isPositive() ? "PositiveNumbers" : e.isNegative() ? "NegativeNumbers" : "RealNumbers" : "ExtendedRealNumbers"; if (e instanceof Va.Complex) { let n = e; return n.im, n.re === 0 ? "ImaginaryNumbers" : "ComplexNumbers" } if (U(e)) { let [n, i] = e; return typeof n != "number" || !Number.isNaN(n) && Number.isNaN(i), "RationalNumbers" } return "Numbers" } function at(e) { e.ctor; let n = e.engine, i = e.params, t = [], r = [], o, s = n.domain(i[i.length - 1]); for (let a of i.slice(0, -1)) if (b(a) === "OptArg") { if (r.length > 0) throw Error(`Unexpected multiple OptArg in domain ${e}`); if (o) throw Error(`Unexpected OptArg after VarArg in domain ${e}`); if (G(a) === 0) throw Error(`Unexpected empty OptArg in domain ${e}`); for (let u of B(a)) { if (b(u) === "OptArg") throw Error(`Unexpected OptArg of OptArg in domain ${e}`); if (b(u) === "VarArg") throw Error(`Unexpected superfluous OptArg of VarArg in domain ${e}`); r.push(n.domain(u)) } } else if (b(a) === "VarArg") { let u = B(a); if (u.length !== 1) throw Error(`Invalid VarArg in domain ${e}`); if (b(u[0]) === "OptArg") throw Error(`Unexpectedf VarArg of OptArg in domain ${e}`); if (b(u[0]) === "VarArg") throw Error(`Unexpected VarArg of VarArg in domain ${e}`); o = n.domain(u[0]) } else { if (r.length > 0) throw Error(`Unexpected required parameter after OptArg in domain ${e}`); if (o) throw Error(`Unexpected required parameter after VarArg in domain ${e}`); t.push(n.domain(a)) } return [t, r, o, s] } function ut(e) { let [n, i, t, r] = at(e); return { params: n.map(o => o.json), optParams: i.map(o => o.json), restParam: t?.json, result: r.json } } function tr(e, n) { let i = [...n.params]; return n.optParams.length > 0 && i.push(["OptArg", ...n.optParams]), n.restParam && i.push(["VarArg", n.restParam]), typeof n.result == "function" ? i.push(n.result(e, []) ?? e.symbol("Undefined")) : i.push(n.result), e.domain(["FunctionOf", ...i]) } function F(e) { return e.numericMode === "bignum" || e.numericMode === "auto" } function ae(e) { return e.numericMode === "auto" || e.numericMode === "complex" } function Di(e) { return typeof e == "string" ? e.startsWith("$") && e.endsWith("$") : !1 } function Ii(e) { return typeof e != "string" ? null : e.startsWith("$$") && e.endsWith("$$") ? e.slice(2, -2) : e.startsWith("$") && e.endsWith("$") ? e.slice(1, -1) : null } function xe(e) { let n = 0; for (let i = 0; i < e.length; i++)n = Math.imul(31, n) + e.charCodeAt(i) | 0; return Math.abs(n) } function lt(e) { let n = e.numericValue; return typeof n == "number" && Number.isInteger(n) ? P(n) : n instanceof v && n.isInteger() ? P(n) : null } function ft(e, n, i) { let t = []; for (let r of n) { let o = za(r, e, i); o !== null && (t.some(s => s.isEqual(o)) || t.push(o)) } return t } function ti(e, n) { let i = new Set; for (let { match: t, replace: r, condition: o, priority: s, id: a } of n) { let u; if (typeof o == "string") { let l = Ii(o); if (l) { let f = e.pattern(l); u = (d, c) => f.subs(d).evaluate()?.symbol === "True" } } else u = o; i.add({ match: e.pattern(t), replace: typeof r == "function" ? r : e.pattern(r), priority: s ?? 0, condition: u, id: a ?? e.box(t, { canonical: !1 }).toString() + (typeof r == "function" ? "  ->  function" : "  ->  " + e.box(r, { canonical: !1 }).toString()) }) } return i } function za({ match: e, replace: n, condition: i, id: t }, r, o, s) { let a = e.match(r, { substitution: o, ...s }); return a === null || typeof i == "function" && !i(a, r.engine) ? null : typeof n == "function" ? n(r, a) : n.subs(a, { canonical: !0 }) } function rr(e, n, i) { let t = i?.iterationLimit ?? 1, r = 0, o = i?.once ?? !1, s = !1, a = !1; try { for (; !s && r < t;) { s = !0; for (let u of n) { let l = za(u, e, {}, i); if (l !== null && l !== e) { if (o) return l; s = !1, a = !0, e = l } } r += 1 } } catch (u) { console.error(u) } return a ? e : null } var eu = pe(ce(), 1); var ki = ["InvalidDomain", "DictionaryOf", "FunctionOf", "ListOf", "TupleOf", "Intersection", "Union", "OptArg", "VarArg"], or = { Functions: ["FunctionOf", ["VarArg", "Anything"], "Anything"], NumericFunctions: ["FunctionOf", "Numbers", ["VarArg", "Numbers"], "Numbers"], RealFunctions: ["FunctionOf", "ExtendedRealNumbers", ["VarArg", "ExtendedRealNumbers"], "ExtendedRealNumbers"], LogicOperators: ["FunctionOf", "Booleans", ["VarArg", "Booleans"], "Booleans"], Predicates: ["FunctionOf", "Anything", ["VarArg", "Anything"], "Booleans"], RelationalOperators: ["FunctionOf", "Anything", "Anything", "Booleans"] }, qn = { Anything: [], Values: "Anything", Domains: "Anything", Void: "NothingDomain", NothingDomain: ["Booleans", "Strings", "Symbols", "Tuples", "Lists", "Dictionaries", "ImaginaryNumbers", "TranscendentalNumbers", "PositiveIntegers", "NegativeIntegers", "NonPositiveIntegers", "NonNegativeIntegers", "PositiveNumbers", "NegativeNumbers", "NonPositiveNumbers", "NonNegativeNumbers", "LogicOperators", "RelationalOperators"], Booleans: "Values", Strings: "Values", Symbols: "Values", Collections: "Values", Lists: "Collections", Dictionaries: "Collections", Sequences: "Collections", Tuples: "Collections", Sets: "Collections", Functions: "Anything", Predicates: "Functions", LogicOperators: "Predicates", RelationalOperators: "Predicates", NumericFunctions: "Functions", RealFunctions: "NumericFunctions", Numbers: "Values", ExtendedComplexNumbers: "Numbers", ComplexNumbers: "ExtendedComplexNumbers", ImaginaryNumbers: "ComplexNumbers", ExtendedRealNumbers: "ExtendedComplexNumbers", RealNumbers: ["ComplexNumbers", "ExtendedRealNumbers"], PositiveNumbers: "NonNegativeNumbers", NonNegativeNumbers: "RealNumbers", NonPositiveNumbers: "NegativeNumbers", NegativeNumbers: "RealNumbers", TranscendentalNumbers: "RealNumbers", AlgebraicNumbers: "RealNumbers", RationalNumbers: "AlgebraicNumbers", Integers: "RationalNumbers", PositiveIntegers: "NonNegativeIntegers", NonNegativeIntegers: "Integers", NonPositiveIntegers: "NegativeIntegers", NegativeIntegers: "Integers" }, dt; function ri(e) { return e ? qn[e] !== void 0 : !1 } function He(e) { if (dt || (dt = {}, He("Void")), dt[e]) return Array.from(dt[e]); let n = []; if (typeof e != "string" || !qn[e]) { if (!Array.isArray(e)) throw Error(`Unknown domain literal ${e}`); if (!ki.includes(e[0])) throw Error(`Unknown domain constructor ${e[0]}`); return e[0] === "FunctionOf" ? He("Functions") : e[0] === "TupleOf" ? He("Tuples") : e[0] === "ListOf" ? He("Lists") : e[0] === "DictionaryOf" ? He("Dictionaries") : e[0] === "OptArg" || e[0] === "VarArg" ? He(e[1]) : e[0] === "Literal" ? ["Anything"] : e[0] === "Union" ? ["Anything"] : e[0] === "Intersection" ? ["Anything"] : ["Anything"] } if (typeof qn[e] == "string") n = [qn[e], ...He(qn[e])]; else if (Array.isArray(qn[e])) for (let i of qn[e]) n.push(i), n.push(...He(i)); return dt[e] = new Set(n), n } function Ua() { let e = {}; for (let n of Object.keys(qn)) e[n] = { domain: "Domains", value: ["Domain", n] }; e.InvalidDomain = { signature: { domain: ["FunctionOf", "Domains", "Domains"], canonical: (n, i) => n.domain(["InvalidDomain", i[0]]) } }; for (let n of ["DictionaryOf", "FunctionOf", "ListOf", "TupleOf"]) e[n] = { signature: { domain: ["FunctionOf", ["VarArg", "Domains"], "Domains"], canonical: (i, t) => i.domain([n, ...t]) } }; for (let n of ["OptArg", "VarArg"]) e[n] = { signature: { domain: ["FunctionOf", "Domains", "Domains"], canonical: (i, t) => i.domain([n, t[0]]) } }; return e } var Wa = pe(ce(), 1); function wi(e) { return e.string !== null || (e.symbolDefinition?.value?.string ?? null) !== null ? !0 : (e.functionDefinition ?? e.symbolDefinition?.value?.functionDefinition)?.iterator !== void 0 } function sr(e) { return e.string !== null || (e.symbolDefinition?.value?.string ?? null) !== null ? !0 : (e.functionDefinition ?? e.symbolDefinition?.value?.functionDefinition)?.at !== void 0 } function ue(e) { if (e.string !== null || (e.symbolDefinition?.value?.string ?? null) !== null) return !0; let n = e.functionDefinition ?? e.symbolDefinition?.value?.functionDefinition; return n ? n.at !== void 0 && Number.isFinite(n.size?.(e) ?? 1 / 0) : !1 } function* X(e) { let n = Jf(e); if (!n) { yield e; return } let i = e.engine.iterationLimit, t = 0; for (; ;) { let { done: r, value: o } = n.next(); if (r) return; if (t++ > i) { yield e.engine.error("iteration-limit-exceeded"); return } yield o } } function Jf(e) { let n = e.functionDefinition ?? e.symbolDefinition?.value?.functionDefinition; if (n?.iterator) return n.iterator(e); let i = e.string ?? e.symbolDefinition?.value?.string ?? null; if (i !== null) { if (i.length === 0) return { next: () => ({ done: !0, value: void 0 }) }; let t = 0; return { next: () => ({ value: e.engine.string(i.charAt(t++)), done: t > i.length }) } } } function Ga(e, n) { let i = e.functionDefinition ?? e.symbolDefinition?.value?.functionDefinition; if (i?.at) return i.at(e, n); let t = e.string; if (t) return n < 1 ? e.engine.string(t.charAt(t.length + n)) : e.engine.string(t.charAt(n - 1)) } function te(e, n) { if (!n || e.every(t => !t.ops || t.head !== n)) return e; let i = []; for (let t of e) !t.ops || t.head !== n ? i.push(t) : i.push(...te(t.ops, n)); return i.length, e.length, i.length === e.length ? e : i } function se(e) { if (e.every(i => i.head !== "Sequence" && i.head !== "Delimiter")) return e; let n = []; for (let i of e) if (!i.isValid) n.push(i); else if (i.head === "Delimiter") if (i.op1.head === "Sequence") { let t = i.op1.ops ?? []; t.length === 0 ? n.push(i.engine.box(["Tupple"])) : n.push(...se(t)) } else n.push(i.op1); else i.head === "Sequence" ? i.ops && n.push(...i.ops) : n.push(i); return n } function Do(e, n) { return n === void 0 ? e._fn("Tuple", []) : n.head === "Delimiter" ? Do(e, n.op1) : n.head === "Sequence" ? n : n.ops ? e._fn("Tuple", n.ops) : n } var ct = pe(ce(), 1); function Io(e) { if (e.head === "Negate") return [-1, e.op1]; let n = e.numericValue; if (n === null) return [1, e]; let i = e.engine; return typeof n == "number" && n < 0 ? [-1, i.number(-n)] : n instanceof v && n.isNegative() ? [-1, i.number(n.neg())] : n instanceof ct.Complex && n.re < 0 ? [-1, i.number(i.complex(-n.re, -n.im))] : J(n) && n[0] < 0 ? [-1, i.number([-n[0], n[1]])] : K(n) && n[0] < 0 ? [-1, i.number([-n[0], n[1]])] : [1, e] } function Wf(e, n, i, t) { let r = e.numericValue, o = e.engine; return typeof r == "number" ? F(o) && i ? o.chop(i(o.bignum(r))) : o.chop(n(r)) : r instanceof v ? o.chop(i?.(r) ?? n(r.toNumber())) : J(r) ? !F(o) || !i ? o.chop(n(r[0] / r[1])) : o.chop(i(o.bignum(r[0]).div(r[1]))) : K(r) ? i ? o.chop(i(o.bignum(r[0]).div(o.bignum(r[1])))) : o.chop(n(Number(r[0]) / Number(r[1]))) : r instanceof ct.Complex ? !t || !ae(o) ? NaN : o.chop(t(r)) : NaN } function R(e, n, i, t) { if ((e?.numericValue ?? null) !== null) return e.engine.number(Wf(e, n, i, t)) } function Yf(e, n, i, t, r) { e.numericValue !== null && n.numericValue; let o = e.engine, s = e.numericValue; J(s) && (s = s[0] / s[1]); let a = n.numericValue; if (J(a) && (a = a[0] / a[1]), !F(o) && typeof s == "number" && typeof a == "number") return i(s, a); let u; s instanceof v ? u = s : K(s) ? u = o.bignum(s[0]).div(o.bignum(s[1])) : s !== null && typeof s == "number" && (u = o.bignum(s)); let l; return a instanceof v ? l = a : K(a) ? u = o.bignum(a[0]).div(o.bignum(a[1])) : a !== null && typeof a == "number" && (l = o.bignum(a)), u && l ? t?.(u, l) ?? i(u.toNumber(), l.toNumber()) : s instanceof ct.Complex || a instanceof ct.Complex ? !r || !ae(o) ? NaN : r(o.complex(s ?? u?.toNumber() ?? NaN), o.complex(a ?? l?.toNumber() ?? NaN)) : NaN } function Vn(e, n, i, t, r) { if (!(e.numericValue === null || n.numericValue === null)) return e.engine.number(Yf(e, n, i, t, r)) } function Bn(e, n, i) { return e === "all" ? !0 : e === "none" ? !1 : e === "first" ? i === 0 : e === "rest" ? i !== 0 : e === "last" ? i === n : e === "most" ? i !== n : !0 } function me(e) { return e.every(n => n.isCanonical) ? e : e.map(n => n.canonical) } function Se(e, n, i) { if (n = me(n), n = se(n), !e.strict || n.length === i) return n; let t = [...n.slice(0, i)], r = Math.min(i, n.length); for (; r < i;)t.push(e.error("missing")), r += 1; for (; r < n.length;)t.push(e.error("unexpected-argument", n[r])), r += 1; return t } function Pe(e, n, i) { let t = typeof i == "number" ? i : i?.count, r = typeof i == "number" || (i?.flatten ?? !0); if (n = me(n), r && (n = se(n)), typeof r == "string" && te(n, r), !e.strict) { for (let a of n) ue(a) || a.infer(e.Numbers); return n } let o = !0; t ?? (t = n.length); let s = []; for (let a = 0; a <= Math.max(t - 1, n.length - 1); a++) { let u = n[a]; if (a > t - 1) o = !1, s.push(e.error("unexpected-argument", u)); else if (u === void 0) o = !1, s.push(e.error("missing")); else if (u.symbol && !e.lookupSymbol(u.symbol) && !e.lookupFunction(u.symbol)) s.push(u); else if (u.isNumber || u.domain?.isNumber) s.push(u); else if (!u.isValid) o = !1, s.push(u); else if (!u.domain) s.push(u); else if (ue(u)) { for (let l of X(u)) if (!l.isNumber && !l.domain?.isNumber) { o = !1; break } o ? s.push(u) : s.push(e.domainError("Numbers", u.domain, u)) } else u.symbolDefinition?.inferredDomain && u.domain.isCompatible(e.Numbers, "contravariant") || u.functionDefinition?.signature.inferredSignature && u.domain.isCompatible(e.Numbers, "contravariant") ? s.push(u) : (o = !1, s.push(e.domainError("Numbers", u.domain, u))) } if (o) for (let a of s) if (ue(a)) for (let u of X(a)) u.infer(e.Numbers); else a.infer(e.Numbers); return s } function Fe(e, n, i) { return n == null ? e.error("missing") : i === void 0 ? e.error("unexpected-argument", n) : (n = n.canonical, n.head === "Sequence" && (n = n.op1), !n.isValid || !n.domain || n.domain.isCompatible(i) ? n : e.domainError(i, n.domain, n)) } function ja(e, n) { return n == null ? e.error("missing") : (n = n.canonical, !n.isValid || n.isPure ? n : e.error("expected-pure-expression", n)) } function ar(e, n, i) { if (n.length === i.length && n.every((r, o) => !r.domain || r.domain.isCompatible(i[o]))) return n; let t = []; for (let r = 0; r <= i.length - 1; r++)t.push(Fe(e, n[r], i[r])); for (let r = i.length; r <= n.length - 1; r++)t.push(e.error("unexpected-argument", n[r])); return t } function Za(e, n, i, t, r, o, s) { if (!e.strict) return null; let a = [], u = !0, l = 0; for (let f of r) { let d = n[l++]; if (!d) { a.push(e.error("missing")), u = !1; continue } if (Bn(i, r.length, l - 1)) { a.push(d); continue } if (!d.isValid) { a.push(d), u = !1; continue } if (!d.domain) { a.push(d); continue } if (t && ue(d)) { a.push(d); continue } if (d.symbolDefinition?.inferredDomain && d.domain.isCompatible(f, "contravariant")) { a.push(d); continue } if (d.functionDefinition?.signature.inferredSignature && d.domain.isCompatible(f, "contravariant")) { a.push(d); continue } if (!d.domain.isCompatible(f)) { a.push(e.domainError(f, d.domain, d)), u = !1; continue } a.push(d) } for (let f of o) { let d = n[l]; if (!d) break; if (Bn(i, r.length, l)) { a.push(d); continue } if (!d.isValid) { a.push(d), u = !1, l += 1; continue } if (!d.domain) { a.push(d), l += 1; continue } if (t && ue(d)) { a.push(d); continue } if (d.symbolDefinition?.inferredDomain && d.domain.isCompatible(f, "contravariant")) { a.push(d); continue } if (!d.domain.isCompatible(f)) { a.push(e.domainError(f, d.domain, d)), u = !1, l += 1; continue } a.push(d), l += 1 } if (s) for (let f of n.slice(l)) { if (l += 1, Bn(i, r.length, l - 1)) { a.push(f); continue } if (!f.isValid) { a.push(f), u = !1; continue } if (!f.domain) { a.push(f); continue } if (t && ue(f)) { a.push(f); continue } if (f.symbolDefinition?.inferredDomain && f.domain.isCompatible(s, "contravariant")) { a.push(f); continue } if (!f.domain.isCompatible(s)) { a.push(e.domainError(s, f.domain, f)), u = !1; continue } a.push(f) } if (l < n.length) for (let f of n.slice(l)) a.push(e.error("unexpected-argument", f)), u = !1; if (!u) return a; l = 0; for (let f of r) Bn(i, r.length, l) || (!t || !ue(n[l])) && n[l].infer(f), l += 1; for (let f of o) (!t || !ue(n[l])) && n[l]?.infer(f), l += 1; if (s) for (let f of n.slice(l)) Bn(i, r.length, l) || (!t || !ue(f)) && f.infer(s), l += 1; return null } function ur(e) { if (!e) return; let n = e.engine, i = [], t = e.ops?.length == 3, r = e.ops[0].ops[0].ops, o = r?.length ?? 0, s = null; if (!(t && (s = e.ops[2].ops[0].ops, r?.length != s?.length))) { for (let a = 0; a < o; a++) { let u, l, f = null, d = null; l = r[a].canonical, r && r[a].head === "Equal" && (l = r[a].op1.canonical, f = r[a].op2.canonical), s && (d = s[a].canonical), d && f ? u = $n(n.tuple([l, f, d])) : d ? u = $n(n.tuple([l, n.One, d])) : f ? u = $n(n.tuple([l, f])) : u = $n(l), u && i.push(u) } return i } } function $n(e) { if (!e) return; let n = e.engine, i = null, t = null, r = null; return e.head !== "Tuple" && e.head !== "Triple" && e.head !== "Pair" && e.head !== "Single" ? i = e : (i = e.ops[0] ?? null, t = e.ops[1]?.canonical ?? null, r = e.ops[2]?.canonical ?? null), i.head === "Hold" && (i = i.op1), i.symbol && (n.declare(i.symbol, { domain: "Integers" }), i.bind()), t && t.isFinite && (t = Fe(n, t, "Integers")), r && r.isFinite && (r = Fe(n, r, "Integers")), t && r ? n.tuple([i, t, r]) : r ? n.tuple([i, n.One, r]) : t ? n.tuple([i, t]) : i } function zn(e) { let n = 1, i = n + Xt, t, r = !0; if (e && (e.head === "Tuple" || e.head === "Triple" || e.head === "Pair" || e.head === "Single")) { if (t = (e.op1.head === "Hold" ? e.op1.op1.symbol : e.op1.symbol) ?? "Nothing", n = q(e.op2) ?? 1, Number.isFinite(n) || (r = !1), e.op3.isNothing || e.op3.isInfinity) r = !1; else { let o = q(e.op3); o === null ? r = !1 : (i = o, Number.isFinite(i) || (r = !1)) } !r && Number.isFinite(n) && (i = n + Xt) } else e && (t = (e.head === "Hold" ? e.op1.symbol : e.symbol) ?? "Nothing", n = 1, i = n + Xt); return [t, n, i, r] } function Ci(e, n) { return e.flatMap(i => n.map(t => [i, t])) } function cn(e, n) { return Array.from({ length: n - e + 1 }, (i, t) => e + t) } var Qf = { Add: ["+", 11], Negate: ["-", 14], Subtract: ["-", 11], Multiply: ["*", 12], Divide: ["/", 13], Equal: ["===", 8], NotEqual: ["!==", 8], LessEqual: ["<=", 9], GreaterEqual: [">=", 9], Less: ["<", 9], Greater: [">", 9], And: ["&&", 4], Or: ["||", 3], Not: ["!", 14] }, Xf = {
      Abs: "Math.abs", Add: (e, n) => e.length === 1 ? n(e[0]) : `(${e.map(i => n(i)).join(" + ")})`, Arccos: "Math.acos", Arcosh: "Math.acosh", Arsin: "Math.asin", Arsinh: "Math.asinh", Arctan: "Math.atan", Artanh: "Math.atanh", Ceiling: "Math.ceil", Chop: "_SYS.chop", Cos: "Math.cos", Cosh: "Math.cosh", Exp: "Math.exp", Floor: "Math.floor", Gamma: "_SYS.gamma", GCD: "_SYS.gcd", LCM: "_SYS.lcm", Limit: (e, n) => `_SYS.limit(${n(e[0])}, ${n(e[1])})`, Ln: "Math.log", List: (e, n) => `[${e.map(i => n(i)).join(", ")}]`, Log: (e, n) => e.length === 1 ? `Math.log(${n(e[0])})` : `(Math.log(${n(e[0])}) / Math.log(${n(e[1])}))`, LogGamma: "_SYS.lngamma", Lb: "Math.log2", Max: "Math.max", Min: "Math.min", Power: (e, n) => { let i = e[0]; if (i === null) throw new Error("Power: no argument"); let t = E(e[1]); return t === .5 ? `Math.sqrt(${n(i)})` : t === 1 / 3 ? `Math.cbrt(${n(i)})` : t === 1 ? n(i) : t === -1 ? `1 / (${n(i)})` : t === -.5 ? `1 / Math.sqrt(${n(i)})` : `Math.pow(${n(i)}, ${n(e[1])})` }, Range: (e, n) => {
        if (e.length === 0) return "[]"; if (e.length === 1) return `Array.from({length: ${n(e[0])}}, (_, i) => i)`; let i = n(e[0]), t = n(e[1]), r = e[2] ? n(e[2]) : "1"; if (i === null) throw new Error("Range: no start"); if (t === null && (t = i, i = "1"), r === "0") throw new Error("Range: step cannot be zero"); if (parseFloat(r) === 1) {
          let o = parseFloat(t), s = parseFloat(i); return o !== null && s !== null ? o - s < 50 ? `[${Array.from({ length: o - s + 1 }, (a, u) => s + u).join(", ")}]` : `Array.from({length: ${o - s + 1} 
        }, (_, i) => ${i} + i)` : `Array.from({length: ${t} - ${i} + 1
      }, (_, i) => ${i} + i)`
        } return `Array.from({length: Math.floor((${t} - ${i}) / ${r}) + 1}, (_, i) => ${i} + i * ${r})`
      }, Root: (e, n) => { let i = e[0]; if (i === null) throw new Error("Root: no argument"); let t = e[1]; return t === null ? `Math.sqrt(${n(i)})` : `Math.pow(${n(i)}, 1 / (${n(t)}))` }, Random: "Math.random", Round: "Math.round", Square: (e, n) => { let i = e[0]; if (i === null) throw new Error("Square: no argument"); return `Math.pow(${n(i)}, 2)` }, Sgn: "Math.sign", Sin: "Math.sin", Sinh: "Math.sinh", Sqrt: "Math.sqrt", Tan: "Math.tan", Tanh: "Math.tanh"
    }, ko = class extends Function { constructor(i) { super("_SYS", "_", `return ${i}`); this.sys = { factorial: er, gamma: Ti, lngamma: ot, gcd: Sn, lcm: Kt, chop: _i, limit: Kn }; return new Proxy(this, { apply: (t, r, o) => super.apply(r, [this.sys, ...o]), get: (t, r) => r === "toString" ? () => i : t[r] }) } }; function Kf(e, n) { let i = he(e, n); return new ko(i) } function Ha(e) { let n = e.unknowns; return Kf(e, { operators: i => Qf[i], functions: i => Xf[i], var: i => { let t = { Pi: "Math.PI", ExponentialE: "Math.E", NaN: "Number.NaN", ImaginaryUnit: "Number.NaN", Half: "0.5", MachineEpsilon: "Number.EPSILON", GoldenRatio: "((1 + Math.sqrt(5)) / 2)", CatalanConstant: "0.91596559417721901", EulerGamma: "0.57721566490153286" }[i]; if (t !== void 0) return t; if (n.includes(i)) return `_.${i}` }, string: i => JSON.stringify(i), number: i => i.toString(), indent: 0, ws: i => i ?? "" }) } function Ja(e, n, i, t) {
      if (e === "Error") throw new Error("Error"); if (e === "Sequence") return n.length === 0 ? "" : `(${n.map(o => he(o, t, i)).join(", ")})`; if (e === "Sum" || e === "Product") return ed(e, n, t); if (n.every(o => !wi(o))) { let o = t.operators?.(e); if (Ki(e) && n.length > 2 && o) { let s = []; for (let a = 0; a < n.length - 1; a++)s.push(Ja(e, [n[a], n[a + 1]], o[1], t)); return `(${s.join(") && (")})` } if (o !== void 0) { if (n === null) return ""; let s; return n.length === 1 ? s = `${o[0]}${he(n[0], t, o[1])}` : s = n.map(a => he(a, t, o[1])).join(` ${o[0]} `), o[1] < i ? `(${s})` : s } } if (e === "Function") { let o = n.slice(1).map(s => s.symbol); return `((${o.join(", ")}) => ${he(n[0].canonical, { ...t, var: s => o.includes(s) ? s : t.var(s) })})` } if (e === "Declare") return `let ${n[0].symbol}`; if (e === "Assign") return `${n[0].symbol} = ${he(n[1], t)}`; if (e === "Return") return `return ${he(n[0], t)}`; if (e === "If") { if (n.length !== 3) throw new Error("If: wrong number of arguments"); return `((${he(n[0], t)}) ? (${he(n[1], t)}) : (${he(n[2], t)}))` } if (e === "Block") {
        let o = []; for (let a of n) a.head === "Declare" && o.push(a.ops[0].symbol); if (n.length === 1 && o.length === 0) return he(n[0], t); let s = n.map(a => he(a, { ...t, var: u => o.includes(u) ? u : t.var(u) })); return s[s.length - 1] = `return ${s[s.length - 1]}`, `(() => {${t.ws(`
`)}${s.join(`;${t.ws(`
`)}`)}${t.ws(`
`)}})()`
      } let r = t.functions?.(e); if (!r) throw new Error(`Unknown function ${e}`); if (typeof r == "function") { if (n.length === 1 && ue(n[0])) { let o = Mi(); return `(${he(n[0], t)}).map((${o}) => ${r(n[0].engine.box(o), s => he(s, t))})` } return r(n, o => he(o, t)) } if (n === null) return `${r}()`; if (n.length === 1 && ue(n[0])) { let o = Mi(); return `(${he(n[0], t)}).map((${o}) => ${r}(${he(n[0].engine.box(o), t)}))` } return `${r}(${n.map(o => he(o, t)).join(", ")})`
    } function he(e, n, i = 0) { if (e === void 0) return ""; if (!e.isValid) throw new Error("Invalid expression"); let t = E(e); if (t !== null) return n.number(t); let r = e.symbol; if (r !== null) return n.var?.(r) ?? r; if (e.string !== null) return n.string(r); let s = e.keys; if (s !== null) { let u = []; for (let l of s) { let f = e.getKey(l); f && u.push(`${l}: ${he(f, n, 0)}`) } return `{${u.join(", ")}}` } let a = e.head; return typeof a == "string" ? Ja(a, e.ops, i, n) : "" } function ed(e, n, i) {
      if (n === null) throw new Error("Sum/Product: no arguments"); if (!n[0]) throw new Error("Sum/Product: no body"); let [t, r, o, s] = zn(n[1]), a = e === "Sum" ? "+" : "*"; if (!t) { let d = Mi(), c = Mi(); return `${he(n[0], i)}.reduce((${c}, ${d}) => ${c} ${a} ${d}, ${a === "+" ? "0" : "1"})` } let u = he(n[0], { ...i, var: d => d === t ? t : i.var(d) }), l = Mi(), f = Mi(); return `(() => {
  let ${f} = ${a === "+" ? "0" : "1"};
  let ${t} = ${r};
  const _fn = () => ${u};
  while (${l} <= ${o}) {
    ${f} ${a}= _fn();
    ${l}++;
  }
  return ${f};
})()`} function Mi() { return `_${Math.random().toString(36).substring(2)}` } var L = class { constructor(n, i) { this.engine = n, i?.latex !== void 0 && (this._latex = i.latex) } valueOf() { return this.symbol === "True" ? !0 : this.symbol === "False" ? !1 : this.head && typeof this.head == "string" && ["List", "Set", "Sequence", "Tuple", "Pair", "Single", "Triple"].includes(this.head) ? this.ops?.map(n => n.valueOf()) : E(this) ?? this.string ?? this.symbol ?? JSON.stringify(this.json) } toString() { if (this.symbol) return this.symbol; if (this.string) return `"${this.string}"`; let n = this.numericValue; if (n !== null) { if (typeof n == "number" || n instanceof v) return n.toString(); if (J(n)) return `(${n[0].toString()}/${n[1].toString()})`; if (K(n)) return `(${n[0].toString()}/${n[1].toString()})`; if (n instanceof Wa.Complex) { let i = n.im === 1 ? "" : n.im === -1 ? "-" : n.im.toString(); return n.re === 0 ? i + "i" : n.im < 0 ? `${n.re.toString()}${i}i` : `(${n.re.toString()}+${i}i)` } } return this.head && typeof this.head == "string" ? this.head === "List" ? `[${this.ops?.map(i => i.toString())}]` : this.head === "Domain" ? JSON.stringify(this.json) : `${this.head}(${this.ops?.map(i => i.toString()).join(", ")})` : JSON.stringify(this.json) } print() { this.toString() } [Symbol.toPrimitive](n) { if (n === "number") { let i = this.valueOf(); return typeof i == "number" ? i : null } return this.toString() } toJSON() { return this.json } get rawJson() { return this.json } get scope() { return null } is(n) { return n == null ? !1 : this.isSame(this.engine.box(n)) } get canonical() { return this } get latex() { return this._latex ?? this.engine.serialize(this) } set latex(n) { this._latex = n } get symbol() { return null } get isNothing() { return !1 } get string() { return null } getSubexpressions(n) { return wo(this, n) } get subexpressions() { return this.getSubexpressions("") } get symbols() { let n = new Set; return fr(this, n), Array.from(n) } get unknowns() { let n = new Set; return dr(this, n), Array.from(n) } get freeVariables() { let n = new Set; return lr(this, n), Array.from(n) } get errors() { return this.getSubexpressions("Error") } get ops() { return null } get nops() { return 0 } get op1() { return this.engine.Nothing } get op2() { return this.engine.Nothing } get op3() { return this.engine.Nothing } get isValid() { return !0 } get isPure() { return !1 } get isExact() { return !1 } get isConstant() { return !1 } get isNaN() { } get isZero() { } get isNotZero() { } get isOne() { } get isNegativeOne() { } get isInfinity() { } get isFinite() { } get isEven() { } get isOdd() { } get isPrime() { } get isComposite() { } get numericValue() { return null } get sgn() { return null } get shape() { return [] } get rank() { return 0 } subs(n, i) { return i?.canonical ? this.canonical : this } solve(n) { return null } replace(n) { return null } has(n) { return !1 } isLess(n) { } isLessEqual(n) { } isGreater(n) { } isGreaterEqual(n) { } get isPositive() { } get isNonNegative() { } get isNegative() { } get isNonPositive() { } isCompatible(n, i) { return !1 } get description() { if (this.baseDefinition && this.baseDefinition.description) return typeof this.baseDefinition.description == "string" ? [this.baseDefinition.description] : this.baseDefinition.description } get url() { return this.baseDefinition?.url ?? void 0 } get wikidata() { return this.baseDefinition?.wikidata ?? void 0 } get complexity() { } get baseDefinition() { } get symbolDefinition() { } get functionDefinition() { } infer(n) { return !1 } bind() { } reset() { } get keys() { return null } get keysCount() { return 0 } getKey(n) { } hasKey(n) { return !1 } get value() { return this.N().valueOf() } set value(n) { throw new Error(`Can't change the value of \\(${this.latex}\\)`) } get domain() { } set domain(n) { throw new Error(`Can't change the domain of \\(${this.latex}\\)`) } get isNumber() { } get isInteger() { } get isRational() { } get isAlgebraic() { return !1 } get isReal() { } get isExtendedReal() { } get isComplex() { } get isImaginary() { } get isExtendedComplex() { } simplify(n) { return this } evaluate(n) { return this.simplify() } N(n) { return this.evaluate({ numericMode: !0 }) } compile(n = "javascript", i) { if (n !== "javascript") return; i ?? (i = { optimize: ["simplify"] }); let t = this; return i.optimize.includes("simplify") && (t = t.simplify()), i.optimize.includes("evaluate") && (t = t.evaluate()), Ha(t) } }; function lr(e, n) { if (e.head, e.symbol) { let i = e.engine.lookupSymbol(e.symbol); if (i && i.value !== void 0) return; let t = e.engine.lookupFunction(e.symbol); if (t && (t.signature.evaluate || t.signature.N)) return; n.add(e.symbol); return } if (e.head && typeof e.head != "string" && lr(e.head, n), e.ops) for (let i of e.ops) lr(i, n); if (e.keys) for (let i of e.keys) lr(e.getKey(i), n) } function fr(e, n) { if (e.symbol) { n.add(e.symbol); return } if (e.head && typeof e.head != "string" && fr(e.head, n), e.ops) for (let i of e.ops) fr(i, n); if (e.keys) for (let i of e.keys) fr(e.getKey(i), n) } function dr(e, n) { if (e.symbol) { let i = e.symbol; if (i === "Unknown" || i === "Undefined" || i === "Nothing") return; let t = e.engine.lookupSymbol(i); if (t && t.value !== void 0) return; let r = e.engine.lookupFunction(i); if (r && (r.signature.evaluate || r.signature.N)) return; n.add(i); return } if (e.head && typeof e.head != "string" && dr(e.head, n), e.ops) for (let i of e.ops) dr(i, n); if (e.keys) for (let i of e.keys) dr(e.getKey(i), n) } function wo(e, n) { let i = !n || e.head === n ? [e] : []; if (e.ops) for (let t of e.ops) i.push(...wo(t, n)); else if (e.keys) for (let t of e.keys) i.push(...wo(e.getKey(t), n)); return i } var Dn = class e extends L { constructor(i, t, r) { t instanceof e; super(i, r); if (typeof t == "string") { if (!ri(t)) throw Error(`Unknown domain literal "${t}"`); this.base = t, this.ctor = null, this.params = []; return } if (!Array.isArray(t)) throw Error("Expected a domain expression"); if (!ki.includes(t[0])) throw Error(`Unknown domain constructor "${t[0]}`); let o = t[0]; if (this.ctor = o, o === "OptArg" || o === "VarArg") throw Error(`Unexpected domain constructor "${o}" outside of FunctionOf`); if (this.params = t.slice(1).map(s => s instanceof L ? s.json : s), o === "FunctionOf" && (this.base = "Functions", i.strict && at(this)), o === "DictionaryOf" && (this.base = "Dictionaries"), o === "ListOf" && (this.base = "Lists"), o === "TupleOf" && (this.base = "Tuples"), o === "Covariant" || o === "Contravariant" || o === "Bivariant" || o === "Invariant") { let s = i.domain(t[1]); if (this.ctor = o, this.base = s.base, this.params = [s.json], t.length !== 2) throw Error(`Invalid "${o}" in domain "${t}"`) } if (o === "Union" || o === "Intersection") { let s; if (o === "Union") for (let a of this.params) s = Un(s, i.domain(a)); else for (let a of this.params) s = mt(s, i.domain(a)); this.base = s.base } } get isCanonical() { return !0 } get canonical() { return this } get isValid() { return !0 } get json() { return this.ctor ? [this.ctor, ...this.params] : this.base } get hash() { return this._hash === void 0 && (this._hash = xe(JSON.stringify(this.json))), this._hash } isCompatible(i, t = "covariant") { let r = this.json, o = i instanceof e ? i.json : i, s = Array.isArray(o) ? o[0] : null; if (s) { let a = o[1]; if (s === "Covariant") return ve(r, a); if (s === "Contravariant") return ve(a, r); if (s === "Invariant") return !ve(a, r) && !ve(r, a); if (s === "Bivariant") return ve(r, a) && ve(a, r) } return t === "covariant" ? ve(r, o) : t === "contravariant" ? ve(o, r) : t === "bivariant" ? ve(o, r) && ve(r, o) : !ve(o, r) && !ve(r, o) } isEqual(i) { return i instanceof e ? this === i ? !0 : this.isCompatible(i, "invariant") : !1 } isSame(i) { return this.isEqual(i) } match(i, t) { return i instanceof e && this.isCompatible(i, "invariant") ? {} : null } get head() { return "Domain" } get domain() { return this.engine.domain("Domains") } get isFunction() { return this.base === "Functions" } get isNumeric() { return this.isCompatible(this.engine.domain("Numbers")) } }; function mn(e) { if (e instanceof Dn) return !0; if (e instanceof L && (e = e.json), typeof e == "string") return ri(e); if (!Array.isArray(e) || e.length <= 1) return !1; let n = e[0]; return typeof n != "string" || !ki.includes(n) ? !1 : n === "ListOf" || n === "OptArg" || n === "VarArg" ? e.length === 2 && mn(e[1]) : n === "FunctionOf" || n === "TupleOf" || n === "Intersection" || n === "Union" ? e.slice(1).every(mn) : e.every(i => i !== null) } function ve(e, n) { let [i, t] = cr([e], n); return !!(i && t.length === 0) } function cr(e, n) { let i = e.shift(), t = typeof n == "string" ? n : null; if (t === "Anything") return [!0, e]; let r = typeof i == "string" ? i : null; if (r && t) return r === t ? [!0, e] : [He(r).includes(t), e]; if (t) { let s = i[0]; return s === "FunctionOf" ? [t === "Functions", e] : s === "DictionaryOf" ? [t === "Dictionaries", e] : s === "ListOf" ? [t === "Lists", e] : s === "TupleOf" ? [t === "Tuples", e] : [!0, e] } let o = n[0]; if (o === "FunctionOf") { if (r === "Functions") return [!0, e]; if (r) return [!1, e]; if (i[0] !== "FunctionOf") return [!1, e]; if (i.length === 1 && n.length === 1) return [!0, e]; if (!ve(i[i.length - 1], n[n.length - 1])) return [!1, e]; let s = i.slice(1, -1), a = n.slice(1, -1); for (let u = 0; u <= s.length - 1; u++) { if (a.length === 0) return (Array.isArray(s[u]) ? s[u][0] : null) !== "OptArg" ? [!1, e] : [!0, e]; { let l = !1; if ([l, a] = cr(a, s[u]), !l) return [!1, e] } } return [a.length === 0, e] } if (o === "Intersection") return [n.slice(1, -1).every(s => ve(i, s)), e]; if (o === "Union") return [n.slice(1, -1).some(s => ve(i, s)), e]; if (o === "OptArg") return r === "NothingDomain" ? [!0, e] : cr([i, ...e], n[1]); if (o === "VarArg") { let s = n[1]; if (!ve(i, s)) return [!1, e]; i = e.shift(); let a = !0; for (; e.length > 0 && a;) [a, e] = cr(e, s), i = e.shift(); return [!0, e] } if (o === "TupleOf") { if (!Array.isArray(i) || i[0] !== "TupleOf") return [!1, e]; if (i.length > n.length) return [!1, e]; for (let s = 1; s <= n.length - 1; s++)if (!i[s] || !ve(i[s], n[s])) return [!1, e]; return [!0, e] } return console.error("Unexpected domain constructor " + o), [!1, e] } function Un(e, n) { if (e == null) return n; if (n == null) return e; let i = [e.base, ...He(e.base)], t = [n.base, ...He(n.base)]; for (; !t.includes(i[0]);)i.shift(); return e.engine.domain(i[0]) } function mt(e, n) { return e === void 0 ? n : n === void 0 || ve(e.base, n.base) ? e : ve(n.base, e.base) ? n : e.engine.Void } var Mo = pe(ce(), 1); function ht(e) { if (e.head === "Power" && e.op2.numericValue !== null) { let n = q(e.op2); return n !== null && n > 0 ? n : 1 } if (e.head === "Multiply") { let n = 1; for (let i of e.ops) { let t = ht(i); t > 1 && (n = n + t) } return n } return 1 } function Co(e) { if (e.head === "Power" && e.op2.numericValue !== null) { let n = q(e.op2); return n !== null && n > 0 ? n : 1 } if (e.head === "Multiply") { let n = 1; for (let i of e.ops) n = Math.max(n, ht(i)); return n } return 1 } function pt(e) { return e.symbol ? e.symbol : e.ops ? (typeof e.head == "string" ? e.head : pt(e.head)) + '"' + e.ops.map(i => pt(i)).filter(i => i.length > 0).join('"') : "" } var pn = 1e5; function Ao(e) { return e.sort((n, i) => { let t = pt(n), r = pt(i); if (!t && !r) return tn(n, i); if (!t) return 1; if (!r || t < r) return -1; if (t > r) return 1; let o = ht(n), s = ht(i); if (o !== s) return s - o; let a = Co(n), u = Co(i); return a !== u ? a - u : tn(n, i) }) } function tn(e, n) { if (e === n || e.numericValue !== null && e.numericValue === n.numericValue) return 0; let i = E(e); if (i !== null) { let t = E(n); return t !== null ? i - t : -1 } if (e.numericValue instanceof Mo.Complex) return n.numericValue instanceof Mo.Complex ? e.numericValue.re === n.numericValue.re ? Math.abs(e.numericValue.im) === Math.abs(n.numericValue.im) ? e.numericValue.im - n.numericValue.im : Math.abs(e.numericValue.im) - Math.abs(n.numericValue.im) : e.numericValue.re - n.numericValue.re : n.numericValue !== null ? 1 : -1; if (e.numericValue) return n.numericValue ? 1 : -1; if (e.head === "Sqrt" && e.op1.numericValue) return n.head === "Sqrt" && n.op1.numericValue ? tn(e.op1, n.op1) : -1; if (e.symbol) return n.symbol ? e.symbol === n.symbol ? 0 : e.symbol > n.symbol ? 1 : -1 : n.numericValue !== null ? 1 : -1; if (e.ops) { if (n.ops) { let t = e.functionDefinition?.complexity ?? pn, r = n.functionDefinition?.complexity ?? pn; return t === r ? typeof e.head == "string" && typeof n.head == "string" ? e.head === n.head ? Ai(e) - Ai(n) : e.head < n.head ? 1 : -1 : Ai(e) - Ai(n) : t - r } return n.numericValue !== null || n.symbol ? 1 : -1 } if (e.string) return n.string ? e.string.length !== n.string.length ? n.string.length - e.string.length : n.string < e.string ? -1 : e.string > n.string ? 1 : 0 : n.keys ? -1 : 1; if (e.keys && n.keys) { if (e.keysCount !== n.keysCount) return n.keysCount - e.keysCount; let t = 0, r = 0; for (let o of n.keys) t += n.getKey(o).complexity ?? pn; for (let o of e.keys) r += e.getKey(o).complexity ?? pn; return r - t } return (e.complexity ?? pn) - (n.complexity ?? pn) } function Oo(e, { recursive: n = !1 }) { if (e.ops) { let i = n ? e.ops.map(t => Oo(t, { recursive: n })) : e.ops; return i = e.head === "Add" ? Ao(i) : i.sort(tn), e.engine._fn(e.head, i) } return e } function Ai(e) { return e.keys !== null ? 1 + e.keysCount : e.ops ? (typeof e.head == "string" ? 1 : Ai(e.head)) + [...e.ops].reduce((n, i) => n + Ai(i), 0) : 1 } var Ka = pe(ce(), 1); var Oi = pe(ce(), 1); function Je(e) { e.isCanonical; let n = e.engine; if (e.head === "Multiply") { let r = [], o = [1, 1]; for (let s of e.ops) { let a = W(s); a ? o = Q(o, a) : r.push(s) } return ie(o) ? [o, e] : [o, n.mul(...r)] } if (e.head === "Divide") { let [r, o] = Je(e.op1), [s, a] = Je(e.op2), u = Q(r, Tn(s)); return a.isOne ? [u, o] : ie(u) ? [u, e] : [u, n.div(o, a)] } if (e.head === "Power") { if (e.op2.numericValue === null) return [[1, 1], e]; let [r, o] = Je(e.op1); if (ie(r)) return [r, e]; let s = E(e.op2); return typeof s == "number" && Number.isInteger(s) ? [ir(r, s), n.pow(o, e.op2)] : [[1, 1], e] } if (e.head === "Sqrt") { let [r, o] = Je(e.op1), s = Ra(r); return s ? [s, n.sqrt(o)] : [[1, 1], e] } if (e.head, e.head === "Negate") { let [r, o] = Je(e.op1); return [_e(r), o] } let i = e.numericValue; if (i instanceof Oi.default && i.re < 0) return [[-1, 1], n.number(n.complex(-i.re, -i.im))]; let t = W(e); return t ? [t, n.One] : [[1, 1], e] } function Qa(e, n) { if (ie(n)) return e; if (Ze(n)) return 0; if (e === null) return null; if (Bi(n)) return typeof e == "number" ? -e : e instanceof Ue || e instanceof Oi.default ? e.neg() : _e(e); if (U(e)) return Q(e, n); if (K(n)) { let [i, t] = n; if (typeof e == "number") return Number.isInteger(e) ? [BigInt(e) * i, BigInt(e) * t] : new Ue(e).mul(i.toString()).div(t.toString()); if (e instanceof Ue) { let [r, o] = [new Ue(i.toString()), new Ue(t.toString())]; return e.isInteger() ? t === BigInt(1) ? e.mul(r) : [BigInt(e.mul(r).toString()), t] : e.mul(r).div(o) } if (e instanceof Oi.default) return e.mul(Number(i)).div(Number(t)) } else { let [i, t] = n; if (typeof e == "number") return Number.isInteger(e) ? [e * i, t] : e * i / t; if (e instanceof Ue) return e.isInteger() ? [BigInt(e.mul(i).toString()), BigInt(t)] : e.mul(i).div(t); if (e instanceof Oi.default) return e.mul(i).div(t) } return null } function oi(e) { let n = e.engine, i = e.head; if (Ki(i)) return n.function(i, [oi(e.ops[0]), oi(e.ops[1])]); if (i === "Divide") return n.div(e.ops[0], e.ops[1]); if (i === "Add") { let [t, r] = e.ops.reduce((o, s) => (s.head === "Divide" ? (o[0].push(s.ops[0]), o[1].push(s.ops[1])) : o[0].push(s), o), [[], []]); return n.div(n.add(...t), n.add(...r)) } return i === "Negate" ? n.neg(oi(e.ops[0])) : e } function Ya(e, n) { let i = [], t = e.engine; for (let o of e.factors) { let s = n.find(o.factor); if (s !== -1) if (o.exponent.isSame(n.factors[s].exponent)) i.push(o); else { let a = E(o.exponent), u = E(n.factors[s].exponent); if (a !== null && u !== null) { if (a > 0 && u > 0) { let l = Math.min(a, u); i.push({ factor: o.factor, exponent: t.number(l) }) } else if (a < 0 && u < 0) { let l = Math.max(a, u); i.push({ factor: o.factor, exponent: t.number(l) }) } } } } let r = e.integerCoefficient(); if (r !== null) { let o = n.integerCoefficient(); o !== null && i.push({ factor: t.number(Sn(r, o)), exponent: t.One }) } return i.length === 0 ? t.One : t.mul(...i.map(o => t.pow(o.factor, o.exponent))) } function Xa(e) { let n = e.head; if (Ki(n)) { let t = new Gn(e.op1), r = new Gn(e.op2); t.reduceExactNumbers(), r.reduceExactNumbers(); let o = Ya(t, r); return o.isOne || (t.div(o), r.div(o)), e.engine.function(n, [t.asExpression(), r.asExpression()]) } if (n === "Add") { let t = null; for (let r of e.ops) if (!t) t = new Gn(r), t.reduceExactNumbers(); else { let o = new Gn(r); o.reduceExactNumbers(), t = new Gn(Ya(t, o)), t.reduceExactNumbers() } return t?.asExpression() ?? e.engine.One } let i = new Gn(oi(e)); return i.reduceExactNumbers(), i.asExpression() } var Gn = class { constructor(n) { this.factors = []; this.hasNaN = !1; this.hasZero = !1; this.hasInfinity = !1; this.sign = 1; this.engine = n.engine, this.mul(oi(n)) } div(n) { if (!n.isOne) { if (n.isNegativeOne) { this.sign *= -1; return } this.mul(n, this.engine.NegativeOne) } } mul(n, i) { if (i ?? (i = n.engine.One), n.head === "Negate" && (this.sign *= -1, n = n.ops[0]), n.head === "Divide") { this.mul(n.ops[0], i), this.mul(n.ops[1], this.engine.neg(i)); return } if (n.head === "Multiply") { for (let r of n.ops) this.mul(r, i); return } if (n.head === "Power") { this.mul(n.ops[0], this.engine.mul(n.ops[1], i)); return } if (n.head === "Sqrt") { this.mul(n.ops[0], this.engine.mul(this.engine.Half, i)); return } if (n.isNegative && (this.sign *= -1, n = this.engine.neg(n)), i.isZero || n.isOne) return; if (n.isNaN) { this.hasNaN = !0; return } if (n.isZero) { i.isNonNegative ? this.hasZero = !0 : this.hasNaN = !0; return } if (n.isInfinity && i.isNonNegative) { i.isNonNegative ? this.hasInfinity = !0 : this.hasNaN = !0; return } let t = this.find(n); t === -1 ? this.factors.push({ factor: n, exponent: i }) : this.factors[t].exponent = this.engine.add(this.factors[t].exponent, i) } find(n) { return this.factors.findIndex(i => i.factor.isSame(n)) } has(n) { return this.find(n) !== -1 } reduceNumbers() { let n = this.factors; this.factors = []; let i = this.engine, t = i.One; for (let r of n) { let o = r.factor.N(); o.numericValue !== null ? t = i.mul(t, i.pow(o, r.exponent)) : this.factors.push(r) } t.isOne || this.factors.push({ factor: t, exponent: i.One }) } reduceExactNumbers() { let n = this.engine; for (let l of this.factors) { let f = l.factor; if (f.numericValue !== null && !f.isExact) return this.reduceNumbers() } let i = this.factors; this.factors = []; let t = [1, 1], r = 1, o = 0, s = [1, 1]; for (let l of i) { let f = E(l.exponent); if (f === null) { this.factors.push(l); continue } if (Number.isInteger(2 * f)) { let m = W(l.factor); if (m) { s = Q(s, ir(m, 2 * f)); continue } } let d = W(l.factor); if (d) { t = Q(t, ir(d, f)); continue } let c = l.factor.numericValue; if (c !== null && c instanceof Oi.default && Number.isInteger(c.re) && Number.isInteger(c.im) && Number.isInteger(f)) { c = c.pow(f), t = Q(t, [c.re, 1]), c.im !== 0 && (r *= c.im, o += f); continue } this.factors.push(l) } let [a, u] = qa(s); t = Q(t, a), o !== 0 && (o % 2 === 0 ? t = Q(t, [r, 1]) : Pa(t) ? (this.factors.push({ factor: n.number(n.complex(Oe(t), r)), exponent: n.One }), t = [1, 1]) : this.factors.push({ factor: n.number(n.complex(0, r)), exponent: n.One })), ie(t) || this.factors.push({ factor: n.number(t), exponent: n.One }), ie(u) || this.factors.push({ factor: n.sqrt(n.number(u)), exponent: n.One }) } integerCoefficient() { let n = null; for (let i of this.factors) { let t = E(i.factor); if (t !== null && Number.isInteger(t)) { let r = E(i.exponent); r !== null && (n = (n ?? 1) * Math.pow(t, r)); continue } } return n } asExpression() { let n = this.engine; if (this.factors.length === 0) return n.One; if (this.hasNaN) return n.NaN; if (this.hasInfinity) return this.sign > 0 ? n.PositiveInfinity : n.NegativeInfinity; if (this.hasZero) return n.Zero; if (this.factors.length === 1) { let { factor: o, exponent: s } = this.factors[0]; return n.pow(o, s) } let i = this.factors.filter(o => o.exponent.isPositive && !o.factor.isOne).map(o => n.pow(o.factor, o.exponent)), t; i.length === 0 ? t = this.sign > 0 ? n.One : n.NegativeOne : i.length === 1 ? this.sign < 0 ? t = n.neg(i[0]) : t = i[0] : (t = n._fn("Multiply", i), this.sign < 0 && (t = n.neg(t))); let r = this.factors.filter(o => o.exponent.isNegative && !o.factor.isOne).map(o => n.pow(o.factor, n.neg(o.exponent))); return r.length === 0 ? t : r.length === 1 ? n.div(t, r[0]) : n.div(t, n._fn("Multiply", r)) } }; var gt = class { constructor(n, i) { this.terms = []; this.engine = n; for (let t of i) this.add(t) } sub(n) { this.add(n, [-1, 1]) } add(n, i) { i ?? (i = [1, 1]); let [t, r] = Je(n); if (t = Q(t, i), Ze(t)) return; if (r.head === "Add") { for (let s of r.ops) this.add(s, t); return } if (r.head === "Negate") { this.add(r.op1, _e(t)); return } let o = this.find(r); if (o >= 0) { this.terms[o].coef = st(this.terms[o].coef, t); return } this.terms.push({ coef: t, term: r }) } find(n) { return this.terms.findIndex(i => i.term.isSame(n)) } reduceNumbers({ exact: n } = { exact: !0 }) { let i = this.engine, t = this.terms; this.terms = []; let r = 0, o = 0, s = 0, a = 0, u = [0, 1], l = i._BIGNUM_ZERO; for (let { coef: f, term: d } of t) { if (d.isNaN) { this.terms = [{ term: i.NaN, coef: [1, 1] }]; return } if (d.isFinite === !1) { d.isPositive ? r++ : o++; continue } if (d.numericValue !== null) { let c = Qa(d.numericValue, f); if (c !== null) { U(c) ? u = st(u, c) : c instanceof Ue ? l = l.add(c) : c instanceof Ka.default ? (F(i) ? l = l.add(c.re) : s += c.re, a += c.im) : F(i) ? l = l.add(c) : s += c; continue } } this.terms.push({ coef: f, term: d }) } if (r > 0 && o > 0) { this.terms = [{ term: i.NaN, coef: [1, 1] }]; return } if (r > 0) { this.terms = [{ term: i.PositiveInfinity, coef: [1, 1] }]; return } if (o > 0) { this.terms = [{ term: i.NegativeInfinity, coef: [1, 1] }]; return } if (!n || !Number.isInteger(s) || !l.isInteger() || !Number.isInteger(a)) { if (!l.isZero() && F(i)) { l = l.add(s), l = l.add(i.bignum(u[0]).div(i.bignum(u[1]))), this.terms.push({ term: i.number(l), coef: [1, 1] }), a !== 0 && this.terms.push({ term: i.number(i.complex(0, a)), coef: [1, 1] }); return } let f = s + l.toNumber() + Number(u[0]) / Number(u[1]); a !== 0 ? this.terms.push({ term: i.number(i.complex(f, a)), coef: [1, 1] }) : f !== 0 && this.terms.push({ term: i.number(f), coef: [1, 1] }); return } l.isZero() || (l = l.add(s), s = 0, Ze(u) || (l = l.add(i.bignum(u[0]).div(i.bignum(u[1]))), u = [0, 1]), this.terms.push({ coef: [1, 1], term: i.number(l) })), a !== 0 ? (Ze(u) || (s += Number(u[0]) / Number(u[1])), this.terms.push({ coef: [1, 1], term: i.number(i.complex(s, a)) })) : s !== 0 && this.terms.push({ coef: [1, 1], term: i.number(s) }), Ze(u) || this.terms.push({ coef: [1, 1], term: i.number(u) }) } asExpression() { let n = this.engine, i = this.terms.filter(({ coef: t, term: r }) => !Ze(t) && !r.isZero); if (i.length === 0) return n.Zero; if (i.length === 1) { let { coef: t, term: r } = i[0]; return ie(t) ? r : Bi(t) ? n.neg(r) : n.mul(n.number(t), r) } return n.function("Add", i.map(({ coef: t, term: r }) => n.mul(n.number(t), r))) } }; function In(e, n) { if (n.every(i => i.isCanonical), n = n.filter(i => i.numericValue === null || !i.isZero), n.length === 0) return e.Zero; if (n.length === 1 && !sr(n[0])) return n[0]; if (n.length === 2) { let i = 0, t = E(n[0]); if (t !== null && t !== 0 ? i = mr(n[1]) : (i = mr(n[0]), i !== 0 && n[1].numericValue !== null && (t = E(n[1]))), t !== null && i !== null && i !== 0) return e.number(e.complex(t, i)) } return n.length === 1 ? n[0] : e._fn("Add", Ao(n)) } function nu(e, n) { let i = null; for (let t of n) { if (!t?.isNumeric) return null; i = Un(i, t) } return i } function pr(e, n) { let i = new gt(e, []); for (let t of n) { if (t = t.simplify(), t.isImaginary && t.isInfinity) return e.ComplexInfinity; if (t.isNaN || t.symbol === "Undefined") return e.NaN; i.add(t) } return i.reduceNumbers({ exact: !0 }), i.asExpression() } function nd(e) { let n = 0; for (let i of e) { let t = i.numericValue; if (typeof t == "number") n += t; else return null } return n } function xt(e, n, i = "evaluate") { if (i === "N" && e.numericMode === "machine") { n = n.map(o => o.N()); let r = nd(n); if (r !== null) return e.number(r) } for (let r of n) { if (r.isImaginary && r.isInfinity) return e.ComplexInfinity; if (r.isNaN || r.symbol === "Undefined") return e.NaN; r.numericValue !== null && !r.isExact && (i = "N") } i === "N" ? n = n.map(r => r.N()) : n = n.map(r => r.evaluate()); let t = new gt(e, n); return i === "N" ? t.reduceNumbers() : t.reduceNumbers({ exact: !0 }), t.asExpression() } function iu(e, n, i) { e.pushScope(), n ?? (n = e.error("missing")); var t = void 0; if (i && i.ops && i.ops[0]?.head === "Delimiter") { var r = ur(i); if (!r) return null; var o = [n.canonical]; r.forEach(a => { o.push(a) }), t = e._fn("Sum", o) } else { var s = $n(i); t = s ? e._fn("Sum", [n.canonical, s]) : e._fn("Sum", [n.canonical]) } return e.popScope(), t } function hr(e, n, i) { let t = n[0], r = []; if (n) { r = []; for (let m = 1; m < n.length; m++)r.push(n[m]) } let o = null; if (r?.length === 0) { let m = i === "simplify" ? t.simplify() : t.evaluate({ numericMode: i === "N" }); if (F(e)) { let g = e.bignum(0); for (let h of X(m)) { let x = Ge(h); if (x === null) { o = void 0; break } if (x.isFinite() === !1) { g = x; break } g = g.add(x) } o === null && (o = e.number(g)) } else { let g = 0; for (let h of X(m)) { let x = E(h); if (x === null) { o = void 0; break } if (x === null || !Number.isFinite(x)) { g = x; break } g += x } o === null && (o = e.number(g)) } return o ?? void 0 } var s = []; let a = [], u = [], l = []; r.forEach(m => { let [g, h, x, S] = zn(m.evaluate()); g && (s.push(g), a.push(h), u.push(x), l.push(S)) }); let f = t, d = e.swapScope(f.scope); e.pushScope(), f.bind(); for (let m = 0; m < s.length; m++) { let g = s[m], h = a[m], x = u[m], S = l[m]; if (h >= x || i === "simplify" && x - h >= rt) return; if (i === "evaluate" && x - h >= rt && (i = "N"), i === "simplify") { let T = []; for (let _ = h; _ <= x; _++)e.assign(g, _), T.push(f.simplify()); o = e.add(...T).simplify() } } let c = []; if (s.length > 1) for (let m = 0; m < s.length - 1; m++)c.length === 0 ? c = Ci(cn(a[m], u[m]), cn(a[m + 1], u[m + 1])) : c = Ci(c.map(g => g[0]), cn(a[m + 1], u[m + 1])); else c = cn(a[0], u[0]).map(m => [m]); if (i === "evaluate") { let m = []; for (let g of c) { let h = s.map((x, S) => (e.assign(x, g[S]), x)); m.push(f.evaluate()) } o = e.add(...m).evaluate() } for (let m = 0; m < s.length; m++)e.assign(s[m], void 0); if (i === "N") for (let m = 0; m < s.length; m++) { let g = s[m], h = a[m], x = u[m], S = l[m]; if (o === null && S) if (F(e)) { let T = e.bignum(0); for (let _ = h; _ <= x; _++) { e.assign(g, _); let w = Ge(f.N()); if (w === null) { o = void 0; break } if (w.isFinite() === !1) { T = w; break } T = T.add(w) } o === null && (o = e.number(T)) } else { let T = e.numericMode, _ = e.precision; e.numericMode = "machine"; let w = 0; for (let j = h; j <= x; j++) { e.assign(g, j); let Z = E(f.N()); if (Z === null) { o = void 0; break } if (!Number.isFinite(Z)) { w = Z; break } w += Z } e.numericMode = T, e.precision = _, o === null && (o = e.number(w)) } else if (o === null) { e.assign(g, 1e3); let T = f.N(); e.assign(g, 999); let _ = f.N(), w = E(e.div(T, _).N()); if (w !== null && Number.isFinite(w) && Math.abs(w) > 1) o = e.PositiveInfinity; else { let j = 0, Z = e.numericMode, De = e.precision; e.numericMode = "machine"; for (let $e = h; $e <= x; $e++) { e.assign(g, $e); let Ce = E(f.N()); if (Ce === null) { o = void 0; break } if (Math.abs(Ce) < Number.EPSILON || !Number.isFinite(Ce)) break; j += Ce } e.numericMode = Z, e.precision = De, o === null && (o = e.number(j)) } } } return e.popScope(), e.swapScope(d), o ?? void 0 } function mr(e) { if (e.symbol === "ImaginaryUnit") return 1; let n = e.numericValue; if (n !== null && n instanceof eu.default && n.re === 0) return n.im; if (e.head === "Negate") return -mr(e.op1); if (e.head === "Multiply" && e.nops === 2) { if (e.op1.symbol === "ImaginaryUnit") return E(e.op2) ?? 0; if (e.op2.symbol === "ImaginaryUnit") return E(e.op1) ?? 0 } if (e.head === "Divide") { let i = mr(e.op1), t = E(e.op2); return t === null ? 0 : i / t } return 0 } var tu = pe(ce(), 1); function ru(e) { let n = e.numericValue; return n === null ? null : (typeof n == "number" ? n = -n : n instanceof v || n instanceof tu.Complex ? n = n.neg() : Array.isArray(n) && (n = _e(n)), e.engine.number(n)) } function bt(e) { let n = -1; for (; e.head === "Negate";)e = e.op1, n = -n; if (n === 1) return e; if (e.numericValue !== null) return ru(e); let i = e.engine; if (e.head === "Subtract") return i.add(e.op2, bt(e.op1)); if (e.head === "Add") { let t = e.ops.map(r => bt(r)); return i.add(...t) } return e.head === "Multiply" ? id(i, e.ops) : e.head === "Divide" ? i.div(bt(e.op1), e.op2) : i._fn("Negate", [e]) } function ge(e) { let n = -1; for (; e.head === "Negate";)e = e.op1, n = -n; if (n === 1) return e; let i = e.engine; if (e.head === "Add") { let t = e.ops.map(r => ge(r)); return In(i, te(se(t), "Add")) } return e.numericValue !== null ? ru(e) : i._fn("Negate", [e]) } function id(e, n) { let i = [], t = !1; for (let r of n) !t && r.head === "Negate" ? (t = !0, i.push(r.op1)) : i.push(r); if (t) return e.mul(...i); i = []; for (let r of n) t || r.numericValue === null || !r.isInteger ? i.push(r) : (t = !0, i.push(ge(r))); if (t) return e.mul(...i); i = []; for (let r of n) t || r.numericValue === null || !r.isNumber ? i.push(r) : (t = !0, i.push(ge(r))); return t ? e.mul(...i) : e._fn("Negate", [e._fn("Multiply", n)]) } function gr(e, n, i = "simplify") { return ge(n) } function hn(e, n) { if (e.head === "Negate" && n.head === "Negate") return hn(e.op1, n.op1); if (e.head === "Negate") return ge(hn(e.op1, n)); if (n.head === "Negate") return ge(hn(e, n.op1)); let i = e.engine; if (e.head === "Divide" && n.head === "Divide") { let t = i.mul(e.op2, n.op2); return i.div(hn(e.op1, n.op1), t) } return e.head === "Divide" ? i.div(hn(e.op1, n), e.op2) : n.head === "Divide" ? i.div(hn(e, n.op1), n.op2) : e.head === "Add" ? i.add(...e.ops.map(t => hn(t, n))) : n.head === "Add" ? i.add(...n.ops.map(t => hn(e, t))) : i.mul(e, n) } function Pi(e) { return e.length === 1 ? e[0] : e.length === 2 ? hn(e[0], e[1]) : hn(e[0], Pi(e.slice(1))) } var yt = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1]]; function td(e, n) { for (; e >= yt.length;) { let i = yt.length, t = [1], r = yt[i - 1]; for (let o = 1; o < i; o++)t[o] = r[o - 1] + r[o]; t[i] = 1, yt.push(t) } return yt[e][n] } function rd(e) { let n = e.reduce((t, r) => t + r, 0), i = 1; for (let t = 0; t < e.length; t += 1)i *= td(n, e[t]), n -= e[t]; return i } function* ou(e, n) { if (e === 1) { yield [n]; return } for (let i = 0; i <= n; i += 1)for (let t of ou(e - 1, n - i)) yield [i, ...t] } function su(e) { if (e.head !== "Power") return null; let n = q(e.op2); if (n === null || n < 0) return null; if (n === 0) return e.engine.One; if (n === 1) return rn(e.op1); let i = e.engine; if (e.op1.head === "Negate") { let s = n % 2 === 0 ? 1 : -1, a = su(i._fn("Power", [e.op1.op1, e.op2])); return a === null ? null : s > 0 ? a : i.neg(a) } if (e.op1.head, e.op1.head !== "Add") return null; let t = e.op1.ops, r = ou(t.length, n), o = []; for (let s of r) { let a = [i.number(rd(s))]; for (let u = 0; u < s.length; u += 1)s[u] !== 0 && (s[u] === 1 ? a.push(t[u]) : a.push(i.pow(t[u], s[u]))); o.push(i.mul(...a)) } return i.add(...o) } function Po(e) { if (e.head && e.ops) { let n = e.ops.map(t => Po(t) ?? t), i = e.engine.box([e.head, ...n]); return rn(i) ?? i } return null } function od(e) { if (e.head !== "Divide") return null; let n = rn(e.op1); if (n === null) return null; let i = e.engine; return n.head === "Add" ? i.add(...n.ops.map(t => i.div(t, e.op2))) : e.engine.div(n, e.op2) } function rn(e) { if (!e) return null; let n = od(e); if (n !== null || e.head === "Multiply" && (n = Pi(e.ops), n !== null)) return n; if (e.head === "Add") { let i = e.ops.map(t => rn(t) ?? t); return pr(e.engine, i) } return e.head === "Negate" && (n = rn(e.op1), n !== null) ? e.engine.neg(n) : e.head === "Power" && (n = su(e), n !== null) ? n : null } var sd = [{ match: ["Multiply", "_x", "__a"], replace: 0, id: "ax", condition: ({ __a: e }) => !e.has("_x") }, { match: ["Add", ["Divide", "_a", "_x"], "__b"], replace: 1 / 0, condition: ({ _a: e, __b: n }) => !e.has("_x") && !n.has("_x") }, { match: ["Add", ["Multiply", "_x", "__a"], "__b"], replace: ["Divide", ["Negate", "__b"], "__a"], condition: ({ __a: e, __b: n }) => !e.has("_x") && !n.has("_x") }, { match: ["Add", ["Multiply", "_a", ["Power", "_x", "_n"]], "__b"], replace: ["Divide", ["Power", ["Negate", "__b"], ["Divide", 1, "_n"]], "_a"], condition: ({ _a: e, __b: n, _n: i }) => !e.has("_x") && !n.has("_x") && !i.isZero }, { match: ["Add", ["Multiply", "__a", ["Power", "_x", 2]], ["Multiply", "__b", "_x"], "__c"], replace: ["Divide", ["Add", ["Negate", "__b"], ["Sqrt", ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "__c"]]]], ["Multiply", 2, "__a"]], condition: ({ __a: e, __b: n, __c: i }) => !e.has("_x") && !n.has("_x") && !i.has("_x") }, { match: ["Add", ["Multiply", "__a", ["Power", "_x", 2]], ["Multiply", "__b", "_x"], "__c"], replace: ["Divide", ["Subtract", ["Negate", "__b"], ["Sqrt", ["Subtract", ["Square", "__b"], ["Multiply", 4, "__a", "__c"]]]], ["Multiply", 2, "__a"]], condition: ({ __a: e, __b: n, __c: i }) => !e.has("_x") && !n.has("_x") && !i.has("_x") }, { match: ["Add", ["Multiply", "__a", ["Exp", ["Multiply", "__b", "_x"]]], "__c"], replace: ["Divide", ["Ln", ["Negate", ["Divide", "__c", "__a"]]], "__b"], condition: ({ __a: e, __c: n }, i) => ((!e.isZero && i.div(n, e).isNegative) ?? !1) && !e.has("_x") && !n.has("_x") }, { match: ["Add", ["Multiply", "__a", ["Exp", "_x"]], "__c"], replace: ["Ln", ["Negate", ["Divide", "__c", "__a"]]], condition: ({ __a: e, __c: n }, i) => ((!e.isZero && i.div(n, e).isNegative) ?? !1) && !e.has("_x") && !n.has("_x") }]; function xr(e, n) { let i = e.engine; e.head === "Equal" && (e = i.add(e.op1.canonical, i.neg(e.op2.canonical)).simplify()); let t = i.cache("univariate-roots-rules", () => ti(i, sd)), r = [e.subs({ [n]: "_x" }, { canonical: !1 })], o = r.flatMap(s => ft(s, t, { _x: i.symbol("_x") })); return o.length === 0 && (r = r.flatMap(s => au(s)), o = r.flatMap(s => ft(s, t, { _x: i.symbol(n) }))), o.length === 0 && (r = r.flatMap(s => rn(s.canonical)).filter(s => s !== null), r = r.flatMap(s => au(s)), o = r.flatMap(s => ft(s, t, { _x: i.symbol(n) }))), o.map(s => s.evaluate().simplify()) } var ad = [{ match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"], replace: ["Add", ["Multiply", "__a", "_x"], "__b", "__c"] }, { match: ["Add", ["Abs", ["Add", ["Multiply", "__a", "_x"], "__b"]], "__c"], replace: ["Add", ["Negate", ["Multiply", "__a", "_x"]], ["Negate", "__b"], "__c"] }, { match: ["Multiply", "__a", ["Power", "_b", "_n"]], replace: "_b", condition: ({ __a: e, _b: n, _n: i }) => !e.has("_x") && n.has("_x") && !i.isZero && !i.has("_x") }, { match: ["Multiply", "__a", ["Sqrt", "_b"]], replace: ["Multiply", ["Square", "_a"], "__b"], condition: ({ _b: e }) => e.has("_x") }, { match: ["Divide", "_a", "_b"], replace: "_a", condition: ({ _a: e, _b: n }) => e.has("_x") && !n.isZero }, { match: ["Multiply", "__a", "_b"], replace: "_b", condition: ({ __a: e, _b: n }) => !e.has("_x") && n.has("_x") }, { match: ["Add", ["Ln", "_a"], ["Ln", "_b"], "__c"], replace: ["Add", ["Ln", ["Multiply", "_a", "_b"]], "__c"] }, { match: ["Multiply", ["Exp", "__a"], ["Exp", "__b"], "__c"], replace: ["Multiply", ["Exp", ["Add", "_a", "_b"]], "__c"] }, { match: ["Ln", "_a"], replace: ["Subtract", "_a", 1], condition: ({ _a: e }) => e.has("_x") }, { match: ["Sin", "_a"], replace: "_a", condition: ({ _a: e }) => e.has("_x") }, { match: ["Cos", "_a"], replace: ["Subtract", "_a", ["Divide", "Pi", 2]], condition: ({ _a: e }) => e.has("_x") }, { match: ["Tan", "_a"], replace: "_a", condition: ({ _a: e }) => e.has("_x") }, { match: ["Add", ["Sin", "_a"], ["Cos", "_a"]], replace: 1, condition: ({ _a: e }) => e.has("_x") }, { match: ["Subtract", ["Square", ["Sin", "_a"]], ["Square", ["Cos", "_a"]]], replace: ["PlusMinus", ["Sin", "_a"], ["Divide", ["Sqrt", 2], 2]], condition: ({ _a: e }) => e.has("_x") }]; function au(e) { let n = e.engine, i = n.cache("univariate-roots-rules", () => ti(n, ad)); return ft(e, i, { _x: n.symbol("_x") }) } function uu(e) { return e.head === "Element" ? fd(e) : e.head === "Equal" ? ud(e) : md(e) ? ld(e) : "not-a-predicate" } function ud(e) { e.head; let n = e.unknowns; if (n.length === 0) { let r = e.evaluate(); return r.symbol === "True" ? "tautology" : r.symbol === "False" ? "contradiction" : (e.canonical.evaluate(), "not-a-predicate") } let i = e.engine, t = e.op1.symbol; if (t && !cd(i, t) && !e.op2.has(t)) { let r = e.op2.evaluate(); if (!r.isValid) return "not-a-predicate"; let o = i.lookupSymbol(t); return o ? o.domain && !r.domain?.isCompatible(o.domain) ? "contradiction" : (o.value = r, "ok") : (i.defineSymbol(t, { value: r, domain: r.domain }), "ok") } if (n.length === 1) { let r = n[0], o = xr(e, r); o.length === 0 && i.assumptions.set(i.box(["Equal", i.add(e.op1.canonical, i.neg(e.op2.canonical)).simplify(), 0]), !0); let s = o.length === 1 ? o[0] : i.box(["List", ...o]), a = i.lookupSymbol(r); return a ? a.domain && !o.every(u => !u.domain || s.domain?.isCompatible(u.domain)) ? "contradiction" : (a.value = s, "ok") : (i.defineSymbol(r, { value: s, domain: s.domain }), "ok") } return i.assumptions.set(e, !0), "ok" } function ld(e) { let n = e.engine; if (e.op1.symbol && !Fo(n, e.op1.symbol)) return e.op2.evaluate().isZero ? e.head === "Less" ? n.defineSymbol(e.op1.symbol, { domain: n.domain("NegativeNumbers") }) : e.head === "LessEqual" ? n.defineSymbol(e.op1.symbol, { domain: n.domain("NonPositiveNumbers") }) : e.head === "Greater" ? n.defineSymbol(e.op1.symbol, { domain: n.domain("PositiveNumbers") }) : e.head === "GreaterEqual" && n.defineSymbol(e.op1.symbol, { domain: n.domain("NonNegativeNumbers") }) : (n.defineSymbol(e.op1.symbol, { domain: n.domain("ExtendedRealNumbers") }), n.assumptions.set(e, !0)), "ok"; let i = "", t, r; if (e.head === "Less" ? (t = e.op1, r = e.op2, i = "<") : e.head === "LessEqual" ? (t = e.op1, r = e.op2, i = "<=") : e.head === "Greater" ? (t = e.op2, r = e.op1, i = "<") : e.head === "GreaterEqual" && (t = e.op2, r = e.op1, i = "<="), !i) return "internal-error"; let o = n.add(t.canonical, n.neg(r.canonical)).simplify(), s = n.box([i === "<" ? "Less" : "LessEqual", o, 0]).evaluate(); if (s.symbol === "True") return "tautology"; if (s.symbol === "False") return "contradiction"; let a = s.unknowns; return a.length === 0 ? "not-a-predicate" : (a.length === 1 && (n.lookupSymbol(a[0]) || n.defineSymbol(a[0], { domain: "ExtendedRealNumbers" })), s.head === "Less" || s.head, n.assumptions.set(s, !0), "ok") } function fd(e) { e.head; let n = e.engine, i = dd(e.op1); if (i.length === 1) { let r = n.domain(e.op2.evaluate().json); return r.isValid ? (n.declare(i[0], r), "ok") : "not-a-predicate" } if (e.op1.symbol && Fo(n, e.op1.symbol)) { let r = n.domain(e.op2.evaluate().json); if (!r.isValid) return "not-a-predicate"; n.context?.ids?.has(e.op1.symbol) || n.declare(e.op1.symbol, r); let o = n.lookupSymbol(e.op1.symbol); if (o) return o.domain && !r.isCompatible(o.domain) ? "contradiction" : (o.domain = r, "ok"); let s = n.lookupFunction(e.op1.symbol); return s ? r.isCompatible(tr(n, s.signature)) ? "ok" : "contradiction" : "not-a-predicate" } if (i.length > 0) return n.assumptions.set(e, !0), "ok"; let t = e.evaluate(); return t.symbol === "True" ? "tautology" : t.symbol === "False" ? "contradiction" : "not-a-predicate" } function Fo(e, n) { return (e.lookupSymbol(n) ?? e.lookupFunction(n)) !== void 0 } function dd(e) { return e.symbols.filter(n => !Fo(e.engine, n)) } function cd(e, n) { return e.lookupFunction(n) ? !1 : e.lookupSymbol(n)?.value !== void 0 } function md(e) { let n = e.head; return typeof n != "string" ? !1 : ["Less", "Greater", "LessEqual", "GreaterEqual"].includes(n) } var Dr = pe(ce(), 1); var Go = pe(ce(), 1); function Ro(e, n) { for (e.isInteger() && n.isInteger(); !n.isZero();) [e, n] = [n, e.modulo(n)]; return e.abs() } function fu(e, n) { return e.mul(n).div(Ro(e, n)) } function Lo(e, n) { if (!n.isInteger() || n.isNegative()) return e._BIGNUM_NAN; if (n.lessThan(10)) return e.bignum([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800][n.toNumber()]); if (n.gt(Number.MAX_SAFE_INTEGER)) { let o = e._BIGNUM_ONE, s = e._BIGNUM_TWO; for (; s.lessThan(n);)o = o.mul(s), s = s.add(1); return o } if (n.modulo(2).eq(1)) return n.times(Lo(e, n.minus(1))); let i = n.toNumber(), t = n, r = n; for (; i > 2;)i -= 2, t = t.add(i), r = r.mul(t); return r } function du(e, n) { if (!n.isInteger() || n.isNegative()) return e._BIGNUM_NAN; if (n.lessThan(1)) return e._BIGNUM_ONE; let i = n; for (; n.greaterThan(2);)n = n.minus(2), i = i.mul(n); return i } var lu = 7; function qo(e, n) { if (n.isNegative()) return e._BIGNUM_NAN; let i = e.cache("gamma-p-ln", () => ["0.99999999999999709182", "57.156235665862923517", "-59.597960355475491248", "14.136097974741747174", "-0.49191381609762019978", "0.33994649984811888699e-4", "0.46523628927048575665e-4", "-0.98374475304879564677e-4", "0.15808870322491248884e-3", "-0.21026444172410488319e-3", "0.2174396181152126432e-3", "-0.16431810653676389022e-3", "0.84418223983852743293e-4", "-0.2619083840158140867e-4", "0.36899182659531622704e-5"].map(s => e.bignum(s))), t = i[0]; for (let s = i.length - 1; s > 0; --s)t = t.add(i[s].div(n.add(s))); let r = e.cache("gamma-g-ln", () => e.bignum(607).div(128)), o = n.add(r).add(e._BIGNUM_HALF); return e._BIGNUM_NEGATIVE_ONE.acos().mul(e._BIGNUM_TWO).log().mul(e._BIGNUM_HALF).add(o.log().mul(n.add(e._BIGNUM_HALF)).minus(o).add(t.log()).minus(n.log())) } function Vo(e, n) { if (n.lessThan(e._BIGNUM_HALF)) { let o = e._BIGNUM_NEGATIVE_ONE.acos(); return o.div(o.mul(n).sin().mul(Vo(e, e._BIGNUM_ONE.sub(n)))) } if (n.greaterThan(100)) return qo(e, n).exp(); n = n.sub(1); let i = e.cache("lanczos-7-c", () => ["0.99999999999980993227684700473478", "676.520368121885098567009190444019", "-1259.13921672240287047156078755283", "771.3234287776530788486528258894", "-176.61502916214059906584551354", "12.507343278686904814458936853", "-0.13857109526572011689554707", "9.984369578019570859563e-6", "1.50563273514931155834e-7"].map(o => e.bignum(o))), t = i[0]; for (let o = 1; o < lu + 2; o++)t = t.add(i[o].div(n.add(o))); let r = n.add(lu).add(e._BIGNUM_HALF); return e._BIGNUM_NEGATIVE_ONE.acos().times(e._BIGNUM_TWO).sqrt().mul(t.mul(r.neg().exp()).mul(r.pow(n.add(e._BIGNUM_HALF)))) } function br(e) { return e.isFinite() ? e.d.length > 3 || e.d.length === 3 && e.d[0] >= 90 ? !1 : (e.precision() <= 16, e.e < 308 && e.e > -306) : !0 } var Uo = pe(ce(), 1); var Fi = pe(ce(), 1); function kn(e, n, i, t) { if (i.symbol === "ComplexInfinity") return e.NaN; if (i.isZero) return e.One; if (i.isOne) return n; if (i.isNegativeOne) return e.inv(n); if (i.numericValue !== null && n.numericValue !== null) { if (n.isOne) return e.One; if (n.isZero) { if (i.isPositive) return e.Zero; if (i.isNegative) return e.ComplexInfinity } if (i.isNegativeOne) return e.inv(n); let r = E(i); if (r === .5 || r === -.5) { if (W(n)) { let s = e._fn("Sqrt", [n], t); return r > 0 ? s : e._fn("Divide", [e.One, s], t) } return e._fn("Power", [n, i], t) } if (n.isInfinity) { if (i.numericValue instanceof Fi.Complex) { let o = i.numericValue.re; if (o === 0) return e.NaN; if (o < 0) return e.Zero; if (o > 0) return e.ComplexInfinity } if (n.isNegative) { if (i.isInfinity) return e.NaN } else if (n.isPositive) { if (i.isNegativeOne) return e.Zero; if (i.isInfinity) return i.isNegative ? e.Zero : e.PositiveInfinity } } if (i.isInfinity && (n.isOne || n.isNegativeOne)) return e.NaN } if (n.head === "Power" && n.op1.isReal) { let r = q(i); if (r !== null) { let o = q(n.op2); if (o !== null) return e.pow(n.op1, e.number(r * o)) } if (n.op1.isNonNegative) { let o = W(i); if (o) { let s = W(n.op2); if (s) return e.pow(n.op1, e.number(Q(o, s))) } } } return e._fn("Power", [n, i], t) } function cu(e, n, i) { if (n.numericValue === null || i.numericValue === null) return; if (n.numericValue instanceof Fi.Complex) return i.numericValue instanceof Fi.Complex ? e.number(n.numericValue.pow(i.numericValue)) : e.number(n.numericValue.pow(E(i) ?? NaN)); if (i.numericValue instanceof Fi.Complex) { let s = E(n) ?? null; return s !== null ? e.number(e.complex(s).pow(i.numericValue)) : void 0 } let t = pd(i); if (F(e) || n.numericValue instanceof v || i.numericValue instanceof v) { let s = Ge(n), a = Ge(i); if (!s || !a) return; if (t === 2) return s.isNeg() ? ae(e) ? e.number(e.complex(0, s.neg().sqrt().toNumber())) : e.NaN : e.number(s.sqrt()); if (!a.isInteger() && s.isNeg()) { if (!ae(e)) return e.NaN; let u = e.complex(s.toNumber()), l = e.complex(a.toNumber()); return e.number(u.pow(l)) } return e.number(s.pow(a)) } let r = E(i) ?? NaN, o = E(n) ?? NaN; if (t === 2) return o < 0 ? ae(e) ? e.mul(e.I, e.number(Math.sqrt(-o))) : e.NaN : e.number(Math.sqrt(o)); if (!Number.isInteger(r) && o < 0) { if (!ae(e)) return e.NaN; let s = e.complex(o), a = e.complex(r); return e.number(s.pow(a)) } return e.number(Math.pow(o, r)) } function si(e, n, i, t) { if (t !== "simplify" && n.symbol === "ExponentialE" && i instanceof Fi.Complex) { let r = i.im, o = i.re, s; if (o === 0) s = this.number(this.complex(Math.cos(r), Math.sin(r))); else { if (r === 0) return this.number(Math.exp(o)); { let a = Math.exp(o); s = this.number(this.complex(a * Math.cos(r), a * Math.sin(r))) } } return t === "N" ? s.N() : s } if (n.head === "Multiply") { let r = F(e) ? [BigInt(1), BigInt(1)] : [1, 1], o = r, s = []; for (let a of n.ops) { let u = W(a); if (u) r = Q(r, u); else { let l = $o(a); l ? o = Q(o, l) : s.push(a) } } if (!ie(r) || !ie(o)) { let a = si(e, e.number(r), i, t), u = si(e, e.number(o), e.div(i, e.number(2)), t), l = e.mul(...s), f = si(e, l, i, t) ?? e._fn("Power", [l, i]); if (a && u && f) return e.mul(a, u, f) } } if (n.head === "Power") { if (q(n.op2) === -1 && q(i) === -1) return n.op1; let r = W(n.op2), o = W(i); if (r && o) { let s = Q(r, o); return e.pow(n.op1, s) } if (t === "N") { let s = E(n.op2), a = E(i); if (s !== null && a !== null) { let u = s * a; return u === 0 ? e.One : u === 1 ? n.op1 : e.pow(n.op1, u) } } } if (t !== "N" && n.numericValue !== null && n.isInteger) { if (n.isOne) return e.One; if (q(i)) return cu(e, n, i); let o = W(i); if (o) { let [s, a] = [Oe(o), dn(o)]; if ((s === 1 || s === -1) && (a === 2 || a === 3)) { if (F(e) || n.numericValue instanceof v) { let u = lt(n); if (a % 2 === 0 && u < 0 && !ae(e)) return e.NaN; let l = u < 0 ? a % 2 === 0 ? e.I : e.NegativeOne : e.One, [f, d] = ii(u > 0 ? u : -u, a); if (d === BigInt(1) && f === BigInt(1)) return l; if (f !== BigInt(1)) return d === BigInt(1) ? e.mul(l, e.number(s >= 0 ? f : [BigInt(1), f])) : e.mul(l, e.number(f), e.pow(e.number(d), i)) } else if (typeof n.numericValue == "number") { if (n.numericValue < 0 && a % 2 === 0 && !ae(e)) return e.NaN; let [u, l] = Ln(Math.abs(n.numericValue), a), f = n.numericValue < 0 ? a % 2 === 0 ? e.I : e.NegativeOne : e.One; if (l === 1 && u === 1) return f; if (u !== 1) return l === 1 ? e.mul(f, e.number(s >= 0 ? u : [1, u])) : e.mul(f, e.number(u), e.pow(e.number(l), i)) } } return n.isNegative ? ae ? e.mul(e.I, e.box(["Sqrt", e.neg(n)])) : e.NaN : void 0 } } if (t !== "N" && U(n.numericValue)) { let [r, o] = n.numericValue; return e.div(e.pow(e.number(r), i), e.pow(e.number(o), i)) } if (t !== "simplify" && n.numericValue !== null && i.numericValue !== null) return cu(e, n, i) } function Ri(e, n, i) { if (n.isOne) return e.One; if (n.isZero) return e.Zero; if (n.isNegativeOne) return ae(e) ? e.I : e.NaN; if (n.isNegative && !ae(e)) return e.NaN; let t = W(n); if (i === "N" || i === "evaluate" && !t) return R(n, o => o < 0 ? e.complex(o).sqrt() : Math.sqrt(o), o => o.isNeg() ? e.complex(o.toNumber()).sqrt() : o.sqrt(), o => o.sqrt()); let r = q(n); if (r !== null) { let [o, s] = Ln(Math.abs(r), 2); return o === 1 ? e._fn("Sqrt", [n]) : r < 0 ? s === 1 ? e.number(e.complex(0, o)) : e.mul(e.number(e.complex(0, o)), e.sqrt(e.number(s))) : s === 1 ? e.number(o) : e.mul(e.number(o), e.sqrt(e.number(s))) } if (t) { if (J(t) && !F(e)) { let [o, s] = t; if (Math.abs(o) < Number.MAX_SAFE_INTEGER && s < Number.MAX_SAFE_INTEGER) { let [a, u] = Ln(Math.abs(o), 2), [l, f] = Ln(s, 2); if (o < 0) return e.mul(e.number([a, l]), e.sqrt(e.number([u, f])), e.I); let d = e.number([a, l]); return d.isOne ? e._fn("Sqrt", [e.number([u, f])]) : e.mul(d, e.sqrt(e.number([u, f]))) } } if (K(t) || F(e)) { let o = P(t[0]), [s, a] = ii(o > 0 ? o : -o, 2), [u, l] = ii(P(t[1]), 2); if (o < 0) return e.mul(e.number([s, u]), e.sqrt(e.number([a, l])), e.I); let f = e.number([s, u]); return f.isOne ? e._fn("Sqrt", [e.number([a, l])]) : e.mul(f, e.sqrt(e.number([a, l]))) } } } function pd(e) { if (typeof e.numericValue == "number") { let t = 1 / e.numericValue; return Number.isInteger(t) ? t : null } if (e.numericValue instanceof v) { let t = e.engine._BIGNUM_ONE.div(e.numericValue); return t.isInt() ? t.toNumber() : null } if (!U(e.numericValue)) return null; let [n, i] = [Oe(e.numericValue), dn(e.numericValue)]; return n !== 1 && n !== -1 ? null : n * i } function Li(e) { return e.head === "Sqrt" || e.head === "Power" && E(e.op2) === .5 } function $o(e) { return Li(e) ? W(e.op1) ?? null : null } var wn = class { constructor(n, i, t) { this.options = t; this._terms = []; this._hasInfinity = !1; this._hasZero = !1; this._isCanonical = !0; if (t = t ? { ...t } : {}, "canonical" in t || (t.canonical = !0), this._isCanonical = t.canonical, this.engine = n, this._sign = 1, this._rational = F(n) ? [BigInt(1), BigInt(1)] : [1, 1], this._rationalSqrt = this._rational, this._complex = Uo.Complex.ONE, this._bignum = n._BIGNUM_ONE, this._number = 1, i) for (let r of i) this.addTerm(r) } get isEmpty() { return this._isCanonical ? this._terms.length === 0 && this._hasInfinity === !1 && this._hasZero === !1 && this._sign === 1 && this._number === 1 && this._complex.re === 1 && this._complex.im === 0 && this._bignum.eq(this.engine._BIGNUM_ONE) && ie(this._rational) && ie(this._rationalSqrt) : this._terms.length === 0 } addTerm(n) { if (n.isCanonical, n.head === "Multiply") { for (let o of n.ops) this.addTerm(o); return } if (this._isCanonical) { if (n.isNothing) return; if (n.numericValue !== null) { if (n.isOne) return; if (n.isZero) { this._hasZero = !0; return } if (n.isNegativeOne) { this._sign *= -1; return } if (n.isInfinity) { this._hasInfinity = !0, n.isNegative && (this._sign *= -1); return } let s = n.numericValue; if (typeof s == "number") { s < 0 && (this._sign *= -1, s = -s), Number.isInteger(s) ? this._rational = Q(this._rational, [s, 1]) : F(this.engine) ? this._bignum = this._bignum.mul(s) : this._number *= s; return } if (s instanceof v) { s.isNegative() && (this._sign *= -1, s = s.neg()), s.isInteger() ? this._rational = Q(this._rational, [P(s), BigInt(1)]) : F(this.engine) ? this._bignum = this._bignum.mul(s) : this._number *= s.toNumber(); return } if (s instanceof Uo.Complex) { this._complex = this._complex.mul(s); return } if (U(s)) { this._rational = Q(this._rational, s), Bo(this._rational) && (this._sign *= -1, this._rational = _e(this._rational)); return } } let o = $o(n); if (o) { this._rationalSqrt = Q(this._rationalSqrt, o); return } } let i = n; if (this._isCanonical) { let o;[o, i] = Je(n), this._rational = Q(this._rational, o), Bo(this._rational) && (this._sign *= -1, this._rational = _e(this._rational)) } if (i.numericValue !== null && i.isOne) return; let t = [1, 1]; if (i.head === "Power") { let o = W(i.op2); o && (t = o, i = i.op1) } else i.head === "Divide" && (this.addTerm(i.op1), t = [-1, 1], i = i.op2); let r = !1; for (let o of this._terms) if (o.term.isSame(i)) { o.exponent = st(o.exponent, t), r = !0; break } r || this._terms.push({ term: i, exponent: t }) } unitTerms(n) { let i = this.engine; if (n === "numeric") { if (!ae(i) && this._complex.im !== 0) return null; if (F(i)) { let u = i._BIGNUM_ONE; if (ie(this._rational) || (K(this._rational) ? u = i.bignum(this._rational[0].toString()).div(i.bignum(this._rational[1].toString())) : u = i.bignum(this._rational[0]).div(this._rational[1])), u = u.mul(this._bignum).mul(this._sign * this._number), this._complex.im !== 0) { let l = this._complex.mul(u.toNumber()); return l.equals(1) ? [] : [{ exponent: [1, 1], terms: [i.number(l)] }] } return u = u.mul(this._complex.re), u.equals(1) ? [] : [{ exponent: [1, 1], terms: [i.number(u)] }] } let a = 1; if (ie(this._rational) || (K(this._rational) ? a = Number(this._rational[0]) / Number(this._rational[1]) : a = this._rational[0] / this._rational[1]), a *= this._sign * this._number * this._bignum.toNumber(), this._complex.im !== 0) { let u = this._complex.mul(a); return u.equals(1) ? [] : [{ exponent: [1, 1], terms: [i.number(u)] }] } return a *= this._complex.re, a === 1 ? [] : [{ exponent: [1, 1], terms: [i.number(a)] }] } let t = [], r = []; if (this._hasInfinity && r.push(i.PositiveInfinity), this._rationalSqrt = je(this._rationalSqrt), !ie(this._rationalSqrt)) { let [a, u] = this._rationalSqrt, l = i.sqrt(i.number(a)), f = i.sqrt(i.number(u)); if (f.isOne) { let d = W(l); d ? this._rational = Q(this._rational, d) : r.push(l) } else l.isInteger && f.isInteger ? (this._rational = Q(Q(this._rational, l), i.inv(f)), r.push(i._fn("Sqrt", [i.div(l.op1, f.op1)]))) : Li(l) && Li(f) ? r.push(i._fn("Sqrt", [i.div(l.op1, f.op1)])) : r.push(i._fn("Divide", [l, f])) } (this._complex.re !== 1 || this._complex.im !== 0) && (this._complex.im === 0 ? this._number *= Math.abs(this._complex.re) : r.push(i.number(this._complex))); let o = this._sign * this._number, s = this._bignum; return this._rational = je(this._rational), ie(this._rational) || (n === "rational" ? (Oe(this._rational) !== 1 && (K(this._rational) ? s = s.mul(i.bignum(this._rational[0])) : o *= this._rational[0]), dn(this._rational) !== 1 && t.push({ exponent: [-1, 1], terms: [i.number(this._rational[1])] })) : o === -1 ? (r.push(i.number(_e(this._rational))), o = 1) : r.push(i.number(this._rational))), s.equals(i._BIGNUM_ONE) ? o !== 1 && r.push(i.number(o)) : r.push(i.number(s.mul(o))), r.length > 0 && t.push({ exponent: [1, 1], terms: r }), t } groupedByDegrees(n) { n ?? (n = {}), "mode" in n || (n.mode = "expression"); let i = this.engine; if (n.mode === "numeric") { if (this._complex.im !== 0 && !ae(i)) return null; if (this._hasInfinity) return [{ exponent: [1, 1], terms: [i.PositiveInfinity] }] } let t = this.unitTerms(n.mode ?? "expression"); if (t === null) return null; for (let r of this._terms) { let o = je(r.exponent); if (o[0] === 0) continue; let s = !1; for (let a of t) if (o[0] === a.exponent[0] && o[1] === a.exponent[1]) { a.terms.push(r.term), s = !0; break } s || t.push({ exponent: o, terms: [r.term] }) } return t } asExpression(n = "evaluate") { let i = this.engine; if (this._hasInfinity) { if (this._hasZero) return i.NaN; if (this._terms.length === 0) return Oe(this._rational) > 0 ? i.PositiveInfinity : i.NegativeInfinity } if (this._hasZero) return i.Zero; let t = this.groupedByDegrees({ mode: n === "N" ? "numeric" : "expression" }); if (t === null) return i.NaN; let r = zo(i, t); return r.length === 0 ? i.One : r.length === 1 ? r[0] : this.engine._fn("Multiply", r) } asNumeratorDenominator() { if (this._hasZero) return [this.engine.Zero, this.engine.One]; if (this._hasInfinity) return [this.engine.NaN, this.engine.NaN]; let n = this.groupedByDegrees({ mode: "rational" }); if (n === null) return [this.engine.NaN, this.engine.NaN]; let i = [], t = []; for (let l of n) l.exponent[0] >= 0 ? i.push(l) : t.push({ exponent: _e(l.exponent), terms: l.terms }); let r = this.engine, o = zo(r, i), s = r.One; o.length === 1 ? s = o[0] : o.length > 0 && (s = r._fn("Multiply", o)); let a = zo(r, t), u = r.One; return a.length === 1 ? u = a[0] : a.length > 0 && (u = r._fn("Multiply", a)), [s, u] } asRationalExpression() { let [n, i] = this.asNumeratorDenominator(); if (i.numericValue !== null) { if (i.isOne) return n; if (i.isNegativeOne) return this.engine.neg(n) } return this.engine._fn("Divide", [n, i]) } }; function mu(e) { if (ie(e)) return 0; let [n, i] = [Oe(e), dn(e)]; return n > 0 && Number.isInteger(n / i) ? 1 : n > 0 ? 2 : Number.isInteger(n / i) ? 3 : 4 } function hd(e, n) { let i = mu(e.exponent), t = mu(n.exponent); if (i !== t) return i - t; let [r, o] = [Oe(e.exponent), dn(e.exponent)], [s, a] = [Oe(n.exponent), dn(n.exponent)]; return r / o - s / a } function zo(e, n) { let i = n.sort(hd).map(t => { let r = te(t.terms, "Multiply"), o = r.length <= 1 ? r[0] : e._fn("Multiply", r.sort(tn)); return e.pow(o, t.exponent) }); return te(i, "Multiply") ?? i } function pu(e, n, i, t) { if (n.numericValue !== null) { if (U(n.numericValue)) return Oe(n.numericValue) < 0 ? O(e, "Subtract", [i, e.number(_e(n.numericValue))], t) : null; let r = q(n); if (r !== null && r < 0) return O(e, "Subtract", [i, e.number(-r)], t) } return n.head === "Negate" ? O(e, "Subtract", [i, n.op1], t) : null } function gu(e, n, i, t) { let r = e.jsonSerializationOptions.exclude; if (n === "Add" && i.length === 2 && !r.includes("Subtract")) { let o = pu(e, i[0], i[1], t) ?? pu(e, i[1], i[0], t); if (o) return o } if (n === "Divide" && i.length === 2 && r.includes("Divide")) return O(e, "Multiply", [i[0], e._fn("Power", [i[1], e.NegativeOne])], t); if (n === "Multiply" && !r.includes("Negate") && E(i[0]) === -1) return i.length === 2 ? O(e, "Negate", [i[1]]) : O(e, "Negate", [e._fn("Multiply", i.slice(1))], t); if (n === "Multiply" && !r.includes("Divide")) { let o = new wn(e, i, { canonical: !1 }).asRationalExpression(); if (o.head === "Divide") return O(e, o.head, o.ops, t) } if (n === "Power") { if (!r.includes("Exp") && i[0]?.symbol === "ExponentialE") return O(e, "Exp", [i[1]], t); if (i[1]?.numericValue !== null) { let o = q(i[1]); if (o === 2 && !r.includes("Square")) return O(e, "Square", [i[0]], t); if (o !== null && o < 0 && !r.includes("Divide")) return O(e, "Divide", [e.One, o === -1 ? i[0] : e.pow(i[0], -o)], t); let s = i[1].numericValue; if (!r.includes("Sqrt") && s === .5) return O(e, "Sqrt", [i[0]], t); if (!r.includes("Sqrt") && s === -.5) return O(e, "Divide", [e.One, e._fn("Sqrt", [i[0]])], t); if (U(s)) { let a = Oe(s), u = dn(s); if (a === 1) { if (!r.includes("Sqrt") && u === 2) return O(e, "Sqrt", [i[0]], t); if (!r.includes("Root")) return O(e, "Root", [i[0], e.number(s[1])], t) } if (a === -1) { if (!r.includes("Sqrt") && u === 2) return O(e, "Divide", [e.One, e._fn("Sqrt", [i[0]])], t); if (!r.includes("Root")) return O(e, "Divide", [e.One, e._fn("Root", [i[0], e.number(s[1])])], t) } } } } if (n === "Add" && i.length === 2 && !r.includes("Subtract")) { if (i[1]?.numericValue !== null) { let o = q(i[1]); if (o !== null && o < 0) return O(e, "Subtract", [i[0], e.number(-o)], t) } if (i[1]?.head === "Negate") return O(e, "Subtract", [i[0], i[1].op1], t) } if (n === "Tuple") { if (i.length === 1 && !r.includes("Single")) return O(e, "Single", i, t); if (i.length === 2 && !r.includes("Pair")) return O(e, "Pair", i, t); if (i.length === 3 && !r.includes("Triple")) return O(e, "Triple", i, t) } return O(e, n, i, t) } function O(e, n, i, t) { let r = e.jsonSerializationOptions.exclude; if (n === "Negate" && i.length === 1) { let u = i[0]?.numericValue; if (u !== null) { if (typeof u == "number") return ai(e, -u); if (u instanceof v || u instanceof Go.Complex) return ai(e, u.neg()); if (U(u)) return ai(e, _e(u)) } } if (typeof n == "string" && r.includes(n)) { if (n === "Rational" && i.length === 2) return O(e, "Divide", i, t); if (n === "Complex" && i.length === 2) return O(e, "Add", [i[0], e._fn("Multiply", [i[1] ?? e.symbol("Undefined"), e.I])], t); if (n === "Sqrt" && i.length === 1) return O(e, "Power", [i[0], r.includes("Half") ? e.number([1, 2]) : e.Half], t); if (n === "Root" && i.length === 2 && i[1]?.numericValue !== null) { let u = q(i[1]); if (u === 2) return O(e, "Sqrt", [i[0]]); if (u !== null) return u < 0 ? O(e, "Divide", [e.One, e._fn("Power", [i[0] ?? e.symbol("Undefined"), e.number([1, -u])])], t) : O(e, "Power", [i[0], e.number([1, -u])], t) } if (n === "Square" && i.length === 1) return O(e, "Power", [i[0], e.number(2)], t); if (n === "Exp" && i.length === 1) return O(e, "Power", [e.E, i[0]], t); if (n === "Pair" || n == "Single" || n === "Triple") return O(e, "Tuple", i, t); if (n === "Subtract" && i.length === 2) return O(e, "Add", [i[0], e._fn("Negate", [i[1] ?? e.symbol("Undefined")])], t); if (n === "Subtract" && i.length === 1) return O(e, "Negate", i, t) } let s = [typeof n == "string" ? n : n.json, ...i.map(u => u?.json ?? "Undefined")], a = { ...t ?? {} }; return e.jsonSerializationOptions.metadata.includes("latex") ? a.latex = a.latex ?? e.serialize({ fn: s }) : a.latex = "", e.jsonSerializationOptions.metadata.includes("wikidata") || (a.wikidata = ""), !a.latex && !a.wikidata && e.jsonSerializationOptions.shorthands.includes("function") ? s : a.latex && a.wikidata ? { fn: s, latex: a.latex, wikidata: a.wikidata } : a.latex ? { fn: s, latex: a.latex } : a.wikidata ? { fn: s, wikidata: a.wikidata } : { fn: s } } function xu(e, n) { return n = n, e.jsonSerializationOptions.shorthands.includes("string") ? `'${n}'` : { str: n } } function yr(e, n, i) { if (n === "Half" && e.jsonSerializationOptions.exclude.includes("Half")) return ai(e, [1, 2], i); if (i = { ...i }, e.jsonSerializationOptions.metadata.includes("latex") ? (i.latex = i.latex ?? e.serialize({ sym: n }), i.latex !== void 0 && (i.latex = i.latex)) : i.latex = void 0, e.jsonSerializationOptions.metadata.includes("wikidata")) { if (i.wikidata === void 0) { let t = e.lookupSymbol(n)?.wikidata; t !== void 0 && (i.wikidata = t) } } else i.wikidata = void 0; return n = n, i.latex === void 0 && i.wikidata === void 0 && e.jsonSerializationOptions.shorthands.includes("symbol") ? n : i.latex !== void 0 && i.wikidata !== void 0 ? { sym: n, latex: i.latex, wikidata: i.wikidata } : i.latex !== void 0 ? { sym: n, latex: i.latex } : i.wikidata !== void 0 ? { sym: n, wikidata: i.wikidata } : { sym: n } } function ai(e, n, i) { i = { ...i }, e.jsonSerializationOptions.metadata.includes("latex") || (i.latex = void 0); let t = i.latex === void 0 && i.wikidata === void 0 && !e.jsonSerializationOptions.metadata.includes("latex") && e.jsonSerializationOptions.shorthands.includes("number"), r = e.jsonSerializationOptions.exclude, o = ""; if (n instanceof v) { if (n.isNaN()) o = "NaN"; else if (!n.isFinite()) o = n.isPositive() ? "+Infinity" : "-Infinity"; else { if (t && br(n)) return n.toNumber(); if (n.isInteger() && n.e < n.precision() + 4) o = n.toFixed(0); else { let s = e.jsonSerializationOptions.precision, a = s === "max" ? n.toString() : n.toPrecision(s === "auto" ? e.precision : s); if (o = hu(e, a), t) { let u = n.toNumber(); if (u.toString() === o) return u } } } return e.jsonSerializationOptions.metadata.includes("latex") && (i.latex = i.latex ?? e.serialize({ num: o })), i.latex !== void 0 ? { num: o, latex: i.latex } : t ? o : { num: o } } if (n instanceof Go.Complex) return n.isInfinite() ? yr(e, "ComplexInfinity", i) : n.isNaN() ? (o = "NaN", e.jsonSerializationOptions.metadata.includes("latex") && (i.latex = i.latex ?? e.serialize({ num: o })), i.latex !== void 0 ? { num: o, latex: i.latex } : { num: o }) : O(e, "Complex", [e.number(n.re), e.number(n.im)], { ...i, wikidata: "Q11567" }); if (U(n)) { let s = !r.includes("Rational"); return t && e.jsonSerializationOptions.shorthands.includes("function") && J(n) ? n[0] === 1 && n[1] === 2 && !r.includes("Half") ? yr(e, "Half", i) : [s ? "Rational" : "Divide", n[0], n[1]] : O(e, s ? "Rational" : "Divide", [e.number(n[0]), e.number(n[1])], { ...i }) } if (Number.isNaN(n)) o = "NaN"; else if (!Number.isFinite(n)) o = n > 0 ? "+Infinity" : "-Infinity"; else { if (t) return n; o = hu(e, n.toString()) } return e.jsonSerializationOptions.metadata.includes("latex") && (i.latex = i.latex ?? e.serialize({ num: o })), i.latex !== void 0 ? { num: o, latex: i.latex } : { num: o } } function hu(e, n) { if (!e.jsonSerializationOptions.repeatingDecimals) return n; let [i, t, r, o] = n.match(/^(.*)\.([0-9]+)([e|E][-+]?[0-9]+)?$/) ?? []; if (!r) return n.toLowerCase(); let s = r[r.length - 1]; r = r.slice(0, -1); let a = 16, u = ""; for (let l = 0; l < r.length - a; l++) { u = r.substring(0, l); for (let f = 0; f <= a; f++) { let d = r.substring(l, l + f + 1), c = Math.floor((r.length - u.length) / d.length); if (c < 3) break; if ((u + d.repeat(c + 1)).startsWith(r)) return d === "0" ? s === "0" ? t + "." + u + (o ?? "") : n : t + "." + u + "(" + d + ")" + (o ?? "") } } for (r += s; r.endsWith("0");)r = r.slice(0, -1); return o ? `${t}.${r}${o.toLowerCase()}` : `${t}.${r}` } var qi = class e extends L { constructor(i, t, r) { r ?? (r = {}); super(i, r.metadata); this._value = new Map; let o = r.canonical ?? !0; if (t instanceof Map) for (let [s, a] of t) this._value.set(s, i.box(a, { canonical: o })); else for (let s of Object.keys(t)) this._value.set(s, i.box(t[s], { canonical: o })); i._register(this) } bind() { for (let [i, t] of this._value) t.bind() } reset() { for (let [i, t] of this._value) t.reset() } get hash() { let i = xe("Dictionary"); for (let [t, r] of this._value) i ^= xe(t) ^ r.hash; return i } get complexity() { return 97 } get head() { return "Dictionary" } get isPure() { return !1 } getKey(i) { return this._value.get(i) } hasKey(i) { return this._value.has(i) } get keys() { return this._value.keys() } get keysCount() { return this._value.size } has(i) { for (let [t, r] of this._value) if (r.has(i)) return !0; return !1 } get domain() { return this.engine.domain("Dictionaries") } get json() { if (this.engine.jsonSerializationOptions.shorthands.includes("dictionary")) { let t = {}; for (let r of this._value.keys()) t[r] = this._value.get(r).json; return { dict: t } } let i = []; for (let t of this._value.keys()) i.push(this.engine._fn("KeyValuePair", [this.engine.string(t), this._value.get(t)])); return O(this.engine, "Dictionary", i, { latex: this._latex }) } isSame(i) { if (this === i) return !0; if (!(i instanceof e) || this._value.size !== i._value.size) return !1; for (let [t, r] of this._value) { let o = i.getKey(t); if (!o || !r.isSame(o)) return !1 } return !0 } match(i, t) { if (!(i instanceof e) || this._value.size !== i._value.size) return null; let r = {}; for (let [o, s] of this._value) { let a = i.getKey(o); if (!a) return null; let u = s.match(a); if (u === null) return null; r = { ...r, ...u } } return r } isEqual(i) { if (this === i) return !0; if (!(i instanceof e) || !i.keys || this._value.size !== i._value.size) return !1; for (let [t, r] of this._value) { let o = i.getKey(t); if (!o || !r.isEqual(o)) return !1 } return !0 } evaluate(i) { return this } get isCanonical() { return this._isCanonical } set isCanonical(i) { this._isCanonical = i } get canonical() { return this.isCanonical ? this : new e(this.engine, this._value, { canonical: !0 }) } simplify(i) { return this } N(i) { return this } replace(i, t) { let r = 0, o = {}; for (let s of this.keys) { let a = this.getKey(s), u = a.replace(i, t); u !== null && (r += 1), o[s] = u ?? a } return r === 0 ? null : new e(this.engine, o) } subs(i, t) { let r = {}; for (let o of this.keys) r[o] = this.getKey(o).subs(i, t); return new e(this.engine, r, t) } }; var Nu = pe(ce(), 1); var bu = []; function jo(e) { if (e.head === "N" && typeof e.op1.head == "string") { let o = { Integrate: "NIntegrate", Limit: "NLimit" }[e.op1.head]; o && (e = e.engine._fn(o, e.op1.ops)) } if (e.head === "Function") return e; let n = e.unknowns; n.includes("_") && (e = e.subs({ _: "_1" }), n = e.unknowns); let i = 0; for (let o of n) if (o.startsWith("_")) { let s = Number(o.slice(1)); s > i && (i = s) } let t = e.engine; return t._fn("Function", [e, ...Array.from({ length: i }, (o, s) => t.symbol(`_${s + 1}`))]) } function Zo(e) { let n = e.engine, i = e.symbol ? n.lookupFunction(e.symbol) : void 0; if (i) { let a = i.signature.N ?? i.signature.evaluate; return a ? u => a(n, u) ?? n._fn(e, u) : u => n._fn(e, u) } let t = jo(e); if (!t) return; t.head; let r = t.ops.slice(1).map(a => a.symbol ?? "Nothing"); n.pushScope(); for (let a of r) n.declare(a, { inferred: !0, domain: void 0 }); let o = t.op1.canonical; o.bind(), n.popScope(); let s = o.scope; return r.length === 0 ? () => { let a = n.swapScope(s); n.resetContext(); let u = o.N() ?? o.evaluate(); return n.swapScope(a), u } : a => { if (n.strict && (a = Se(n, a, r.length), !a.every(d => d.isValid))) return; a = a.map(d => d.evaluate()); let u = n.swapScope(s); n.resetContext(); let l = 0; for (let d of r) n.assign(d, a[l++]); let f = o.N() ?? o.evaluate(); if (n.swapScope(u), !!f.isValid) return f } } function ui(e, n) { return Zo(e)?.(n) ?? e.engine._fn(e, n) } function li(e) { return Zo(e) ?? (n => e.engine._fn(e.N(), n).N()) } function Ho(e) { let n = e.engine, i = Zo(e); return i ? t => i([n.number(t)])?.value ?? NaN : t => n._fn(e.evaluate(), [n.number(t)]).value } function Jo(e) { let n = e.match(/(.+)\((.*)\)/); if (!n) return [e, void 0]; let i = n[1], t = n[2].split(",").map(r => r.trim()); return [i, t] } function on(e, n, i) { if (!n.isValid || !i.isValid) return e._fn("Divide", [n, i]); if (n.head === "Negate" && i.head === "Negate" && (n = n.op1, i = i.op1), n.numericValue !== null && i.numericValue !== null) { if (i.isOne) return n; if (i.isNegativeOne) return e.neg(n); if (n.isOne) return e.inv(i); if (n.isNegativeOne) return e.neg(e.inv(i)); let m = W(n), g = W(i); if (m && g && !Ze(g)) return e.number(Q(m, Tn(g))) } if (n.head === "Divide" && i.head === "Divide") return on(e, e.mul(n.op1, i.op2), e.mul(n.op2, i.op1)); if (n.head === "Divide") return on(e, e.mul(n.op1, i), n.op2); if (i.head === "Divide") return on(e, e.mul(n, i.op2), i.op1); let t = n.numericValue; if (t !== null) { if (J(t)) { let [m, g] = t; return on(e, e.number(m), e.mul(e.number(g), i)) } if (K(t)) { let [m, g] = t; return on(e, e.number(m), e.mul(e.number(g), i)) } } let r = i.numericValue; if (r !== null) { if (J(r)) { let [m, g] = r; return on(e, e.mul(n, e.number(g)), e.number(m)) } if (K(r)) { let [m, g] = r; return on(e, e.mul(n, e.number(g)), e.number(m)) } } let [o, s] = Je(n), [a, u] = Je(i); if (!ie(o) || !ie(a)) { let [m, g] = Fa(o, a), [h, x] = [e.mul(e.number(m), s), e.mul(e.number(g), u)]; return x.isNegative && (x = e.neg(x), h = e.neg(h)), x.head === "Negate" && (x = x.op1, h = e.neg(h)), h.isZero ? e.Zero : x.isOne ? h : e._fn("Divide", [h, x]) } let [l, f] = Io(n), [d, c] = Io(i); return f = f.canonical, c = c.canonical, c.numericValue !== null && c.isOne ? l * d < 0 ? ge(f) : f : l * d > 0 ? e._fn("Divide", [f, c]) : f.numericValue ? e._fn("Divide", [ge(f), c]) : ge(e._fn("Divide", [f, c])) } function Er(e, n, i) { if (n.numericValue !== null && i.numericValue !== null) { let t = W(n), r = W(i); if (t && r && !Ze(r)) return e.number(Q(t, Tn(r))) } return new wn(e, [n, e.inv(i)]).asRationalExpression() } function vr(e, n, i) { let t = Er(e, n, i); return t?.head === "Divide" && (!t.op1.isExact || !t.op2.isExact) && (t = Vn(n, i, (r, o) => r / o, (r, o) => r.div(o), (r, o) => r.div(o)) ?? t), t !== void 0 ? t : e._fn("Divide", [n, i]) } function Et(e, n) { if (n.every(s => s.isCanonical), n.length === 0) return e.One; if (n.length === 1) return n[0]; let i = [], t = 1, r, o = 0; for (let s of n) if (!s.isOne) { if (s.isNegativeOne) { t = -t; continue } if (s.head === "Negate") { t = -t, i.push(s.op1); continue } if (r === void 0 && typeof s.numericValue == "number") { r = s.numericValue, r < 0 && (t = -t, r = -r); continue } if (s.numericValue !== null && s.isNegative) { t = -t, i.push(e.neg(s)); continue } if (s.symbol === "ImaginaryUnit") { o++; continue } i.push(s) } return o > 0 && (o % 2 === 0 ? t = -t : (i.push(e.number(e.complex(0, t * (r ?? 1)))), t = 1, r = void 0)), typeof r == "number" && (i.push(e.number(t * r)), t = 1), t < 0 ? i.length === 0 ? e.NegativeOne : i.length === 1 ? e.neg(i[0]) : e.neg(e._fn("Multiply", i.sort(tn))) : i.length === 0 ? e.One : i.length === 1 ? i[0] : e._fn("Multiply", i.sort(tn)) } function yu(e, n) { n.every(t => t.head !== "Multiply"); let i = new wn(e); for (let t of n) { if (t = t.simplify(), t.isNaN || t.symbol === "Undefined") return e.NaN; i.addTerm(t) } return i.asExpression() } function vt(e, n, i = "evaluate") { if (n.length === 1) return n[0]; if (i === "N" && (n = n.map(t => t.N()), (e.numericMode === "machine" || e.numericMode === "auto") && n.every(t => typeof t.numericValue == "number"))) { let t = 1; for (let r of n) t *= r.numericValue; return e.number(t) } for (let t of n) { if (t.isNaN || t.symbol === "Undefined") return e.NaN; t.numericValue !== null && !t.isExact && (i = "N") } return n.every(t => t.head !== "Multiply"), i === "N" ? n = n.map(t => t.N()) : n = n.map(t => t.evaluate()), new wn(e, n).asExpression(i) } function Eu(e, n, i) { e.pushScope(), n ?? (n = e.error("missing")); var t = void 0; if (i && i.ops && i.ops[0]?.head === "Delimiter") { var r = ur(i); if (!r) return null; var o = [n.canonical]; r.forEach(a => { o.push(a) }), t = e._fn("Product", o) } else { var s = $n(i); t = s ? e._fn("Product", [n.canonical, s]) : e._fn("Product", [n.canonical]) } return e.popScope(), t } function Nr(e, n, i) { let t = n[0], r = []; if (n) { r = []; for (let m = 1; m < n.length; m++)r.push(n[m]) } let o = null; if (r?.length === 0) { let m = i === "simplify" ? t.simplify() : t.evaluate({ numericMode: i === "N" }); if (F(e)) { let g = e.bignum(1); for (let h of X(m)) { let x = Ge(h); if (x === null) { o = void 0; break } if (x.isFinite() === !1) { g = x; break } g = g.mul(x) } o === null && (o = e.number(g)) } else { let g = 1; for (let h of X(m)) { let x = E(h); if (x === null) { o = void 0; break } if (x === null || !Number.isFinite(x)) { g = x; break } g *= x } o === null && (o = e.number(g)) } return o ?? void 0 } var s = []; let a = [], u = [], l = []; r.forEach(m => { let [g, h, x, S] = zn(m.evaluate()); g && (s.push(g), a.push(h), u.push(x), l.push(S)) }); let f = t, d = e.swapScope(f.scope); e.pushScope(), f.bind(); for (let m = 0; m < s.length; m++) { let g = s[m], h = a[m], x = u[m], S = l[m]; if (h >= x || i !== "N" && (h >= x || x - h >= rt)) return; if (i === "simplify") { let T = []; for (let _ = h; _ <= x; _++)e.assign({ [g]: _ }), T.push(f.simplify()); o = e.mul(...T).simplify() } } let c = []; if (s.length > 1) for (let m = 0; m < s.length - 1; m++)c.length === 0 ? c = Ci(cn(a[m], u[m]), cn(a[m + 1], u[m + 1])) : c = Ci(c.map(g => g[0]), cn(a[m + 1], u[m + 1])); else c = cn(a[0], u[0]).map(m => [m]); if (i === "evaluate") { let m = []; for (let g of c) { let h = s.map((x, S) => (e.assign(x, g[S]), x)); m.push(f.evaluate()) } o = e.mul(...m).evaluate() } if (i === "N") for (let m = 0; m < s.length; m++) { let g = s[m], h = a[m], x = u[m], S = l[m]; if (o === null && S) { if (F(e)) { let j = e.bignum(1); for (let Z = h; Z <= x; Z++) { e.assign({ [g]: Z }); let De = Ge(f.N()); if (De === null || De.isFinite() === !1) { o = De !== null ? e.number(De) : void 0; break } j = j.mul(De) } o === null && (o = e.number(j)) } let T = 1, _ = e.numericMode, w = e.precision; e.numericMode = "machine"; for (let j = h; j <= x; j++) { e.assign({ [g]: j }); let Z = E(f.N()); if (Z === null || !Number.isFinite(Z)) { o = Z !== null ? e.number(Z) : void 0; break } T *= Z } e.numericMode = _, e.precision = w, o === null && (o = e.number(T)) } if (o === null) { e.assign({ [g]: 1e3 }); let T = f.N(); e.assign({ [g]: 999 }); let _ = f.N(), w = E(e.div(T, _).N()); if (w !== null && Number.isFinite(w) && Math.abs(w) > 1) o = e.PositiveInfinity; else { let j = 1, Z = e.numericMode, De = e.precision; e.numericMode = "machine"; for (let $e = h; $e <= x; $e++) { e.assign({ [g]: $e }); let Ce = E(f.N()); if (Ce === null) { o = void 0; break } if (Math.abs(1 - Ce) < Number.EPSILON || !Number.isFinite(Ce)) break; j *= Ce } o === null && (o = e.number(j)), e.numericMode = Z, e.precision = De } } } for (let m = 0; m < s.length; m++)e.assign(s[m], void 0); return e.popScope(), e.swapScope(d), o ?? void 0 } var be = class e extends L { constructor(i, t, r, o) { o ?? (o = {}), o.canonical ?? (o.canonical = !1); super(i, o.metadata); this._result = void 0; this._head = t, this._ops = r, o.canonical && (this._canonical = this, this.bind()), i._register(this) } get hash() { if (this._hash !== void 0) return this._hash; let i = 0; for (let t of this._ops) i = i << 1 ^ t.hash | 0; return typeof this._head == "string" ? i = i ^ xe(this._head) | 0 : i = i ^ this._head.hash | 0, this._hash = i, i } infer(i) { let t = this._def; return !t || !t.signature.inferredSignature ? !1 : (typeof t.signature.result != "function" && (t.signature.result = mt(t.signature.result, i)), !0) } bind() { this._def = void 0, this._scope = this.engine.context; let i = this._head; if (typeof i != "string") { i.bind(); return } this._def = this.engine.lookupFunction(i); for (let t of this._ops) t.bind() } reset() { } get isExact() { return Li(this) && this.op1.isExact } get isCanonical() { return this._canonical === this } set isCanonical(i) { this._canonical = i ? this : void 0 } get isPure() { if (this._isPure !== void 0) return this._isPure; if (!this.isCanonical) return this._isPure = !1, !1; let i = this.functionDefinition?.pure ?? !1; return i && (i = this._ops.every(t => t.isPure)), this._isPure = i, i } get json() { return this.isValid && this._canonical === this ? gu(this.engine, this._head, this._ops, { latex: this._latex, wikidata: this.wikidata }) : O(this.engine, this._head, this._ops, { latex: this._latex, wikidata: this.wikidata }) } get rawJson() { return [typeof this._head == "string" ? this._head : this._head.rawJson, ...this.ops.map(t => t.rawJson)] } get scope() { return this._scope } get head() { return this._head } get ops() { return this._ops } get nops() { return this._ops.length } get op1() { return this._ops[0] ?? this.engine.Nothing } get op2() { return this._ops[1] ?? this.engine.Nothing } get op3() { return this._ops[2] ?? this.engine.Nothing } get isValid() { return this._head === "Error" || typeof this._head != "string" && !this._head.isValid ? !1 : this._ops.every(i => i?.isValid) } get canonical() { return this._canonical ?? (this._canonical = this.isValid ? _r(this.engine, this._head, this._ops) : this), this._canonical } *map(i) { let t = 0; for (; t < this._ops.length;)yield i(this._ops[t++]) } subs(i, t) { t = t ? { ...t } : {}, "canonical" in t || (t.canonical = !0); let r = this._ops.map(o => o.subs(i, t)); return t.canonical && r.every(o => o.isValid) ? _r(this.engine, this._head, r) : new e(this.engine, this._head, r, { canonical: !1 }) } replace(i, t) { return rr(this, i, t) } has(i) { if (typeof this._head == "string") { if (typeof i == "string") { if (this._head === i) return !0 } else if (i.includes(this._head)) return !0 } for (let t of this._ops) if (t.has(i)) return !0; return !1 } isSame(i) { if (this === i) return !0; if (!(i instanceof e) || this.nops !== i.nops) return !1; if (typeof this.head == "string") { if (this.head !== i.head) return !1 } else if (typeof i.head == "string" || !i.head || !this.engine.box(this.head).isSame(this.engine.box(i.head))) return !1; let t = this._ops, r = i._ops; for (let o = 0; o < t.length; o++)if (!t[o].isSame(r[o])) return !1; return !0 } match(i, t) { if (!(i instanceof e)) return null; let r = {}; if (typeof this.head == "string") { if (this.head !== i.head) return null } else { if (typeof i.head == "string") return null; { if (!i.head) return null; let a = this.head.match(i.head, t); if (a === null) return null; r = { ...r, ...a } } } let o = this._ops, s = i._ops; for (let a = 0; a < o.length; a++) { let u = o[a].match(s[a], t); if (u === null) return null; r = { ...r, ...u } } return r } get complexity() { if (this.isCanonical) return this.functionDefinition?.complexity ?? pn } get baseDefinition() { return this.functionDefinition } get functionDefinition() { return this._def } isEqual(i) { if (this === i) return !0; let t = ni(this, i); return t === 0 ? !0 : t !== void 0 ? !1 : this.engine.add(this, this.engine.neg(i)).simplify().isZero ? !0 : this.isSame(i) } get isNumber() { return this.domain?.isCompatible("Numbers") } get isInteger() { return this.domain?.isCompatible("Integers") } get isRational() { return this.domain?.isCompatible("RationalNumbers") } get isAlgebraic() { return this.domain?.isCompatible("AlgebraicNumbers") } get isReal() { return this.domain?.isCompatible("RealNumbers") } get isExtendedReal() { return this.domain?.isCompatible("ExtendedRealNumbers") } get isComplex() { return this.domain?.isCompatible("ComplexNumbers") } get isImaginary() { return this.domain?.isCompatible("ImaginaryNumbers") } get domain() { if (this._result !== void 0) return this._result; if (!this.canonical) return; let i = this.engine, t; if (typeof this._head != "string") t = this._head.domain; else if (this._def) { let r = this._def.signature; typeof r.result == "function" ? t = r.result(i, this._ops) : t = r.result } return t ?? (t = void 0), this._result = t, t } simplify(i) { if (!this.isValid) return this; if (!this.isCanonical) { let f = this.canonical; return !f.isCanonical || !f.isValid ? this : f.simplify(i) } let t = i?.recursive ?? !0, r; if (t && (r = rn(this), r !== null)) return r = r.simplify({ ...i, recursive: !1 }), Nt(this, r); let o = this.functionDefinition, s = t ? vu(this._ops, o?.hold ?? "none", o?.associative ? o.name : "", f => f.simplify(i)) : this._ops; if (typeof this._head != "string") { let f = ui(this._head, s); return typeof f.head != "string" ? f : f.simplify(i) } if (o) if (o.inert) r = s[0]?.canonical ?? this; else { let f = o.signature; f?.simplify && (r = f.simplify(this.engine, s)) } r ? r = Nt(this.engine.box([this._head, ...s]), r) : r = this.engine.box([this._head, ...s]), r = Nt(this, r); let a = i?.rules ?? this.engine.cache("standard-simplification-rules", () => ti(this.engine, bu), f => { for (let [d, c, m, g] of f) d.reset(), c.reset(); return f }), u = 0, l = !1; do { let f = r.replace(a); f !== null ? (r = Nt(r, f), r === f && (l = !0)) : l = !0, u += 1 } while (!l && u < this.engine.iterationLimit); return Nt(this, r) } evaluate(i) { if (!this.isValid) return this; if (i?.numericMode) { let a = this.head; if (a === "Integrate" || a === "Limit") return this.engine.box(["N", this], { canonical: !0 }).evaluate(i) } if (!this.isCanonical) { this.engine.pushScope(); let a = this.canonical; return this.engine.popScope(), !a.isCanonical || !a.isValid ? this : a.evaluate(i) } let t = this.functionDefinition; if (t?.threadable && this.ops.some(a => ue(a))) { let a = Math.max(...this._ops.map(l => l.functionDefinition?.size?.(l) ?? 0)), u = []; for (let l = 0; l <= a - 1; l++) { let f = this._ops.map(d => ue(d) ? Ga(d, l % a + 1) ?? this.engine.Nothing : d); u.push(this.engine._fn(this.head, f).evaluate(i)) } return u.length === 0 ? this.engine.box(["Sequence"]) : u.length === 1 ? u[0] : this.engine._fn("List", u) } let r = vu(this._ops, t?.hold ?? "none", t?.associative ? t.name : "", a => a.evaluate(i)); if (t?.inert) return r[0] ?? this; let o; typeof this._head != "string" && (o = ui(this._head, r)); let s = t?.signature; if (!o && s) { let a = i?.numericMode ?? !1, u = this.engine.swapScope(this.scope); a && s.N && (o = s.N(this.engine, r)), !o && s.evaluate && (o = s.evaluate(this.engine, r)), this.engine.swapScope(u) } if (o) { let a = o.numericValue; a !== null && (!ae(this.engine) && a instanceof Nu.Complex ? o = this.engine.NaN : !F(this.engine) && a instanceof v && (o = this.engine.number(a.toNumber()))) } return o ?? this.engine.box([this._head, ...r]) } N(i) { return this.evaluate({ ...i, numericMode: !0 }) } solve(i) { return i.length !== 1 ? null : xr(this.simplify(), i[0]) } }; function gd(e, n, i, t) { let r = []; if (n === "Add" || n === "Multiply") r = Pe(e, e.canonical(i), { flatten: n }); else if (n === "Negate" || n === "Square" || n === "Sqrt" || n === "Exp" || n === "Ln") r = Pe(e, e.canonical(i), 1); else if (n === "Divide" || n === "Power") r = Pe(e, e.canonical(i), 2); else return null; if (!r.every(o => o.isValid)) return e._fn(n, r, t); if (n === "Add") return In(e, te(se(r), "Add")); if (n === "Negate") return ge(r[0]); if (n === "Multiply") return Et(e, te(se(r), "Multiply")); if (n === "Divide") return on(e, r[0].canonical, r[1].canonical); if (n === "Exp") return kn(e, e.E, r[0].canonical); if (n === "Power") return kn(e, r[0].canonical, r[1].canonical); if (n === "Square") return kn(e, r[0].canonical, e.number(2)); if (n === "Sqrt") { let o = r[0].canonical; return U(o.numericValue) ? e._fn("Sqrt", [o], t) : kn(e, o, e.Half) } return n === "Ln" ? e._fn("Ln", r, t) : null } function _r(e, n, i, t) { if (typeof n != "string" && (e.pushScope(), n = n.evaluate().symbol ?? n, e.popScope()), typeof n == "string") { let u = gd(e, n, i, t); if (u) return u } else if (!n.isValid) return new be(e, n, i.map(u => e.box(u, { canonical: !1 })), { metadata: t, canonical: !1 }); let r = e.lookupFunction(n); if (!r) return new be(e, n, se(i.map(u => e.box(u))), { metadata: t, canonical: !0 }); let o = []; for (let u = 0; u < i.length; u++)if (!Bn(r.hold, i.length - 1, u)) o.push(e.box(i[u])); else { let l = e.box(i[u], { canonical: !1 }); l.head === "ReleaseHold" ? o.push(l.op1.canonical) : o.push(l) } let s = r.signature; if (s.canonical) { try { let u = s.canonical(e, o); if (u) return u } catch (u) { console.error(u) } return new be(e, n, o, { metadata: t, canonical: !1 }) } o = se(o), r.associative && (o = te(o, n)); let a = Za(e, o, r.hold, r.threadable, s.params, s.optParams, s.restParam); if (a) return e._fn(n, a, t); if (o.length === 1 && o[0].head === n) { if (r.involution) return o[0].op1; r.idempotent && (o = o[0].ops) } return o.length > 1 && r.commutative === !0 && (o = o.sort(tn)), e._fn(n, o, t) } function vu(e, n, i, t) { if (e.length === 0) return []; if (e = te(e, i), n === "all") return e; if (n === "none") { let o = []; for (let s of e) { let a = s.head; if (a === "Hold") o.push(s); else { let u = a === "ReleaseHold" ? s.op1 : s; if (u) { let l = t(u); l !== null && o.push(l) } } } return te(o, i) } let r = []; for (let o = 0; o < e.length; o++)if (e[o].head === "Hold") r.push(e[o]); else { let s; if (e[o].head === "ReleaseHold" ? s = e[o].op1 : Bn(n, e.length - 1, o) ? r.push(e[o]) : s = e[o], s) { let a = t(s); a !== null && r.push(a) } } return te(r, i) } function Nt(e, n) { if (n == null || e === n) return e; let i = e.engine, t = i.box(n); return i.costFunction(t) <= 1.2 * i.costFunction(e) ? t : e } var Re = pe(ce(), 1); var xd = 0x3ffffffffffe5; function jn(e) { if (!Number.isInteger(e) || !Number.isFinite(e) || Number.isNaN(e) || e <= 1) return !1; if (e <= ka) return No.has(e); for (let n of No) if (e % n === 0) return !1; return e >= xd ? yd(e, 30) ? void 0 : !1 : e === bd(e) } function bd(e) { if (e === 1) return 1; if (e % 2 === 0) return 2; if (e % 3 === 0) return 3; if (e % 5 === 0) return 5; let n = Math.floor(Math.sqrt(e)), i = 7; for (; i <= n;) { if (e % i === 0) return i; if (e % (i + 4) === 0) return i + 4; if (e % (i + 6) === 0) return i + 6; if (e % (i + 10) === 0) return i + 10; if (e % (i + 12) === 0) return i + 12; if (e % (i + 16) === 0) return i + 16; if (e % (i + 22) === 0) return i + 22; if (e % (i + 24) === 0) return i + 24; i += 30 } return e } function yd(e, n) { let i = 0, t = e - 1; for (; t % 2 === 0;)t /= 2, ++i; e: do { let r = Math.pow(2 + Math.floor(Math.random() * (e - 3)), t) % e; if (!(r === 1 || r === e - 1)) { for (let o = i - 1; o--;) { if (r = r * r % e, r === 1) return !1; if (r === e - 1) continue e } return !1 } } while (--n); return !0 } var le = class e extends L { constructor(i, t, r) { super(i, r?.metadata); if (typeof t == "number") { this._value = t, this._isCanonical = !0; return } if (U(t)) { let [o, s] = t; typeof o != "number" || Number.isInteger(o) && Number.isInteger(s), !(typeof o == "bigint" && typeof s == "bigint") || s !== o && BigInt(1), r?.canonical ?? !0 ? (this._value = Wo(i, t), this._isCanonical = !0) : (this._value = t, this._isCanonical = !1) } else !(t instanceof Re.Complex) || !Number.isNaN(t.re) && !Number.isNaN(t.im) && i.chop(t.im), this._value = Wo(i, t), this._isCanonical = !0 } get hash() { if (this._hash !== void 0) return this._hash; let i = 0; return typeof this._value == "number" ? i = xe(this._value.toString()) : this._value instanceof Re.Complex ? i = xe(this._value.re.toString() + " +i " + this._value.im.toString()) : this._value instanceof v ? i = xe(this._value.toString()) : i = xe(this._value[0].toString() + " / " + this._value[1].toString()), this._hash = i, i } get head() { return "Number" } get isPure() { return !0 } get isExact() { let i = this._value; return typeof i == "number" ? Number.isInteger(i) : i instanceof v ? i.isInteger() : i instanceof Re.Complex ? Number.isInteger(i.re) && Number.isInteger(i.im) : U(i) } get isCanonical() { return this._isCanonical } set isCanonical(i) { this._isCanonical = i } get complexity() { return 1 } get numericValue() { return this._value } get domain() { return this._domain ?? (this._domain = this.engine.domain($a(this._value))), this._domain } get json() { return ai(this.engine, this._value, { latex: this._latex }) } get sgn() { if (this._value === 0) return 0; if (typeof this._value == "number") return this._value < 0 ? -1 : this._value > 0 ? 1 : null; if (this._value instanceof v) return this._value.isZero() ? 0 : this._value.isNegative() ? -1 : this._value.isPositive() ? 1 : null; if (Array.isArray(this._value)) { let [i, t] = this._value; return i === 0 && t !== 0 ? 0 : i < 0 ? -1 : i > 0 ? 1 : null } return null } isSame(i) { if (this === i) return !0; if (!(i instanceof e)) return !1; if (typeof this._value == "number") return typeof i._value != "number" ? !1 : this._value === i._value; if (this._value instanceof v) return i._value instanceof v ? this._value.eq(i._value) : !1; if (Array.isArray(this._value)) { if (!Array.isArray(i._value)) return !1; let [t, r] = i._value; return this._value[0] === t && this._value[1] === r } return this._value instanceof Re.Complex && i._value instanceof Re.Complex ? this._value.equals(i._value) : !1 } isEqual(i) { return this === i || ni(this, i) === 0 } match(i, t) { return this.isEqualWithTolerance(i, t?.numericTolerance ?? 0) ? {} : null } isEqualWithTolerance(i, t) { return i instanceof e && ni(this, i, t) === 0 } isLess(i) { let t = ni(this, i); if (t !== void 0) return t < 0 } isLessEqual(i) { let t = ni(this, i); if (t !== void 0) return t <= 0 } isGreater(i) { return i.isLessEqual(this) } isGreaterEqual(i) { return i.isLess(this) } get isPositive() { if (typeof this._value == "number") return this._value > 0; let i = this.sgn; if (i != null) return i > 0 } get isNonNegative() { if (typeof this._value == "number") return this._value >= 0; let i = this.sgn; if (i != null) return i >= 0 } get isNegative() { if (typeof this._value == "number") return this._value < 0; let i = this.sgn; if (i != null) return i < 0 } get isNonPositive() { if (typeof this._value == "number") return this._value <= 0; let i = this.sgn; if (i != null) return i <= 0 } get isZero() { return this._value === 0 ? !0 : this._value instanceof v ? this._value.isZero() : this._value instanceof Re.Complex ? this._value.isZero() : !1 } get isNotZero() { return this._value === 0 ? !1 : this._value instanceof v ? !this._value.isZero() : this._value instanceof Re.Complex ? !this._value.isZero() : !0 } get isOne() { return this._value === 1 ? !0 : typeof this._value == "number" ? !1 : this._value instanceof v ? this._value.equals(this.engine._BIGNUM_ONE) : this._value instanceof Re.Complex ? this._value.im === 0 && this._value.re === 1 : ie(this._value) } get isNegativeOne() { return this._value === -1 ? !0 : typeof this._value == "number" ? !1 : this._value instanceof v ? this._value.equals(this.engine._BIGNUM_NEGATIVE_ONE) : this._value instanceof Re.Complex ? this._value.im === 0 && this._value.re === -1 : Bi(this._value) } get isOdd() { if (this.isOne || this.isNegativeOne) return !0; if (this.isZero || !this.isInteger) return !1; if (typeof this._value == "number") return this._value % 2 !== 0; if (this._value instanceof v) return !this._value.mod(2).isZero() } get isEven() { if (this.isOne || this.isNegativeOne) return !1; if (this.isZero) return !0; if (!this.isInteger) return !1; if (typeof this._value == "number") return this._value % 2 === 0; if (this._value instanceof v) return this._value.mod(2).isZero() } get isPrime() { if (!this.isInteger || !this.isFinite || this.isNonPositive || this.isOne || this.isZero) return !1; if (typeof this._value == "number") return jn(this._value); if (this._value instanceof v) return jn(this._value.toNumber()) } get isComposite() { if (!this.isInteger || !this.isFinite || this.isNonPositive || this.isOne || this.isZero) return !1; if (typeof this._value == "number") return !jn(this._value); if (this._value instanceof v) return !jn(this._value.toNumber()) } get isInfinity() { return typeof this._value == "number" ? !Number.isFinite(this._value) && !Number.isNaN(this._value) : this._value instanceof v ? !this._value.isFinite() && !this._value.isNaN() : this._value instanceof Re.Complex ? !this._value.isFinite() && !this._value.isNaN() : !1 } get isNaN() { return typeof this._value == "number" ? Number.isNaN(this._value) : this._value instanceof v ? this._value.isNaN() : this._value instanceof Re.Complex ? this._value.isNaN() : !1 } get isFinite() { return !this.isInfinity && !this.isNaN } get isNumber() { return !0 } get isInteger() { return typeof this._value == "number" ? Number.isInteger(this._value) : this._value instanceof v ? this._value.isInteger() : !1 } get isRational() { return Array.isArray(this._value) ? !0 : this.isInteger } get isAlgebraic() { if (this.isRational) return !0 } get isReal() { return this.isFinite ? this._value instanceof Re.Complex ? this.engine.chop(this._value.im) === 0 : !0 : !1 } get isExtendedReal() { return this.isInfinity || this.isReal } get isComplex() { return !this.isNaN } get isImaginary() { return this._value instanceof Re.Complex ? (this._value.im, !0) : !1 } get isExtendedComplex() { return this.isInfinity || !this.isNaN } get canonical() { return this._isCanonical ? this : this.engine.number(Wo(this.engine, this._value)) } simplify(i) { return this.canonical } evaluate(i) { return i?.numericMode ? this.N(i) : this } N(i) { if (!Array.isArray(this._value)) return this; let t = this.engine, [r, o] = this._value; return typeof r == "number" && typeof o == "number" && !F(t) ? t.number(r / o) : t.number(t.bignum(r).div(t.bignum(o))) } }; function Wo(e, n) { if (n instanceof v && br(n)) return n.toNumber(); if (!U(n)) return n; if (n = je(n), K(n)) { let [r, o] = n; if (r > Number.MIN_SAFE_INTEGER && r < Number.MAX_SAFE_INTEGER && o > Number.MIN_SAFE_INTEGER && o < Number.MAX_SAFE_INTEGER) n = [Number(r), Number(o)]; else return o < 0 && ([r, o] = [-r, -o]), o === BigInt(1) ? e.bignum(r) : o === BigInt(0) ? r === o ? NaN : r < 0 ? -1 / 0 : 1 / 0 : [r, o] } let [i, t] = n; return Number.isNaN(i) || Number.isNaN(t) ? NaN : (t < 0 && ([i, t] = [-i, -t]), t === 1 ? i : t === 0 ? i === 0 || !Number.isFinite(i) ? NaN : i < 0 ? -1 / 0 : 1 / 0 : i === 0 ? i : [i, t]) } var gn = class e extends L { constructor(i, t, r) { super(i, r); this._string = t.normalize(), i._register(this) } get hash() { return xe("String" + this._string) } get json() { return xu(this.engine, this._string) } get head() { return "String" } get isPure() { return !0 } get isCanonical() { return !0 } set isCanonical(i) { } get domain() { return this.engine.Strings } get complexity() { return 19 } get string() { return this._string } isEqual(i) { return i.string === this._string } isSame(i) { return i.string === this._string } match(i, t) { return i instanceof e && this._string === i._string ? {} : null } }; var Ko = pe(ce(), 1); function Sr(e, n) { switch (n) { case "float64": case "float32": case "int32": case "uint8": return new Yo(e); case "complex128": case "complex64": return new Xo(e); case "bool": case "string": case "expression": return new Qo(e) }throw new Error(`Unknown dtype ${n}`) } var Yo = class { constructor(n) { this.ce = n; this.one = 1; this.zero = 0; this.nan = NaN } cast(n, i) { let t = this.ce; switch (i) { case "float64": case "float32": case "int32": case "uint8": return n; case "complex128": case "complex64": return Array.isArray(n) ? n.map(r => t.complex(r)) : this.ce.complex(n); case "bool": return Array.isArray(n) ? n.map(r => r !== 0) : n !== 0; case "string": return Array.isArray(n) ? n.map(r => Number(r).toString()) : Number(n).toString(); case "expression": return Array.isArray(n) ? n.map(r => t.number(r)) : t.number(n) }throw new Error(`Cannot cast ${n} to ${i}`) } expression(n) { return this.ce.number(n) } isZero(n) { return n === 0 } isOne(n) { return n === 1 } equals(n, i) { return n === i } add(n, i) { return n + i } addn(...n) { return n.reduce((i, t) => i + t, 0) } neg(n) { return -n } sub(n, i) { return n - i } mul(n, i) { return n * i } muln(...n) { return n.reduce((i, t) => i * t, 1) } div(n, i) { return n / i } pow(n, i) { return n ** i } conjugate(n) { return n } }, Qo = class { constructor(n) { this.one = n.One, this.zero = n.Zero, this.nan = n.NaN, this.ce = n } cast(n, i) { if (Array.isArray(n)) return n.map(r => this.cast(r, i)); let t = n.value; switch (i) { case "float64": case "float32": return typeof t == "number" ? t : void 0; case "int32": return typeof t == "number" ? Math.round(t) : void 0; case "uint8": if (typeof t != "number") return; let r = Math.round(t); return r >= 0 && r <= 255 ? r : void 0; case "complex128": case "complex64": if (typeof t == "number") return this.ce.complex(t); let o = n.numericValue; return o instanceof Ko.default ? o : void 0; case "bool": return typeof t == "boolean" ? t : void 0; case "string": return typeof t == "string" ? t : void 0; case "expression": return n }throw new Error(`Cannot cast ${n} to ${i}`) } expression(n) { return n } isZero(n) { return n.isZero ?? !1 } isOne(n) { return n.isOne ?? !1 } equals(n, i) { return n.isEqual(i) } add(n, i) { return this.ce.add(n, i) } addn(...n) { return this.ce.add(...n) } neg(n) { return this.ce.neg(n) } sub(n, i) { return this.ce.add(n, this.ce.neg(i)) } mul(n, i) { return this.ce.mul(n, i) } muln(...n) { return this.ce.mul(...n) } div(n, i) { return this.ce.div(n, i) } pow(n, i) { return this.ce.pow(n, i) } conjugate(n) { return this.ce.box(["Conjugate", n]) } }, Xo = class { constructor(n) { this.ce = n, this.one = n.complex(1), this.zero = n.complex(0), this.nan = n.complex(NaN) } cast(n, i) { if (Array.isArray(n)) return n.map(t => this.cast(t, i)); switch (i) { case "float64": return n.im === 0 ? n.re : void 0; case "float32": return n.im === 0 ? n.re : void 0; case "int32": return n.im === 0 ? Math.round(n.re) : void 0; case "uint8": if (n.im !== 0) return; let t = Math.round(n.re); return t >= 0 && t <= 255 ? t : void 0; case "complex128": return n; case "complex64": return n; case "bool": return !(n.im === 0 && n.re === 0); case "string": return n.toString(); case "expression": return this.ce.number(n) }throw new Error(`Cannot cast ${n} to ${i}`) } expression(n) { return this.ce.number(n) } isZero(n) { return n.isZero() } isOne(n) { return n.re === 1 && n.im === 0 } equals(n, i) { return n.equals(i) } add(n, i) { return n.add(i) } addn(...n) { return n.reduce((i, t) => i.add(t), this.zero) } neg(n) { return n.neg() } sub(n, i) { return n.sub(i) } mul(n, i) { return n.mul(i) } muln(...n) { return n.reduce((i, t) => i.mul(t), this.one) } div(n, i) { return n.div(i) } pow(n, i) { return n.pow(i) } conjugate(n) { return n.conjugate() } }; function Tr(e, n) { return e === n ? e : e === "string" || n === "string" || e === "expression" || n === "expression" ? "expression" : e === "complex128" || n === "complex128" ? "complex128" : e === "complex64" || n === "complex64" ? "complex64" : e === "float64" || n === "float64" ? "float64" : e === "float32" || n === "float32" ? "float32" : e === "int32" || n === "int32" ? "int32" : e === "uint8" || n === "uint8" ? "uint8" : e === "bool" || n === "bool" ? "bool" : "expression" } function es(e) { let n = e.value; if (typeof n == "number") return Number.isInteger(n) ? n >= 0 && n <= 255 ? "uint8" : "int32" : "float64"; let i = e.numericValue; return i !== null && i instanceof Ko.default ? "complex128" : e.string ? "string" : "expression" } var Zn = class e { constructor(n, i) { this.ce = n; this.shape = i.shape, this.rank = this.shape.length, this._strides = Ed(this.shape), this.field = Sr(n, i.dtype) } static align(n, i) { if (n.dtype === i.dtype) return [n, i]; let t = Tr(n.dtype, i.dtype); return n.dtype === t ? [n, i.upcast(t)] : [n.upcast(t), i] } static broadcast(n, i, t) { if (!(t instanceof e)) return i.map1(n, t); let [r, o] = e.align(i, t), s = r.data.map((a, u) => n(a, o.data[u])); return xn(r.ce, { dtype: r.dtype, shape: r.shape, data: s }) } get expression() { let n = this.shape, i = this.rank, t = this.data, r = this._index.bind(this), o = this.field.expression.bind(this.field), s = a => { if (a.length === i - 1) { let u = r(a), l = this.ce._fn("List", t.slice(u, u + n[i - 1]).map(f => o(f))); return l.isCanonical = l.ops.every(f => f.isCanonical), l } else { let u = []; for (let f = 0; f <= n[a.length] - 1; f++)u.push(s([...a, f + 1])); let l = this.ce._fn("List", u); return l.isCanonical = l.ops.every(f => f.isCanonical), l } }; return s([]) } get array() { let n = this.shape, i = this.rank, t = this.data; if (i === 1) return t; if (i === 2) { let [s, a] = n, u = new Array(s); for (let l = 0; l < s; l++)u[l] = t.slice(l * a, (l + 1) * a); return u } let r = this._index.bind(this), o = s => { if (s.length === i - 1) { let a = r(s); return t.slice(a, a + n[i - 1]) } else { let a = []; for (let u = 0; u < n[s.length]; u++)a.push(o([...s, u + 1])); return a } }; return o([]) } _index(n) { let i = this._strides; return n.reduce((t, r, o) => t + (r - 1) * i[o], 0) } get isSquare() { let n = this.shape; return n.length === 2 && n[0] === n[1] } get isSymmetric() { if (!this.isSquare) return !1; let n = this.shape[0], i = this.data, t = this.field.equals.bind(this.field); for (let r = 0; r < n; r++)for (let o = r + 1; o < n; o++)if (!t(i[r * n + o], i[o * n + r])) return !1; return !0 } get isSkewSymmetric() { if (!this.isSquare) return !1; let n = this.shape[0], i = this.data, t = this.field.equals.bind(this.field), r = this.field.neg.bind(this.field); for (let o = 0; o < n; o++)for (let s = o + 1; s < n; s++)if (!t(i[o * n + s], r(i[s * n + o]))) return !1; return !0 } get isUpperTriangular() { if (!this.isSquare) return !1; let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field); for (let r = 1; r < n; r++)for (let o = 0; o < r; o++)if (t(i[r * n + o])) return !1; return !0 } get isLowerTriangular() { if (!this.isSquare) return !1; let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field); for (let r = 0; r < n - 1; r++)for (let o = r + 1; o < n; o++)if (!t(i[r * n + o])) return !1; return !0 } get isTriangular() { if (!this.isSquare) return !1; let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field); for (let r = 0; r < n; r++)for (let o = 0; o < n; o++)if (r < o && !t(i[r * n + o]) || r > o && !t(i[r * n + o])) return !1; return !0 } get isDiagonal() { if (!this.isSquare) return !1; let n = this.shape[0], i = this.data, t = this.field.isZero.bind(this.field); for (let r = 0; r < n; r++)for (let o = 0; o < n; o++)if (r === o && !t(i[r * n + o]) || r !== o && !t(i[r * n + o])) return !1; return !0 } get isIdentity() { if (!this.isSquare) return !1; let [n, i] = this.shape, t = this.data, r = this.field.isOne.bind(this.field), o = this.field.isZero.bind(this.field); for (let s = 0; s < i; s++)for (let a = 0; a < i; a++)if (s === a && !r(t[s * i + a]) || s !== a && !o(t[s * i + a])) return !1; return !0 } get isZero() { let n = this.field.isZero.bind(this.field); return this.data.every(i => n(i)) } at(...n) { let i = this.data.length; return this.data[this._index(n) % i] } diagonal(n, i) { if (n ?? (n = 1), i ?? (i = 2), n === i || n <= 0 || n > this.shape.length || this.shape[n - 1] !== this.shape[i - 1]) return; let t = new Array(this.shape[n - 1]), r = this.data, o = this.shape[n - 1]; for (let s = 0; s < o; s++)t[s] = r[s * o + s]; return t } trace(n, i) { if (this.rank !== 2) return; let [t, r] = this.shape; if (t !== r) return; let o = this.data, s = new Array(t); for (let a = 0; a < t; a++)s[a] = o[a * t + a]; return this.field.addn(...s) } reshape(...n) { return xn(this.ce, { dtype: this.dtype, shape: n, data: this.data }) } flatten() { return this.data } upcast(n) { let i = this.field.cast(this.data, n); if (i === void 0) throw Error(`Cannot cast tensor to ${n}`); return xn(this.ce, { dtype: n, shape: this.shape, data: i }) } transpose(n, i, t) { if (this.rank !== 2) return; if (n ?? (n = 1), i ?? (i = 2), n === i) return this; if (n <= 0 || n > 2 || i <= 0 || i > 2) return; let [r, o] = this.shape, s = this.data; t && (s = s.map(f => t(f))); let a = 0, u = new Array(r * o), l = o; for (let f = 0; f < o; f++)for (let d = 0; d < r; d++)u[a++] = s[d * l + f]; return xn(this.ce, { dtype: this.dtype, shape: [o, r], data: u }) } conjugateTranspose(n, i) { let t = this.field.conjugate.bind(this.field); return this.transpose(n, i, t) } determinant() { if (this.rank !== 2) return; let [n, i] = this.shape; if (n !== i) return; if (n === 1) return this.data[0]; let t = this.field.add.bind(this.field), r = this.field.mul.bind(this.field), o = this.field.neg.bind(this.field); if (n === 2) { let [h, x, S, T] = this.data; return t(r(h, T), o(r(x, S))) } let s = this.field.addn.bind(this.field), a = this.field.muln.bind(this.field); if (n === 3) { let [h, x, S, T, _, w, j, Z, De] = this.data; return s([a(h, _, De), a(x, w, j), a(S, T, Z), o(a(S, _, j)), o(a(x, T, De)), o(a(h, w, Z))]) } let u = this.shape[0], l = !1, f = this.field.div.bind(this.field), d = this.field.sub.bind(this.field), c = new Array(u).fill(0).map((h, x) => x), m = [...this.data]; for (let h = 0; h < u; h++) { let x = c[h - 1]; if (this.at(x, h) === 0) { let _; for (_ = h + 1; _ < u; _++)if (this.at(c[_], h) !== 0) { x = c[_], c[_ - 1] = c[h - 1], c[h - 1] = x, l = !l; break } if (_ === u) return this.at(x, h) } let S = this.at(x, h), T = h === 0 ? 1 : this.at(c[h - 2], h - 2); for (let _ = h + 1; _ < u; _++) { let w = c[_ - 1]; for (let j = h + 1; j < u; j++)m[w][j] = f(d(r(m[w][j], S), r(m[w][h], m[x][j])), T) } } let g = m[c[u - 1]][u - 1]; return l ? this.field.neg(g) : g } inverse() { if (this.rank !== 2) return; let [n, i] = this.shape; if (n !== i) return; if (n === 2) { let [c, m, g, h] = this.data, x = this.determinant(); if (x === void 0 || this.field.isZero(x)) return; let S = this.field.div.bind(this.field), T = this.field.neg.bind(this.field), _ = [S(h, x), T(S(m, x)), T(S(g, x)), S(c, x)]; return xn(this.ce, { dtype: this.dtype, shape: [i, i], data: _ }) } let t = this.shape[0], r = this.field.div.bind(this.field), o = this.field.sub.bind(this.field), s = this.field.mul.bind(this.field), a = this.array, u = new Array(t).fill(0).map((c, m) => { let g = new Array(t).fill(0); return g[m] = 1, g }), l = a.map((c, m) => [...c, ...u[m]]), f = new Array(t).fill(0).map((c, m) => m); for (let c = 0; c < t; c++) { let m = f[c - 1]; if (this.at(m, c) === 0) { let x; for (x = c + 1; x < t; x++)if (this.at(f[x], c) !== 0) { m = f[x], f[x - 1] = f[c - 1], f[c - 1] = m; break } if (x === t) return } let g = this.at(m, c), h = c === 0 ? 1 : this.at(f[c - 2], c - 2); for (let x = c + 1; x < t; x++) { let S = f[x - 1]; for (let T = c + 1; T < t * 2; T++)l[S][T] = o(l[S][T], s(r(s(l[S][c], l[m][T]), g), h)) } } for (let c = t - 1; c >= 0; c--) { let m = l[f[c], c]; for (let g = 0; g < c; g++) { let h = f[g]; for (let x = t; x < t * 2; x++)l[h][x] = o(l[h][x], s(r(s(l[h][c], l[c][x]), m), m)) } for (let g = t; g < t * 2; g++)l[c][g] = r(l[c][g], m) } let d = l.map(c => c.slice(t)); return xn(this.ce, { dtype: this.dtype, shape: [i, i], data: d }) } pseudoInverse() { } adjugateMatrix() { } minor(n, i) { } map1(n, i) { return xn(this.ce, { dtype: this.dtype, shape: this.shape, data: this.data.map(t => n(t, i)) }) } map2(n, i) { let t = i.data; return xn(this.ce, { dtype: this.dtype, shape: this.shape, data: this.data.map((r, o) => n(r, t[o])) }) } add(n) { return e.broadcast(this.field.add.bind(this.field), this, n) } subtract(n) { return e.broadcast(this.field.sub.bind(this.field), this, n) } multiply(n) { return e.broadcast(this.field.mul.bind(this.field), this, n) } divide(n) { return e.broadcast(this.field.div.bind(this.field), this, n) } power(n) { return e.broadcast(this.field.pow.bind(this.field), this, n) } equals(n) { if (this.rank !== n.rank || !this.shape.every((o, s) => o === n.shape[s])) return !1; let i = this.field.equals.bind(this.field), t = this.field.cast.bind(this.field), r = this.dtype; return this.dtype !== n.dtype ? !!this.data.every((o, s) => i(o, t(n.data[s], r))) : this.data.every((o, s) => i(o, n.data[s])) } }; function Ed(e) { let n = new Array(e.length); for (let i = e.length - 1, t = 1; i >= 0; i--)n[i] = t, t *= e[i]; return n } var ns = class extends Zn { constructor(i, t) { super(i, t); this.dtype = "float64"; this.data = t.data } get isZero() { return this.data.every(i => i === 0) } }, is = class extends Zn { constructor(i, t) { super(i, t); this.dtype = "complex128"; this.data = t.data } }, ts = class extends Zn { constructor(i, t) { super(i, t); this.dtype = "bool"; this.data = t.data } }, rs = class extends Zn { constructor(i, t) { super(i, t); this.dtype = "expression"; this.data = t.data } }; function xn(e, n) { let i = n.dtype; return i === "float64" || i === "float32" || i === "uint8" || i === "int32" ? new ns(e, n) : i === "bool" ? new ts(e, n) : i === "complex64" || i === "complex128" ? new is(e, n) : new rs(e, n) } var _t = class e extends L { constructor(i, t, r) { r ?? (r = {}), r.canonical ?? (r.canonical = !0); super(i, r.metadata); t instanceof Zn ? this._tensor = t : (this._head = t.head ?? "List", this._ops = r.canonical ? i.canonical(t.ops) : t.ops, this._expression = new be(i, this._head, this._ops, { canonical: r.canonical })), i._register(this) } get expression() { return this._expression ?? (this._expression = this._tensor.expression), this._expression } get tensor() { if (this._tensor === void 0) { this._head, this._ops; let i = vd(this._head, this._ops); if (i === void 0) throw new Error("Invalid tensor"); this._tensor = xn(this.engine, i) } return this._tensor } get baseDefinition() { return this.expression.baseDefinition } get functionDefinition() { return this.expression.functionDefinition } bind() { this.expression.bind() } reset() { } get hash() { return xe("BoxedTensor") } get canonical() { return this.isCanonical ? this : new e(this.engine, { head: this._head, ops: this._ops }, { canonical: !0 }) } get isCanonical() { return this._tensor ? !0 : this._expression.isCanonical } set isCanonical(i) { this._tensor || (this.expression.isCanonical = i) } get isPure() { return this._tensor ? !0 : this.expression.isPure } get isValid() { return this._tensor ? !0 : this.expression.isValid } get complexity() { return 97 } get head() { return this._tensor ? "List" : this._head } get nops() { return this._tensor ? this._tensor.shape[0] : this.expression.nops } get ops() { return this.expression.ops } get op1() { if (this._tensor) { let i = this._tensor.data; return i.length === 0 ? this.engine.Nothing : this.engine.box(i[0]) } return this.expression.op1 } get op2() { if (this._tensor) { let i = this._tensor.data; return i.length < 2 ? this.engine.Nothing : this.engine.box(i[1]) } return this.expression.op2 } get op3() { if (this._tensor) { let i = this._tensor.data; return i.length < 3 ? this.engine.Nothing : this.engine.box(i[2]) } return this.expression.op3 } get shape() { return this.tensor.shape } get rank() { return this.tensor.rank } get domain() { return this._tensor ? this.engine.domain("Lists") : this.expression.domain } get json() { return this.expression.json } get rawJson() { return this.expression.rawJson } isSame(i) { return this === i ? !0 : i instanceof e ? this.tensor.equals(i.tensor) : this.expression.isSame(i) } isEqual(i) { return this === i ? !0 : i instanceof e ? this.tensor.equals(i.tensor) : this.expression.isEqual(i) } match(i, t) { return this.expression.match(i, t) } evaluate(i) { return this._tensor ? this : this.expression.evaluate(i) } simplify(i) { return this._tensor ? this : this.expression.simplify(i) } N(i) { return this._tensor ? this : this.expression.N(i) } }; function Le(e) { return e instanceof _t } function os(e, n) { let i, t = [], r = !0, o = (s, a = 0) => { if (s.length !== 0) { s.length > 1 && t[a] !== void 0 ? r = r && t[a] === s.length : t[a] = Math.max(t[a] ?? 0, s.length); for (let u of s) if (u.head === e ? o(u.ops, a + 1) : i === void 0 ? i = es(u) : i = Tr(i, es(u)), !r) return } }; if (o(n), !!r) return { shape: t, dtype: i } } function vd(e, n) { let { shape: i, dtype: t } = os(e, n) ?? { shape: [], dtype: void 0 }; if (t === void 0) return; let r = !0, o = [], s = Sr(n[0].engine, "expression"), a = s.cast.bind(s), u = l => { for (let f of l) if (f.head === e) u(f.ops); else { let d = a(f, t); if (d === void 0) { r = !1; return } o.push(d) } }; if (u(n), !!r) return { shape: i, data: o, dtype: t } } function St(e) { return e[Math.floor(Math.random() * e.length)] } function _u(e, n) { if (e === "Add" || e === "Multiply") { let i = [], t = 1 + Math.floor(Math.random() * 12); for (; t > 0;)i.push(bn(n + 1)), t -= 1; return [e, ...i] } return e === "Divide" || e === "Power" ? [e, bn(n + 1), bn(n + 1)] : e === "Root" ? [e, bn(n + 1), bn(10)] : e === "trig" ? Nd() : [e, bn(n + 1)] } function Nd() { return [St(["Cos", "Sin", "Tan", "Sinh", "Arccos", "Arsinh"]), St(["Pi", "-1", "0", "1", ["Divide", "Pi", -5], ["Multiply", -2, ["Divide", "Pi", 11]], ["Multiply", "Half", "Pi"], ["Multiply", 5, "Pi"], ["Multiply", 12, "Pi"], ["Divide", "Pi", 5], ["Divide", "Pi", 9], ["Multiply", 5, ["Divide", "Pi", 9]], ["Multiply", 2, ["Divide", "Pi", 11]], ["Multiply", 2, ["Divide", "Pi", 3]]])] } function bn(e) { if (e ?? (e = 1), e === 1) { let n = St([["Sqrt", ["Multiply", 6, ["Sum", ["Divide", 1, ["Power", "n", 2]], ["Triple", ["Hold", "n"], 1, { num: "+Infinity" }]]]], "Add", "Add", "Add", "Add", "Add", "Multiply", "Multiply", "Multiply", "Multiply", "Divide", "Divide", "Divide", "Root", "Sqrt", "Subtract", "Negate", "trig"]); return typeof n == "string" ? _u(n, 1) : n } if (e === 2) { let n = Math.random(); if (n > .75) return bn(1); if (n > .5) return bn(3); let i = St(["Multiply", "Multiply", "Add", "Power", "trig", "Ln", "Exp"]); return _u(i, 2) } return St([-12345e-9, -2, -2, -2, -3, -5, -6, -12, -1654e-60, 0, 0, 12345e-8, 1654e-60, 1, 2, 2, 2, 2, 3, 3, 5, 5, 6, 6, 1234.5678, 5678.1234, 10, 15, 18, 30, 60, 1234e54, "123456789.12345678912345e200", "987654321.12345678912345", ["Rational", -6, 10], ["Rational", -12, 15], ["Rational", -15, 12], ["Rational", 3, 5], ["Rational", 12, 15], ["Rational", 15, 12], "ExponentialE", ["Sqrt", 3], ["Sqrt", 5], ["Sqrt", 15], ["Sqrt", 25], ["Complex", -1.1, 1.1], ["Complex", 4, 5], "x", "x", "x", "x", ["Add", "x", 1], ["Divide", "x", 3], ["Square", "x"], ["Power", "x", 3], ["Power", "x", 4], ["Subtract", "x", 1], ["Add", "x", 1], "Pi"]) } var Su = [{ Nothing: { domain: "NothingDomain" } }, { InvisibleOperator: { complexity: 9e3, hold: "all", signature: { restParam: "Anything", result: (e, n) => n.length === 0 ? e.domain("NothingDomain") : n.length === 1 ? n[0].domain : e.Anything, canonical: Br } }, Sequence: { hold: "all", signature: { restParam: "Anything", result: (e, n) => n.length === 0 ? e.domain("NothingDomain") : n.length === 1 ? n[0].domain : e.Anything, canonical: (e, n) => { let i = me(se(n)); return i.length === 0 ? e._fn("Sequence", []) : i.length === 1 ? i[0] : e._fn("Sequence", i) } } }, Delimiter: { complexity: 9e3, hold: "all", signature: { params: ["Anything"], optParams: ["Strings"], result: (e, n) => n[0].domain, canonical: (e, n) => { if (n.length === 0) return e._fn("Tuple", []); let i = n[0]; return i.head === "Sequence" ? i = e._fn("Sequence", e.canonical(i.ops)) : i = i.canonical, i.head === "Sequence" && i.ops.length === 1 && (i = i.ops[0]), n = [i, ...n.slice(1)], n.length === 1 ? e._fn("Delimiter", n) : n.length > 2 ? e._fn("Delimiter", Se(e, n, 2)) : (n[1].string?.length ?? 0) > 3 ? e._fn("Delimiter", [n[0], e.error("invalid-delimiter", n[1])]) : e._fn("Delimiter", [n[0], Fe(e, n[1], "Strings")]) }, evaluate: (e, n) => { if (n.length === 0) return e.Nothing; let i = n[0]; return (i.head === "Sequence" || i.head === "Delimiter") && (n = se(n[0].ops)), n.length === 1 ? n[0].evaluate() : e._fn("Tuple", n.map(t => t.evaluate())) }, N: (e, n) => { if (n.length === 0) return e.Nothing; let i = n[0]; return (i.head === "Sequence" || i.head === "Delimiter") && (n = se(n[0].ops)), n.length === 1 ? n[0].N() : e._fn("Tuple", n.map(t => t.N())) } } }, Error: { hold: "all", complexity: 500, signature: { domain: ["FunctionOf", "Anything", ["OptArg", "Anything"], "Void"], canonical: (e, n) => e._fn("Error", n) } }, ErrorCode: { complexity: 500, hold: "all", signature: { domain: ["FunctionOf", "Strings", ["VarArg", "Anything"], "Anything"], canonical: (e, n) => { let i = Fe(e, n[0], e.Strings).string; return i === "incompatible-domain" ? e._fn("ErrorCode", [e.string(i), n[1], n[2]]) : e._fn("ErrorCode", n) } } }, Hold: { hold: "all", signature: { domain: ["FunctionOf", "Anything", "Anything"], result: (e, n) => { let i = n[0]; return i.symbol ? e.domain("Symbols") : i.string ? e.domain("Strings") : i.head === "Numbers" ? e.domain("Numbers") : i.domain }, canonical: (e, n) => n.length !== 1 ? null : e.hold(n[0]), evaluate: (e, n) => n[0] } }, HorizontalSpacing: { signature: { domain: "Functions", canonical: (e, n) => n.length === 2 ? n[0].canonical : e.box(["Sequence"]) } }, Style: { complexity: 9e3, inert: !0, signature: { domain: ["FunctionOf", "Anything", ["OptArg", "Dictionaries"], "Anything"] } } }, { About: { signature: { domain: "Functions" } }, Head: { hold: "all", signature: { domain: "Functions", canonical: (e, n) => { if (n.length !== 1) return null; let i = n[0]; return i.head ? e.box(i.head) : e._fn("Head", me(n)) }, evaluate: (e, n) => { let i = n[0]; return typeof i?.head == "string" ? e.symbol(i.head) : i?.head ?? e.Nothing } } }, Tail: { hold: "all", signature: { domain: "Functions", canonical: (e, n) => { if (n.length !== 1) return null; let i = n[0]; return i.ops ? e._fn("Sequence", i.ops) : e._fn("Tail", me(n)) }, evaluate: (e, n) => { let i = n[0]; return i?.ops ? e.box(["Sequence", ...i.ops]) : e.box(["Sequence"]) } } }, Identity: { signature: { domain: ["FunctionOf", "Anything", "Anything"], result: (e, n) => n[0].domain, evaluate: (e, n) => n[0] } } }, { Apply: { signature: { domain: "Functions", canonical: (e, n) => n[0].symbol ? e.box([n[0].symbol, ...n.slice(1)]) : e._fn("Apply", n), evaluate: (e, n) => ui(n[0], n.slice(1)) } }, Assign: { hold: "all", pure: !1, signature: { domain: ["FunctionOf", "Anything", "Anything", "Anything"], canonical: (e, n) => { if (n.length !== 2) return null; let i = n[0]; if (!i.symbol) return null; let t = n[1]; return e._fn("Assign", [i, t]) }, evaluate: (e, n) => { let i = n[0], t = n[1]; if (!i.symbol) return e.Nothing; let r = t.evaluate(); return e.assign(i.symbol, r), r } } }, Assume: { hold: "all", pure: !1, signature: { domain: ["FunctionOf", "Anything", "Anything"], evaluate: (e, n) => e.string(e.assume(n[0])) } }, Declare: { hold: "all", pure: !1, signature: { domain: ["FunctionOf", "Symbols", "Anything"], canonical: (e, n) => { if (n.length !== 2) return null; let i = n[0], t = n[1]; return i.symbol ? t.symbol ? e._fn("Declare", n) : e._fn("Declare", [i, e._fn("Hold", [t])]) : null }, evaluate: (e, n) => { let i = n[0], t = n[1]; if (!i.symbol) return e.Nothing; let r = t.evaluate(); if (mn(r)) return e.declare(i.symbol, r), r } } }, Domain: { signature: { domain: ["FunctionOf", "Anything", "Domains"], evaluate: (e, n) => n[0].domain } }, Evaluate: { hold: "all", signature: { domain: ["FunctionOf", "Anything", "Anything"], result: (e, n) => n[0].domain, canonical: (e, n) => e._fn("Evaluate", Se(e, n, 1)), evaluate: (e, n) => n[0].evaluate() } }, Function: { complexity: 9876, hold: "all", signature: { domain: ["FunctionOf", "Anything", ["VarArg", "Symbols"], "Functions"], canonical: (e, n) => n.length === 0 ? e.box(["Sequence"]) : (n.length === 1 ? jo(n[0]) : e._fn("Function", n)) ?? null, evaluate: (e, n) => { } } }, Simplify: { hold: "all", signature: { domain: ["FunctionOf", "Anything", "Anything"], result: (e, n) => n[0].domain, canonical: (e, n) => e._fn("Simplify", Se(e, n, 1)), evaluate: (e, n) => n[0].simplify() } }, CanonicalForm: { complexity: 8200, hold: "all", signature: { domain: ["FunctionOf", "Anything", ["VarArg", "Symbols"], "Anything"], canonical: (e, n) => { if (n.length === 1) return n[0].canonical; let i = n.slice(1).map(t => t.symbol ?? t.string).filter(t => t != null); return yn(n[0], i) } } }, N: { hold: "all", signature: { domain: ["FunctionOf", "Anything", "Anything"], result: (e, n) => n[0].domain, canonical: (e, n) => { if (n.length !== 1) return e._fn("N", Se(e, n, 1)); let i = n[0].head; if (i === "N") return n[0].canonical; if (i === "Integrate") { let [t, r, o] = zn(n[0].op2); if (!t || r === void 0 || o === void 0) return null; let s = n[0].op1; return e._fn("NIntegrate", [e.box(["Function", s, t]), e.number(r), e.number(o)]) } return i === "Limit" ? e._fn("NLimit", n[0].ops) : e._fn("N", n) }, evaluate: (e, n) => n[0].N() } }, Signatures: { signature: { domain: ["FunctionOf", "Symbols", ["ListOf", "Domains"]], canonical: (e, n) => (n = Se(e, n, 1), n[0].symbol ? e._fn("Signatures", n) : e._fn("Signatures", [e.domainError("Symbols", n[0].domain, n[0])])), evaluate: (e, n) => { let i = n[0].symbol; if (!i) return e.Nothing; let t = e.lookupFunction(i); if (!t) return e.box(["List"]); let r = t.signature, o = [...r.params]; return r.optParams.length > 0 && o.push(e._fn("OptArg", r.optParams)), r.restParam && o.push(e._fn("VarArg", [r.restParam])), typeof r.result == "function" ? o.push(r.result(e, []) ?? e.symbol("Undefined")) : o.push(r.result), e.box(["List", ...o]) } } }, Subscript: { hold: "last", signature: { domain: ["FunctionOf", "Anything", "Anything", "Anything"], result: (e, n) => { let i = n[0], t = n[1]; if (i.string && q(t) !== null) return e.domain("Integers"); if (i.symbol) { let r = i.evaluate()?.head; if (r) return e.lookupFunction(r)?.at ? void 0 : e.domain("Symbols") } }, canonical: (e, n) => { let i = n[0], t = n[1]; if (i.string) { let r = q(t); if (r !== null && r > 1 && r <= 36) { let [o, s] = Si(i.string, r); return s ? e.error(["unexpected-digit", { str: s[0] }], ["LatexString", e.string(i.string)]) : e.number(o) } } if (i.symbol) { let r = i.evaluate()?.head; if (r && e.lookupFunction(r)?.at) return e._fn("At", [i.canonical, t.canonical]); let o = t.string ?? t.symbol ?? q(t)?.toString(); if (o) return e.symbol(i.symbol + "_" + o) } return t.head === "Sequence" && e._fn("Subscript", [i, e._fn("List", t.ops)]), e._fn("Subscript", n) } } }, Symbol: { complexity: 500, description: "Construct a new symbol with a name formed by concatenating the arguments", threadable: !0, hold: "all", signature: { domain: ["FunctionOf", ["VarArg", "Anything"], "Anything"], canonical: (e, n) => { if (n.length === 0) return e.Nothing; let i = n.map(t => t.symbol ?? t.string ?? q(t)?.toString() ?? "").join(""); return i.length > 0 ? e.symbol(i) : e.Nothing } } }, Timing: { description: "`Timing(expr)` evaluates `expr` and return a `Pair` of the number of second elapsed for the evaluation, and the value of the evaluation", signature: { domain: ["FunctionOf", "Values", ["OptArg", "Integers"], ["TupleOf", "Values", "Numbers"]], evaluate: (e, n) => { if (n[1].symbol === "Nothing") { let u = globalThis.performance.now(), l = n[0].evaluate(), f = 1e3 * (globalThis.performance.now() - u); return e.pair(e.number(f), l) } let i = Math.max(3, Math.round(q(n[1]) ?? 3)), t = [], r; for (; i > 0;) { let u = globalThis.performance.now(); r = n[0].evaluate(), t.push(1e3 * (globalThis.performance.now() - u)), i -= 1 } let o = Math.max(...t), s = Math.min(...t); t = t.filter(u => u > s && u < o); let a = t.reduce((u, l) => u + l, 0); return a === 0 ? e.pair(e.number(o), r) : e.pair(e.number(a / t.length), r) } } } }, { LatexString: { inert: !0, signature: { domain: ["FunctionOf", "Strings", "Strings"] } }, Latex: { signature: { domain: ["FunctionOf", ["VarArg", "Anything"], "Strings"], evaluate: (e, n) => e.box(["LatexString", e.string(N(n.map(i => i.latex)))]) } }, Parse: { description: "Parse a LaTeX string and evaluate to a corresponding expression", signature: { domain: ["FunctionOf", "Anything", "Anything"], evaluate: (e, n) => { if (n.length === 0) return e.box(["Sequence"]); let i = n[0], t = i.string ?? i.head === "LatexString" ? i.op1.string : ""; return e.parse(t) ?? e.box(["Sequence"]) } } } }, { RandomExpression: { signature: { domain: "Functions", evaluate: (e, n) => e.box(bn()) } } }]; function Br(e, n) { if (n.length === 0) return null; let i = n[0]; if (n.length === 1) return Br(e, [i.canonical]); if (n.length === 2) { let t = E(i); if (t !== null && Number.isInteger(t)) { let o = n[1]; if (o.head === "Divide" || o.head === "Rational") { let [s, a] = [E(o.op1), E(o.op2)]; if (s !== null && a !== null && s > 0 && s <= 1e3 && a > 1 && a <= 1e3 && Number.isInteger(s) && Number.isInteger(a)) return e._fn("Add", [i.canonical, o.canonical]) } } let r = n[1]; if (i.symbol && r.head === "Delimiter" && !e.lookupSymbol(i.symbol)) return e.lookupFunction(i.symbol) || e.declare(i.symbol, "Functions"), r.nops === 0 ? e.box([i.symbol]) : (r = r.op1, r.head === "Sequence" ? e.box([i.symbol, ...e.canonical(r.ops)]) : e.box([i.symbol, r.canonical])) } return n = me(se(n)), n.every(t => t.isValid && (!t.domain || t.domain.isNumeric || sr(t) && !t.string)) ? e._fn("Multiply", te(n, "Multiply")) : e._fn("Tuple", n) } function yn(e, n) { if (n === !1) return e; if (n === !0) return e.canonical; typeof n == "string" && (n = [n]); for (let i of n) switch (i) { case "InvisibleOperator": e = ss(e); break; case "Number": e = Bu(e); break; case "Multiply": e = Du(e); break; case "Add": e = Iu(e); break; case "Power": e = Vi(e); break; case "Divide": e = ku(e); break; case "Flatten": e = Tu(e); break; case "Order": e = Oo(e, { recursive: !0 }); break; default: throw Error("Invalid canonical form") }return e } function Tu(e) { if (!e.ops) return e; let n = e.ops.map(Tu); e.head === "Delimiter" && (n = [Do(e.engine, e.op1)]); let i = e.engine, t = e.head === "Add" || e.head === "Multiply"; return t || i.lookupFunction(e.head)?.commutative && (t = !0), t && typeof e.head == "string" && (e = i._fn(e.head, te(n, e.head))), e } function ss(e) { return e.ops ? e.head === "InvisibleOperator" ? Br(e.engine, e.ops.map(ss)) ?? e : e.engine._fn(e.head, e.ops.map(ss)) : e } function Bu(e) { return e.numericValue ? e.canonical : e.ops ? e.engine._fn(e.head, e.ops.map(Bu)) : e } function Du(e) { if (!e.ops) return e; let n = e.ops.map(Du); return e.head === "Multiply" ? Et(e.engine, n) : e.head === "Negate" ? Et(e.engine, [e.op1, e.engine.NegativeOne]) : e } function Iu(e) { if (!e.ops) return e; let n = e.ops.map(Iu); return e.head === "Add" ? In(e.engine, n) : e.head === "Subtract" ? In(e.engine, [n[0], e.engine.neg(n[1])]) : e.engine._fn(e.head, n) } function Vi(e) { return e.ops ? e.head === "Power" ? kn(e.engine, Vi(e.op1), Vi(e.op2)) : e.ops ? e.engine._fn(e.head, e.ops.map(Vi)) : e : e } function ku(e) { return e.head === "Divide" ? on(e.engine, Vi(e.op1), Vi(e.op2)) : e.ops ? e.engine._fn(e.head, e.ops.map(ku)) : e } function Ir(e, n, i) { if (typeof n == "number" || n instanceof v) return new le(e, n, i); if (i = i ? { ...i } : {}, "canonical" in i || (i.canonical = !0), Array.isArray(n) && n.length === 2 && n[0] instanceof v && n[1] instanceof v) { if (!n[0].isInteger() || !n[1].isInteger()) throw new Error("Array argument to `boxNumber()` should be two integers"); n = [P(n[0].toString()), P(n[1].toString())] } if (U(n)) { if (n.length !== 2) throw new Error("Array argument to `boxNumber()` should be two integers or two bignums"); let [r, o] = n; if (typeof r == "bigint" && typeof o == "bigint") return r === o ? o === BigInt(0) ? e.NaN : e.One : r === BigInt(0) ? e.Zero : o === BigInt(1) ? e.number(r, i) : o === BigInt(-1) ? e.number(-r, i) : r === BigInt(1) && o === BigInt(2) ? e.Half : new le(e, [r, o], i); if (typeof r != "number" || typeof o != "number") throw new Error("Array argument to `boxNumber()` should be two integers or two bignums"); if (!Number.isInteger(r) || !Number.isInteger(o)) throw new Error("Array argument to `boxNumber()` should be two integers"); return o === r ? o === 0 ? e.NaN : e.One : r === 0 ? e.Zero : o === 1 ? e.number(r, i) : o === -1 ? e.number(-r, i) : r === 1 && o === 2 ? e.Half : new le(e, [r, o], i) } if (n instanceof Dr.Complex) return n.isNaN() ? e.NaN : n.isZero() ? e.Zero : n.isInfinite() ? e.ComplexInfinity : e.chop(n.im) === 0 ? e.number(n.re, i) : new le(e, n, i); let t = ""; if (typeof n == "string") t = n; else if (typeof n == "object" && "num" in n) { if (typeof n.num == "number") return e.number(n.num, i); if (typeof n.num != "string") throw new Error("MathJSON `num` property should be a string of digits"); t = n.num } if (t) { if (t = t.toLowerCase(), /[0-9][nd]$/.test(t) && (t = t.slice(0, -1)), t = t.replace(/[\u0009-\u000d\u0020\u00a0]/g, ""), t === "nan") return e.NaN; if (t === "infinity" || t === "+infinity") return e.PositiveInfinity; if (t === "-infinity") return e.NegativeInfinity; if (t === "0") return e.Zero; if (t === "1") return e.One; if (t === "-1") return e.NegativeOne; if (/\([0-9]+\)/.test(t)) { let [r, o, s, a] = t.match(/(.+)\(([0-9]+)\)(.+)?$/) ?? []; t = o + s.repeat(Math.ceil(e.precision / s.length)) + (a ?? "") } return Ir(e, e.bignum(t), i) } return null } function as(e, n, i) { if (n === null) return e.error("missing"); if (typeof n == "object" && n instanceof L) return n; if (n = H(n), typeof n == "string") return we(e, n, i); if (Array.isArray(n)) { let t = n.map(r => as(e, r, i)); return new be(e, t[0], t.slice(1)) } if (typeof n == "object") { if ("dict" in n) return new qi(e, n.dict); if ("fn" in n) return as(e, n.fn, i); if ("str" in n) return new gn(e, n.str); if ("sym" in n) return we(e, n.sym, i); if ("num" in n) return we(e, n.num, i) } return we(e, n, i) } function Tt(e, n, i, t) { if (n === "Hold") return new be(e, "Hold", [as(e, i[0], t)], { ...t, canonical: !0 }); if (n === "Error" || n === "ErrorCode") return e._fn(n, i.map(r => e.box(r, { canonical: !1 })), t.metadata); if (n === "Domain") return e.domain(i[0], t.metadata); if (n === "Number" && i.length === 1) return we(e, i[0], t); if (n === "String") return i.length === 0 ? new gn(e, "", t.metadata) : new gn(e, i.map(r => wu(r) ?? "").join(""), t.metadata); if (n === "Symbol" && i.length > 0) return e.symbol(i.map(r => wu(r) ?? "").join(""), t); if (t.canonical && (n === "Divide" || n === "Rational") && i.length === 2) { if (i[0] instanceof L && i[1] instanceof L) { if (e.numericMode === "machine") { let [s, a] = [E(i[0]), E(i[1])]; if (s !== null && Number.isInteger(s) && a !== null && Number.isInteger(a)) return e.number([s, a], t) } let [r, o] = [lt(i[0]), lt(i[1])]; if (r !== null && o !== null) return e.number([r, o], t) } else { let [r, o] = [To(i[0]), To(i[1])]; if (r !== null && o !== null) return e.number([r, o], t) } n = "Divide" } if (t.canonical && n === "Complex") { if (i.length === 1) { let r = we(e, i[0], t), o = E(r); return o !== null && o !== 0 ? e.number(e.complex(0, o), t) : e.mul(r, e.I) } if (i.length === 2) { let r = we(e, i[0], t), o = we(e, i[1], t), s = E(r), a = E(o); return a !== null && s !== null ? a === 0 && s === 0 ? e.Zero : a !== null && a !== 0 ? e.number(e.complex(s, a), t) : r : e.add(r, e.mul(o, e.I)) } } if (t.canonical && n === "Negate" && i.length === 1) { let r = i[0]; if (typeof r == "number") return e.number(-r, t); if (r instanceof v) return e.number(r.neg(), t); let o = e.box(r, t).numericValue; if (o !== null) { if (typeof o == "number") return e.number(-o, t); if (o instanceof v) return e.number(o.neg(), t); if (o instanceof Dr.Complex) return e.number(o.neg()); if (U(o)) return e.number(_e(o)) } } if (n === "Dictionary") { let r = {}; for (let o of i) { let s = e.box(o, { canonical: t.canonical }), a = s.head; if (a === "KeyValuePair" || a === "Pair" || a === "Tuple" && s.nops === 2) { let u = s.op1; if (u.isValid && !u.isNothing) { let l = s.op2, f = u.symbol ?? u.string; if (!f && (u.numericValue !== null || u.string)) { let d = typeof u.numericValue == "number" ? u.numericValue : q(u); d && Number.isFinite(d) && Number.isInteger(d) && (f = d.toString()) } f && (r[f] = l) } } } return new qi(e, r, t) } if (n === "List" && t.canonical) { let r = i.map(a => we(e, a)), { shape: o, dtype: s } = os("List", r) ?? {}; return s && o ? new _t(e, { head: n, ops: r }) : e._fn(n, r) } return t.canonical ? _r(e, n, i, t.metadata) : new be(e, n, i.map(r => we(e, r, { canonical: !1 })), t) } function we(e, n, i) { if (n == null) return e._fn("Sequence", []); if (n instanceof L) return yn(n, i?.canonical ?? !0); i = i ? { ...i } : {}, "canonical" in i || (i.canonical = !0); let t = i.canonical === !0; if (Array.isArray(n)) { if (J(n)) return Number.isInteger(n[0]) && Number.isInteger(n[1]) ? e.number(n) : yn(Tt(e, "Divide", n, { canonical: t }), i.canonical); if (K(n)) return e.number(n); if (typeof n[0] == "string") return yn(Tt(e, n[0], n.slice(1), { canonical: t }), i.canonical); Array.isArray(n[0]); let r = n.slice(1).map(s => we(e, s, i)), o = we(e, n[0], { canonical: !1 }); return yn(new be(e, o, r), i.canonical) } if (typeof n == "number" || n instanceof Dr.Complex || n instanceof v) return e.number(n); if (typeof n == "string") return n.startsWith("'") && n.endsWith("'") ? new gn(e, n.slice(1, -1)) : /^[+-]?[0-9]/.test(n) ? e.number(n) : ri(n) ? e.domain(n) : Ee(n) ? e.symbol(n, { canonical: t }) : e.error("invalid-identifier", { str: n }); if (typeof n == "object") { let r = { latex: n.latex, wikidata: n.wikidata }; if ("dict" in n) return yn(new qi(e, n.dict, { canonical: !0, metadata: r }), i.canonical); if ("fn" in n) return typeof n.fn[0] == "string" ? yn(Tt(e, n.fn[0], n.fn.slice(1), { canonical: t }), i.canonical) : yn(new be(e, we(e, n.fn[0], i), n.fn.slice(1).map(o => we(e, o, i)), { metadata: r }), i.canonical); if ("str" in n) return new gn(e, n.str, r); if ("sym" in n) return e.symbol(n.sym, { canonical: t }); if ("num" in n) return e.number(n, { canonical: t }) } return e.symbol("Undefined") } function wu(e) { if (typeof e == "string") return e; if (e instanceof L) return e.string ?? e.symbol ?? e.toString(); if (typeof e == "object") { if ("str" in e) return e.str; if ("fn" in e && e.fn[0] === "String" && typeof e.fn[1] == "string") return e.fn[1] } return Array.isArray(e) && e[0] === "String" && typeof e[1] == "string" ? e[1] : null } var ls = pe(ce(), 1); var Au = [{ Abs: { wikidata: "Q3317982", threadable: !0, idempotent: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "NonNegativeNumbers"], simplify: (e, n) => us(e, n[0], "simplify"), evaluate: (e, n) => us(e, n[0], "evaluate"), N: (e, n) => us(e, n[0], "N") } }, Add: { wikidata: "Q32043", associative: !0, commutative: !0, threadable: !0, idempotent: !0, complexity: 1300, hold: "all", signature: { domain: "NumericFunctions", result: (e, n) => nu(e, n.map(i => i.domain)), simplify: (e, n) => pr(e, n.map(i => i.simplify())), evaluate: (e, n) => xt(e, n.map(i => i.evaluate())), N: (e, n) => xt(e, n.map(i => i.N()), "N") } }, Ceil: { description: "Rounds a number up to the next largest integer", complexity: 1250, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Integers"], evaluate: (e, n) => R(n[0], Math.ceil, i => i.ceil(), i => i.ceil(0)) } }, Chop: { associative: !0, threadable: !0, idempotent: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => R(n[0], i => e.chop(i), i => e.chop(i), i => e.chop(i)) } }, Divide: { wikidata: "Q1226939", complexity: 2500, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers", "Numbers"], canonical: (e, n) => { if (n = Pe(e, n, 2), n.length !== 2) return e._fn("Divide", n); let [i, t] = n; return e.div(i, t) }, simplify: (e, n) => Er(e, n[0], n[1]), evaluate: (e, n) => vr(e, n[0], n[1]) } }, Exp: { wikidata: "Q168698", threadable: !0, complexity: 3500, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], canonical: (e, n) => (n = Pe(e, n, 1), n.length !== 1 ? e._fn("Power", [e.E, ...n]) : e.pow(e.E, n[0])) } }, Factorial: { description: "Factorial Function", wikidata: "Q120976", threadable: !0, complexity: 9e3, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], canonical: (e, n) => { let i = n[0]; return i instanceof le && i.isNegative ? e.neg(e._fn("Factorial", [e.neg(i)])) : e._fn("Factorial", [i]) }, evaluate: (e, n) => { let i = q(n[0]); if (i !== null && i >= 0) return F(e) ? e.number(Lo(e, e.bignum(i))) : e.number(er(i)); let t = n[0].numericValue; if (t !== null && t instanceof ls.Complex) return e.number(t.add(1)); let r = E(n[0]); if (r !== null) return e.number(Ti(1 + r)) } } }, Factorial2: { description: "Double Factorial Function", complexity: 9e3, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = q(n[0]); if (i !== null) return F(e) ? e.number(du(e, e.bignum(i))) : e.number(wa(i)) } } }, Floor: { wikidata: "Q56860783", complexity: 1250, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "ExtendedRealNumbers"], evaluate: (e, n) => R(n[0], Math.floor, i => i.floor(), i => i.floor(0)) } }, Gamma: { wikidata: "Q190573", complexity: 8e3, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], N: (e, n) => R(n[0], i => Ti(i), i => Vo(e, i), i => i) } }, GammaLn: { complexity: 8e3, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], N: (e, n) => R(n[0], i => ot(i), i => qo(e, i), i => i) } }, Ln: { description: "Natural Logarithm", wikidata: "Q204037", complexity: 4e3, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], simplify: Mu, evaluate: Mu, N: (e, n) => R(n[0], i => i >= 0 ? Math.log(i) : e.complex(i).log(), i => i.isNeg() ? e.complex(i.toNumber()).log() : i.ln(), i => i.log()) } }, Log: { description: "Log(z, b = 10) = Logarithm of base b", wikidata: "Q11197", complexity: 4100, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", ["OptArg", "Numbers"], "Numbers"], canonical: (e, n) => { if (n.length === 1) return e._fn("Log", [Fe(e, n[0], "Numbers")]); if (n = Pe(e, n, 2), n.length !== 2) return e._fn("Log", n); let [i, t] = n; return t.numericValue === 10 ? e._fn("Log", [i]) : e._fn("Log", [i, t]) }, N: (e, n) => n[1] === void 0 ? R(n[0], i => i >= 0 ? Math.log10(i) : e.complex(i).log().div(Math.LN10), i => i.isNeg() ? e.complex(i.toNumber()).log().div(Math.LN10) : v.log10(i), i => i.log().div(Math.LN10)) : Vn(n[0], n[1], (i, t) => Math.log(i) / Math.log(t), (i, t) => i.log(t), (i, t) => i.log().div(typeof t == "number" ? Math.log(t) : t.log())) } }, Lb: { description: "Base-2 Logarithm", wikidata: "Q581168", complexity: 4100, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], N: (e, n) => R(n[0], i => i >= 0 ? Math.log2(i) : e.complex(i).log().div(Math.LN2), i => i.isNeg() ? v.log10(i) : e.complex(i.toNumber()).log().div(Math.LN2), i => i.log().div(Math.LN2)) } }, Lg: { description: "Base-10 Logarithm", wikidata: "Q966582", complexity: 4100, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], N: (e, n) => R(n[0], i => i >= 0 ? Math.log10(i) : e.complex(i).log().div(Math.LN10), i => i.isNeg() ? e.complex(i.toNumber()).log().div(Math.LN10) : v.log10(i), i => i.log().div(Math.LN10)) } }, Mod: { description: "Modulo", wikidata: "Q1799665", complexity: 2500, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers", "Numbers"], evaluate: (e, n) => { if (n.length !== 2) return; let [i, t] = n, r = i.value, o = t.value; if (typeof r == "number" && typeof o == "number") return e.number((r % o + o) % o) } } }, Multiply: { wikidata: "Q40276", associative: !0, commutative: !0, idempotent: !0, complexity: 2100, hold: "all", threadable: !0, signature: { domain: "NumericFunctions", simplify: (e, n) => yu(e, n.map(i => i.simplify())), evaluate: (e, n) => vt(e, n.map(i => i.evaluate())), N: (e, n) => vt(e, n.map(i => i.N()), "N") } }, Negate: { description: "Additive Inverse", wikidata: "Q715358", complexity: 2e3, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], result: (e, n) => { let i = n[0].domain; if (!i?.base) return i; let t = { PositiveNumbers: "NegativeNumbers", NonNegativeNumbers: "NonPositiveNumbers", NonPositiveNumbers: "NonNegativeNumbers", NegativeNumbers: "PositiveNumbers", PositiveIntegers: "NegativeIntegers", NonNegativeIntegers: "NonPositiveIntegers", NonPositiveIntegers: "NonNegativeIntegers", NegativeIntegers: "PositiveIntegers" }[i.base]; return t ? e.domain(t) : i }, canonical: (e, n) => (n = Pe(e, n), n.length !== 1 ? e._fn("Negate", n) : e.neg(n[0])), simplify: (e, n) => gr(e, n[0], "simplify"), evaluate: (e, n) => gr(e, n[0], "evaluate"), N: (e, n) => gr(e, n[0], "N"), sgn: (e, n) => { let i = n[0].sgn; if (i != null) { if (i === 0) return 0; if (i > 0) return -1; if (i < 0) return 1 } } } }, PlusMinus: { description: "Plus or Minus", wikidata: "Q120812", complexity: 1200, involution: !0, signature: { domain: ["FunctionOf", "Values", "Tuples"], evaluate: (e, n) => { if (n.length === 1) return e.box(["Pair", n[0], e.neg(n[0])]) } } }, Power: { wikidata: "Q33456", commutative: !1, threadable: !0, complexity: 3500, signature: { domain: ["FunctionOf", "Numbers", "Numbers", "Numbers"], canonical: (e, n) => { if (n = Pe(e, n, 2), n.length !== 2) return e._fn("Power", n); let [i, t] = n; return i instanceof le && i.isNegative ? e.neg(e.pow(i, t)) : e.pow(i, t) }, simplify: (e, n) => si(e, n[0], n[1], "simplify"), evaluate: (e, n) => si(e, n[0], n[1], "evaluate"), N: (e, n) => e.numericMode === "machine" && typeof n[0].numericValue == "number" && typeof n[1].numericValue == "number" ? e.number(Math.pow(n[0].numericValue, n[1].numericValue)) : si(e, n[0], n[1], "N") } }, Rational: { complexity: 2400, signature: { domain: ["FunctionOf", "Numbers", ["OptArg", "Numbers"], "RationalNumbers"], canonical: (e, n) => (n = me(se(n)), n.length === 0 ? e._fn("Rational", [e.error("missing")]) : n.length === 1 ? e._fn("Rational", [Fe(e, n[0], "ExtendedRealNumbers")]) : (n = ar(e, n, ["Integers", "Integers"]), n.length !== 2 || !n[0].isValid || !n[1].isValid ? e._fn("Rational", n) : e.div(n[0], n[1]))), simplify: (e, n) => { if (n.length === 2) return Er(e, n[0], n[1]) }, evaluate: (e, n) => { if (n.length === 2) { let [t, r] = [q(n[0]), q(n[1])]; return t !== null && r !== null ? e.number([t, r]) : void 0 } let i = E(n[0].N()); if (i !== null) return e.number(La(i)) }, N: (e, n) => n.length === 1 ? n[0] : Vn(n[0], n[1], (i, t) => i / t, (i, t) => i.div(t), (i, t) => i.div(t)) } }, Root: { complexity: 3200, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers", "Numbers"], canonical: (e, n) => { n = Pe(e, n, 2); let [i, t] = n; return n.length !== 2 || !i.isValid || !t.isValid ? e._fn("Root", n) : e.pow(i, e.inv(t)) } } }, Round: { complexity: 1250, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => R(n[0], Math.round, i => i.round(), i => i.round(0)) } }, Sign: { complexity: 1200, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Integers"], simplify: (e, n) => { let i = n[0].sgn; if (i === 0) return e.Zero; if (i === 1) return e.One; if (i === -1) return e.NegativeOne }, evaluate: (e, n) => { let i = n[0].sgn; if (i === 0) return e.Zero; if (i === 1) return e.One; if (i === -1) return e.NegativeOne }, N: (e, n) => { let i = n[0].sgn; if (i === 0) return e.Zero; if (i === 1) return e.One; if (i === -1) return e.NegativeOne } } }, Sqrt: { description: "Square Root", wikidata: "Q134237", complexity: 3e3, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], canonical: (e, n) => (n = me(se(n)), n.length !== 1 ? e._fn("Sqrt", n) : e.pow(n[0], e.Half)), simplify: (e, n) => Ri(e, n[0], "simplify"), evaluate: (e, n) => Ri(e, n[0], "evaluate"), N: (e, n) => Ri(e, n[0], "N") } }, Square: { wikidata: "Q3075175", complexity: 3100, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], canonical: (e, n) => (n = me(se(n)), n.length !== 1 ? e._fn("Square", n) : e._fn("Power", [n[0], e.number(2)]).canonical) } }, Subtract: { wikidata: "Q40754", complexity: 1350, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", ["OptArg", "Numbers"], "Numbers"], canonical: (e, n) => { if (n.length === 1) { let r = Fe(e, n[0], "Numbers"); if (r.isValid) return ge(r) } n = Pe(e, n, 2); let [i, t] = n; return n.length !== 2 || !i.isValid || !t.isValid ? e._fn("Subtract", n) : In(e, te([i, ge(t)], "Add")) } } } }, {
      e: { domain: "TranscendentalNumbers", constant: !0, holdUntil: "never", value: "ExponentialE" }, i: { domain: "ImaginaryNumbers", constant: !0, holdUntil: "never", flags: { imaginary: !0 }, value: "ImaginaryUnit" }, MachineEpsilon: { domain: "RealNumbers", holdUntil: "N", constant: !0, flags: { real: !0 }, value: { num: Number.EPSILON.toString() } }, Half: { domain: "RationalNumbers", constant: !0, holdUntil: "evaluate", value: ["Rational", 1, 2] }, ImaginaryUnit: { domain: "ImaginaryNumbers", constant: !0, holdUntil: "evaluate", wikidata: "Q193796", flags: { imaginary: !0 }, value: ["Complex", 0, 1] }, ExponentialE: { domain: "TranscendentalNumbers", flags: { algebraic: !1, real: !0 }, wikidata: "Q82435", constant: !0, holdUntil: "N", value: e => F(e) ? e._BIGNUM_ONE.exp() : Math.exp(1) }, GoldenRatio: { domain: "AlgebraicNumbers", wikidata: "Q41690", constant: !0, flags: { algebraic: !0 }, holdUntil: "simplify", value: ["Divide", ["Add", 1, ["Sqrt", 5]], 2] }, CatalanConstant: {
        domain: "RealNumbers", flags: { algebraic: void 0 }, wikidata: "Q855282", constant: !0, holdUntil: "N", value: {
          num: `0.91596559417721901505460351493238411077414937428167
                  21342664981196217630197762547694793565129261151062
                  48574422619196199579035898803325859059431594737481
                  15840699533202877331946051903872747816408786590902
                  47064841521630002287276409423882599577415088163974
                  70252482011560707644883807873370489900864775113225
                  99713434074854075532307685653357680958352602193823
                  23950800720680355761048235733942319149829836189977
                  06903640418086217941101917532743149978233976105512
                  24779530324875371878665828082360570225594194818097
                  53509711315712615804242723636439850017382875977976
                  53068370092980873887495610893659771940968726844441
                  66804621624339864838916280448281506273022742073884
                  31172218272190472255870531908685735423498539498309
                  91911596738846450861515249962423704374517773723517
                  75440708538464401321748392999947572446199754961975
                  87064007474870701490937678873045869979860644874974
                  64387206238513712392736304998503539223928787979063
                  36440323547845358519277777872709060830319943013323
                  16712476158709792455479119092126201854803963934243
                  `}
      }, EulerGamma: {
        domain: "RealNumbers", flags: { algebraic: void 0 }, wikidata: "Q273023", holdUntil: "N", constant: !0, value: {
          num: `0.57721566490153286060651209008240243104215933593992359880576723488486772677766
          467093694706329174674951463144724980708248096050401448654283622417399764492353
          625350033374293733773767394279259525824709491600873520394816567085323315177661
          152862119950150798479374508570574002992135478614669402960432542151905877553526
          733139925401296742051375413954911168510280798423487758720503843109399736137255
          306088933126760017247953783675927135157722610273492913940798430103417771778088
          154957066107501016191663340152278935867965497252036212879226555953669628176388
          792726801324310104765059637039473949576389065729679296010090151251959509222435
          014093498712282479497471956469763185066761290638110518241974448678363808617494
          551698927923018773910729457815543160050021828440960537724342032854783670151773
          943987003023703395183286900015581939880427074115422278197165230110735658339673`}
      }
    }, { PreIncrement: { signature: { domain: ["FunctionOf", "Numbers", "Numbers"] } }, PreDecrement: { signature: { domain: ["FunctionOf", "Numbers", "Numbers"] } } }, { GCD: { description: "Greatest Common Divisor", complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", ["VarArg", "Anything"], "Numbers"], evaluate: (e, n) => Cu(e, n, "GCD") } }, LCM: { description: "Least Common Multiple", complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", ["VarArg", "Anything"], "Numbers"], evaluate: (e, n) => Cu(e, n, "LCM") } }, Numerator: { description: "Numerator of an expression", complexity: 1200, threadable: !0, hold: "all", signature: { domain: ["FunctionOf", "Anything", "Numbers"], canonical: (e, n) => { if (n.length === 0) return e.box(["Sequence"]); let i = n[0]; if (i.head === "Rational" || i.head === "Divide") return i.op1; let t = W(i); return t !== void 0 ? e.number(t[0]) : e._fn("Numerator", me(n)) }, evaluate: (e, n) => { if (n.length === 0) return e.box(["Sequence"]); let i = n[0]; if (i.head === "Rational" || i.head === "Divide") return i.op1.evaluate(); let t = W(i.evaluate()); return t !== void 0 ? e.number(t[0]) : e._fn("Numerator", n.map(r => r.evaluate())) } } }, Denominator: { description: "Denominator of an expression", complexity: 1200, threadable: !0, hold: "all", signature: { domain: ["FunctionOf", "Anything", "Numbers"], canonical: (e, n) => { if (n.length === 0) return e.box(["Sequence"]); let i = n[0]; if (i.head === "Rational" || i.head === "Divide") return i.op2; let t = W(i); return t !== void 0 ? e.number(t[1]) : e._fn("Denominator", me(n)) }, evaluate: (e, n) => { if (n.length === 0) return e.box(["Sequence"]); let i = n[0]; if (i.head === "Rational" || i.head === "Divide") return i.op2.evaluate(); let t = W(i.evaluate()); return t !== void 0 ? e.number(t[1]) : e._fn("Denominator", n.map(r => r.evaluate())) } } }, NumeratorDenominator: { description: "Sequence of Numerator and Denominator of an expression", complexity: 1200, threadable: !0, hold: "all", signature: { domain: ["FunctionOf", "Anything", "Anything"], canonical: (e, n) => { if (n.length === 0) return e.box(["Sequence"]); let i = n[0]; if (i.head === "Rational" || i.head === "Divide") return e._fn("Sequence", i.ops); let t = W(i.evaluate()); return t !== void 0 ? e._fn("Sequence", [e.number(t[0]), e.number(t[1])]) : e._fn("NumeratorDenominator", n.map(r => r.evaluate())) }, evaluate: (e, n) => { if (n.length === 0) return e.box(["Sequence"]); let i = n[0]; if (i.head === "Rational" || i.head === "Divide") return e._fn("Sequence", i.ops); let t = W(i); return t !== void 0 ? e._fn("Sequence", [e.number(t[0]), e.number(t[1])]) : e._fn("NumeratorDenominator", me(n)) } } } }, { Max: { description: "Maximum of two or more numbers", complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", ["VarArg", "Values"], "Numbers"], simplify: (e, n) => n.length === 0 ? e.NegativeInfinity : n.length === 1 ? n[0] : e.box(["Max", ...n]), evaluate: (e, n) => kr(e, n, "Max") } }, Min: { description: "Minimum of two or more numbers", complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", ["VarArg", "Values"], "Numbers"], simplify: (e, n) => n.length === 0 ? e.PositiveInfinity : n.length === 1 ? n[0] : e.box(["Min", ...n]), evaluate: (e, n) => kr(e, n, "Min") } }, Supremum: { description: "Like Max, but defined for open sets", complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", ["VarArg", "Values"], "Numbers"], simplify: (e, n) => n.length === 0 ? e.NegativeInfinity : n.length === 1 ? n[0] : e.box(["Min", ...n]), evaluate: (e, n) => kr(e, n, "Supremum") } }, Infimum: { description: "Like Min, but defined for open sets", complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", ["VarArg", "Values"], "Numbers"], simplify: (e, n) => n.length === 0 ? e.PositiveInfinity : n.length === 1 ? n[0] : e.box(["Min", ...n]), evaluate: (e, n) => kr(e, n, "Infimum") } }, Product: { wikidata: "Q901718", complexity: 1e3, hold: "all", threadable: !1, signature: { domain: ["FunctionOf", "Anything", ["OptArg", "Tuples"], "Numbers"], canonical: (e, n) => Eu(e, n[0], n[1]), simplify: (e, n) => Nr(e, n, "simplify"), evaluate: (e, n) => Nr(e, n, "evaluate"), N: (e, n) => Nr(e, n, "N") } }, Sum: { wikidata: "Q218005", complexity: 1e3, hold: "all", threadable: !1, signature: { domain: ["FunctionOf", ["Union", "Collections", "Functions"], ["OptArg", "Tuples"], "Numbers"], canonical: (e, n) => iu(e, n[0], n[1]), simplify: (e, n) => hr(e, n, "simplify"), evaluate: (e, n) => hr(e, n, "evaluate"), N: (e, n) => hr(e, n, "N") } } }, { BaseForm: { description: "`BaseForm(expr, base=10)`", complexity: 9e3, inert: !0, signature: { domain: ["FunctionOf", "Values", ["OptArg", "Integers"], "Values"], result: (e, n) => n[0].domain } }, FromDigits: { description: "`FromDigits(s, base=10)`       return an integer representation of the string `s` in base `base`.", signature: { domain: ["FunctionOf", "Strings", ["OptArg", "Anything"], "Integers"], evaluate: (e, n) => { let i = n[0]?.string; if (!i) return e.domainError("Strings", n[0]?.domain, n[0]); if (i = i.trim(), i.startsWith("0x")) return e.number(parseInt(i.slice(2), 16)); if (i.startsWith("0b")) return e.number(parseInt(i.slice(2), 2)); let t = n[1] ?? e.Nothing; if (t.isNothing) return e.number(Number.parseInt(i, 10)); let r = E(t); if (r && (!Number.isInteger(r) || r < 2 || r > 36)) return e.error(["unexpected-base", r], t); let [o, s] = Si(i, t.string ?? t.symbol ?? 10); return s ? e.error(["unexpected-digit", { str: s[0] }], { str: s }) : e.number(o) } } }, IntegerString: { description: "`IntegerString(n, base=10)`       return a string representation of the integer `n` in base `base`.", threadable: !0, signature: { domain: ["FunctionOf", "Integers", ["OptArg", "Integers"], "Strings"], evaluate: (e, n) => { let i = n[0], t = E(i) ?? NaN; if (Number.isNaN(t) || !Number.isInteger(t)) return e.domainError("Integers", i.domain, i); let r = n[1] ?? e.Nothing; if (r.isNothing) { let s = i.numericValue; return typeof s == "number" ? e.string(Math.abs(s).toString()) : s instanceof v ? e.string(s.abs().toString()) : e.string(Math.abs(Math.round(E(i) ?? NaN)).toString()) } if (q(r) === null) return e.domainError("Integers", r.domain, r); let o = q(r); return o < 2 || o > 36 ? e.error(["out-of-range", 2, 36, o], r) : e.string(Math.abs(t).toString(o)) } } } }]; function us(e, n, i) { if (i !== "simplify") { let t = n.numericValue; if (t !== null) { if (typeof t == "number") return e.number(Math.abs(t)); if (t instanceof v || t instanceof ls.Complex) return e.number(t.abs()); if (J(t)) return e.number(i === "N" ? Math.abs(t[0] / t[1]) : [Math.abs(t[0]), t[1]]); if (K(t)) { let [r, o] = t; return e.number(i === "N" ? e.bignum(r).div(e.bignum(o)).abs() : [r > 0 ? r : -r, o]) } } } if (n.isNonNegative) return n; if (n.isNegative) return e.neg(n) } function Ou(e, n) { let i = e.engine, t = n === "Max" || n === "Supremum"; if (e.head === "Interval") { let r = t ? e.op2 : e.op1; return !r.isNumber || r.numericValue === void 0 ? [void 0, [e]] : [r, []] } if (e.head === "Range") { if (e.nops === 1) e = t ? e.op1 : i.One; else if (!t) e = e.op1; else { let r = e.nops === 2 ? 1 : E(e.op3); if (r === null || !isFinite(r)) return [void 0, [e]]; let [o, s] = [E(e.op1), E(e.op2)]; if (o === null || s === null) return [void 0, [e]]; let a = Math.floor((s - o) / r); e = i.number(o + r * a) } return [e, []] } if (e.head === "Linspace") return e.nops === 1 ? e = t ? e.op1 : i.One : t ? e = e.op2 : e = e.op1, [e, []]; if (wi(e)) { let r, o = []; for (let s of X(e)) { let [a, u] = Ou(s, n); a && (r ? (t && a.isGreater(r) || !t && a.isLess(r)) && (r = a) : r = a), o.push(...u) } return [r, o] } return !e.isNumber || e.numericValue === void 0 ? [void 0, [e]] : [e, []] } function kr(e, n, i) { let t = i === "Max" || i === "Supremum"; if (n.length === 0) return t ? e.NegativeInfinity : e.PositiveInfinity; let r, o = []; for (let s of n) { let [a, u] = Ou(s, i); a && (r ? (t && a.isGreater(r) || !t && a.isLess(r)) && (r = a) : r = a), o.push(...u) } return o.length > 0 ? e.box(r ? [i, r, ...o] : [i, ...o]) : r ?? (t ? e.NegativeInfinity : e.PositiveInfinity) } function Cu(e, n, i) { let t = i === "LCM" ? Kt : Sn, r = i === "LCM" ? fu : Ro, o = []; if (F(e)) { let a = null; for (let u of n) if (a === null) a = Ge(u), (a === null || !a.isInteger()) && o.push(u); else { let l = Ge(u); l && l.isInteger() ? a = r(a, l) : o.push(u) } return o.length === 0 ? a === null ? e.One : e.number(a) : a === null ? e._fn(i, o) : e._fn(i, [e.number(a), ...o]) } let s = null; for (let a of n) if (s === null) s = E(a), (s === null || !Number.isInteger(s)) && o.push(a); else { let u = E(a); u && Number.isInteger(u) ? s = t(s, u) : o.push(a) } return o.length === 0 ? s === null ? e.One : e.number(s) : s === null ? e._fn(i, o) : e._fn(i, [e.number(s), ...o]) } function Mu(e, n) { let i = n[0]; if (i.isZero) return e.NaN; if (i.isOne) return e.Zero; if (i.isNegativeOne && ae(e)) return e.mul(e.Pi, e.I); if (i.symbol === "ExponentialE") return e.One; if (i.head === "Power" && i.op1.symbol === "ExporentialE") return i.op2; if (i.head === "Power") { let [t, r] = i.ops; return e.mul(r, e.box(["Ln", t]).simplify()) } if (i.head === "Multiply") { let [t, r] = i.ops; return e.add(e.box(["Ln", t]).simplify(), e.box(["Ln", r]).simplify()) } if (i.head === "Divide") { let [t, r] = i.ops; return e.add(e.box(["Ln", t]).simplify(), e.neg(e.box(["Ln", r]).simplify())) } } var _d = { Sin: ["Cos", "_"], Cos: ["Negate", ["Sin", "_"]], Tan: ["Power", ["Sec", "_"], 2], Sec: ["Multiply", ["Tan", "_"], ["Sec", "_"]], Csc: ["Multiply", ["Negate", ["Cot", "_"]], ["Csc", "_"]], Cot: ["Negate", ["Power", ["Csc", "_"], 2]], Arcsin: ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]], Arccos: ["Negate", ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]]], Arctan: ["Power", ["Add", 1, ["Power", "_", 2]], -1], Arcsec: ["Multiply", ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]], ["Negate", ["Power", "_", 2]]], Arccsc: ["Multiply", ["Power", ["Subtract", 1, ["Power", "_", 2]], ["Negate", "Half"]], ["Negate", ["Power", "_", 2]]], Arccot: ["Negate", ["Power", ["Add", 1, ["Power", "_", 2]], -1]], Sinh: ["Cosh", "_"], Cosh: ["Sinh", "_"], Tanh: ["Power", ["Sech", "_"], 2], Sech: ["Multiply", ["Tanh", "_"], "Sech"], Csch: ["Multiply", ["Coth", "_"], "Csch"], Coth: ["Negate", ["Power", ["Csch", "_"], 2]], Arcsinh: ["Power", ["Add", ["Power", "_", 2], 1], ["Negate", "Half"]], Arccosh: ["Power", ["Subtract", ["Power", "_", 2], 1], ["Negate", "Half"]], Arctanh: ["Power", ["Subtract", 1, ["Power", "_", 2]], -1], Arcsech: ["Negate", ["Power", ["Multiply", "2", "Subtract", ["Power", "_", 2]], ["Negate", "Half"]]], Arccsch: ["Negate", ["Power", ["Multiply", "2", "Add", ["Power", "_", 2]], ["Negate", "Half"]]], Arccoth: ["Negate", ["Power", ["Subtract", 1, ["Power", "_", 2]], -1]], Ln: ["Divide", 1, "_"], Log: ["Power", ["Multiply", "_", ["Ln", "10"]], -1], Sqrt: ["Multiply", ["Power", "_", ["Negate", "Half"]], "Half"], Abs: ["Piecewise", ["Tuple", ["Multiply", "_", ["Power", "_", -1]], ["Greater", "_", 0]]], Erf: ["Multiply", ["Divide", "2", ["Sqrt", "Pi"]], ["Exp", ["Negate", ["Square", "_"]]]], Gamma: ["Multiply", ["Gamma", "_"], ["Digamma", "_"]], Digamma: ["Add", ["Multiply", ["Digamma", "_"], ["Gamma", "_"]], ["Multiply", ["Power", "_", -1], ["Gamma", "_"]]], Zeta: ["Multiply", ["Multiply", -1, ["Zeta", "_"]], ["Digamma", "_"]], PolyGamma: ["Add", ["Multiply", ["PolyGamma", "_"], ["Gamma", "_"]], ["Multiply", ["Power", "_", -1], ["Gamma", "_"]]], Beta: ["Multiply", ["Add", ["Multiply", ["Beta", "_"], ["Digamma", "_"]], ["Multiply", ["Power", "_", -1], ["Beta", "_"]]], ["Beta", "_"]], Erfc: ["Multiply", ["Negate", ["Erfc", "_"]], ["Exp", ["Negate", ["Power", "_", 2]]], ["Power", "_", -1]], LambertW: ["Multiply", ["Power", "_", -1], ["Multiply", ["Add", "_", ["LambertW", "_"]], ["Add", ["LambertW", "_"], 1]]], AiryAi: ["Multiply", ["AiryAi", "_"], ["AiryBi", "_"]], AiryBi: ["Multiply", ["AiryAi", "_"], ["AiryBi", "_"]], BesselJ: ["Multiply", ["BesselJ", "_"], ["BesselY", "_"]], BesselY: ["Multiply", ["BesselJ", "_"], ["BesselY", "_"]], BesselI: ["Multiply", ["BesselI", "_"], ["BesselK", "_"]], BesselK: ["Multiply", ["BesselI", "_"], ["BesselK", "_"]], FresnelS: ["Multiply", ["FresnelS", "_"], ["FresnelC", "_"]], FresnelC: ["Multiply", ["FresnelS", "_"], ["FresnelC", "_"]], Erfi: ["Multiply", ["Erfi", "_"], ["Erf", "_"]] }; function qe(e, n) { let i = e.engine; if (!(e.string || e.keys)) { if (e.numericValue !== null) return e.engine.Zero; if (e.symbol === n) return e.engine.One; if (e.symbol) return e.engine.Zero; if (e.head && typeof e.head == "string") { if (e.head === "Negate") { let s = qe(e.op1, n); return s ? i.neg(s) : i.neg(i._fn("D", [e.op1, i.symbol(n)])) } if (e.head === "Add") { let s = e.ops.map(a => qe(a, n)); return s.some(a => a === void 0) ? void 0 : i.add(...s) } if (e.head === "Multiply") { let s = e.ops.map((a, u) => { let l = e.ops.slice(); l.splice(u, 1); let f = i.mul(...l), d = qe(a, n) ?? i._fn("D", [a, i.symbol(n)]); return i.mul(d, f) }); return s.some(a => a === void 0) ? void 0 : i.add(...s) } if (e.head === "Power") { let [s, a] = e.ops; if (s.symbol === n) return i.mul(a, i.pow(s, i.add(a, i.NegativeOne))); let u = s, l = a, f = qe(u, n) ?? i._fn("D", [u, i.symbol(n)]), d = qe(l, n) ?? i._fn("D", [l, i.symbol(n)]), c = i.box(["Ln", u]).evaluate(), m = i.mul(d, c), g = i.mul(l, f), h = i.div(g, u); return i.mul(e, i.add(m, h)) } if (e.head === "Divide") { let [s, a] = e.ops, u = qe(s, n) ?? i._fn("D", [s, i.symbol(n)]), l = qe(a, n) ?? i._fn("D", [a, i.symbol(n)]); return i.div(i.add(i.mul(u, a), i.neg(i.mul(l, s))), i.pow(a, 2)) } let t = _d[e.head]; if (!t) { if (e.nops > 1) return; let s = i._fn("Derivative", [i.symbol(e.head), i.One]); if (!s.isValid) return; let a = e.ops[0], u = qe(a, n) ?? i._fn("D", [a, i.symbol(n)]); return u.isValid ? i.mul(i._fn("Apply", [s, a]), u) : void 0 } if (e.nops > 1) return i._fn("D", [e, i.symbol(n)]); let r = e.ops[0], o = qe(r, n) ?? i._fn("D", [r, i.symbol(n)]); return i.mul(ui(i.box(t), [r]), o) } } } var Pu = [{ Derivative: { hold: "all", threadable: !1, signature: { domain: ["FunctionOf", "Functions", ["OptArg", "Numbers"], "Functions"], canonical: (e, n) => n[0].functionDefinition ? qe(e._fn(n[0].canonical, [e.symbol("_")]), "_")?.canonical ?? e._fn("Derivative", n) : e._fn("Derivative", n), simplify: (e, n) => { let i = n[0].simplify(); return n[1] ? e._fn("Derivative", [i, n[1]]) : e._fn("Derivative", [i]) }, evaluate: (e, n) => { let i = n[0].evaluate(); if (i.functionDefinition) return qe(e._fn(i, [e.symbol("_")]), "_")?.canonical ?? void 0; let t = qe(i, "_"); if (t) return t.canonical } } }, D: { hold: "all", threadable: !1, signature: { domain: ["FunctionOf", "Anything", "Symbols", ["VarArg", "Symbols"], "Anything"], canonical: (e, n) => { let i = n[0]; if (!i) return null; e.pushScope(); let t = n.slice(1); i.bind(), i = i.canonical; let r = e._fn("D", [i, ...t]); return e.popScope(), r }, evaluate: (e, n) => { let i = n[0].canonical, t = e.swapScope(i.scope); i = i.evaluate(); let r = n.slice(1); r.length === 0 && (i = void 0); for (let o of r) { if (!o.symbol) { i = void 0; break } if (i = qe(i, o.symbol), i === void 0) break } return e.swapScope(t), i = i?.canonical, i?.head === "D" ? i : i?.evaluate() } } }, ND: { hold: "first", threadable: !1, signature: { domain: ["FunctionOf", "Anything", "Numbers", "Functions"], N: (e, n) => { let i = n[1]?.value; if (typeof i != "number") return; let t = Ho(e.box(n[0])); return e.number(Ma(t, i)) } } }, Integrate: { wikidata: "Q80091", hold: "all", threadable: !1, signature: { domain: ["FunctionOf", "Functions", ["OptArg", ["Union", "Tuples", "Symbols"]], "Numbers"], canonical: (e, n) => { let i = n[1], t = null, r = null, o = null; i && i.head !== "Tuple" && i.head !== "Triple" && i.head !== "Pair" && i.head !== "Single" ? t = i : i && (t = i.ops?.[0] ?? null, r = i.ops?.[1]?.canonical ?? null, o = i.ops?.[2]?.canonical ?? null), t && t.head === "Hold" && (t = t.op1), t && t.head === "ReleaseHold" && (t = t.op1.evaluate()), t ?? (t = e.Nothing), t.symbol || (t = e.domainError("Symbols", t.domain, t)), r && (r = Fe(e, r, e.Numbers)), o && (o = Fe(e, o, e.Numbers)), r && o ? i = e.tuple([t, r, o]) : o ? i = e.tuple([t, e.NegativeInfinity, o]) : r ? i = e.tuple([t, r]) : i = t; let s = n[0] ?? e.error("missing"); return s = s.canonical, s.head === "Delimiter" && s.op1.head === "Sequence" && (s = s.op1.op1), e._fn("Integrate", [s, i]) } } }, NIntegrate: { hold: "first", threadable: !1, signature: { domain: ["FunctionOf", "Functions", "Numbers", "Numbers", "Numbers"], evaluate: (e, n) => { let i = e.numericMode, t = e.precision; e.numericMode = "machine"; let r = Ho(n[0]), [o, s] = n.slice(1).map(u => u.value), a; return typeof o == "number" && typeof s == "number" && (a = e.number(Aa(r, o, s))), e.numericMode = i, e.precision = t, a } } } }, { Limit: { description: "Limit of a function", complexity: 5e3, hold: "all", threadable: !1, signature: { domain: ["FunctionOf", "Anything", "Numbers", ["OptArg", "Numbers"], "Numbers"], N: (e, n) => { let [i, t, r] = n, o = E(t.N()); if (o === null) return; let s = li(i); return e.number(Kn(a => { let u = s([e.number(a)])?.value; return typeof u == "number" ? u : Number.NaN }, o, r ? E(r) ?? 1 : 1)) } } }, NLimit: { description: "Numerical approximation of the limit of a function", complexity: 5e3, hold: "all", threadable: !1, signature: { domain: ["FunctionOf", "Anything", "Numbers", ["OptArg", "Numbers"], "Numbers"], evaluate: (e, n) => { let [i, t, r] = n, o = E(t.N()); if (o === null) return; let s = li(i); return e.number(Kn(a => { let u = s([e.number(a)])?.value; return typeof u == "number" ? u : Number.NaN }, o, r ? E(r) ?? 1 : 1)) } } } }]; var wr = 50, Ru = { List: { complexity: 8200, hold: "all", signature: { domain: ["FunctionOf", ["VarArg", "Anything"], "Lists"], canonical: Td }, size: e => e.nops, iterator: (e, n, i) => { let t = n ?? 1; return i = Math.min(i ?? e.nops, e.nops), i <= 0 ? { next: () => ({ value: void 0, done: !0 }) } : { next: () => i > 0 ? (i--, { value: e.ops[t++ - 1], done: !1 }) : { value: void 0, done: !0 } } }, at: (e, n) => { if (typeof n == "number" && !(n < 1 || n > e.nops)) return e.ops[n - 1] }, indexOf: (e, n, i) => { if (i ?? (i = 1), i < 0) { if (i < -e.nops) return; i = e.nops + i + 1; let r = i; for (let o = r; o >= 1; o--)if (e.ops[o - 1].isEqual(n)) return o; return } let t = i; for (let r = t; r <= e.nops; r++)if (e.ops[r - 1].isEqual(n)) return r } }, Range: { complexity: 8200, signature: { domain: ["FunctionOf", "Numbers", ["OptArg", "Numbers", "Numbers"], "Values"] }, size: e => { let [n, i, t] = Ar(e); return !isFinite(n) || !isFinite(i) ? 1 / 0 : 1 + Math.max(0, Math.floor((i - n) / t)) }, at: (e, n) => { if (typeof n != "number") return; let [i, t, r] = Ar(e); if (!(n < 1 || n > 1 + (t - i) / r)) return e.engine.number(i + r * (n - 1)) }, iterator: (e, n, i) => { let [t, r, o] = Ar(e), s = n ?? 1; return i = Math.min(i ?? r, r), i <= 0 ? { next: () => ({ value: void 0, done: !0 }) } : { next: () => i > 0 ? (i--, { value: e.engine.number(t + o * (s++ - 1)), done: !1 }) : { value: void 0, done: !0 } } } }, Linspace: { complexity: 8200, signature: { domain: ["FunctionOf", "Numbers", ["OptArg", "Numbers", "Numbers"], "Values"] }, size: e => { let n = E(e.op3) ?? wr; return Math.max(0, Math.floor(n)) }, at: (e, n) => { if (typeof n != "number") return; let i = E(e.op1), t = E(e.op2), r = E(e.op3) ?? wr; if (!(i === void 0 || t === void 0) && !(n < 1 || n > r)) return e.engine.number(i + (t - i) * (n - 1) / r) }, iterator: (e, n, i) => { let t = E(e.op1), r = E(e.op2), o; r === void 0 ? (r = t, t = 1, o = wr) : o = Math.max(0, E(e.op3) ?? wr); let s = n ?? 1; return i = Math.min(i ?? o, o), i <= 0 ? { next: () => ({ value: void 0, done: !0 }) } : { next: () => i > 0 ? (i--, { value: e.engine.number(t + (r - t) * (s++ - 1) / o), done: !1 }) : { value: void 0, done: !0 } } } }, KeyValuePair: { description: "A key/value pair", complexity: 8200, signature: { domain: ["FunctionOf", "Strings", "Anything", "Tuples"], canonical: (e, n) => { let [i, t] = ar(e, n, [e.Strings, "Values"]); return !i.isValid || !t.isValid ? e._fn("KeyValuePair", [i, t]) : e.tuple([i, t]) } }, size: e => 1 }, Single: { description: "A tuple with a single element", complexity: 8200, signature: { domain: ["FunctionOf", "Anything", "Tuples"], canonical: (e, n) => e.tuple(Se(e, n, 1)) }, size: e => e.nops, at: (e, n) => { if (!(typeof n != "number" || n !== 1)) return e.ops[0] } }, Pair: { description: "A tuple of two elements", complexity: 8200, signature: { domain: ["FunctionOf", "Anything", "Anything", "Tuples"], canonical: (e, n) => e.tuple(Se(e, n, 2)) }, size: e => e.nops, at: (e, n) => typeof n == "number" ? e.ops[n - 1] : void 0 }, Triple: { description: "A tuple of three elements", complexity: 8200, signature: { domain: ["FunctionOf", "Anything", "Anything", "Anything", "Tuples"], canonical: (e, n) => e.tuple(Se(e, n, 3)) }, size: e => e.nops, at: (e, n) => typeof n == "number" ? e.ops[n - 1] : void 0 }, Tuple: { description: "A fixed number of heterogeneous elements", complexity: 8200, signature: { domain: ["FunctionOf", "Anything", ["VarArg", "Anything"], "Tuples"], canonical: (e, n) => e.tuple(me(n)) }, size: e => e.nops, at: (e, n) => typeof n == "number" ? e.ops[n - 1] : void 0 }, String: { threadable: !0, signature: { domain: ["FunctionOf", ["OptArg", "Anything"], "Strings"], evaluate: (e, n) => n.length === 0 ? e.string("") : e.string(n.map(i => i.string ?? i.toString()).join("")) } }, Length: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Numbers"], evaluate: (e, n) => { let i = n[0].functionDefinition; if (i?.size) return e.number(i.size(n[0])); let t = n[0].string; return t !== null ? e.number(t.length) : e.Zero } } }, IsEmpty: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Numbers"], evaluate: (e, n) => { let i = n[0].functionDefinition, t; if (i?.size) t = i.size(n[0]); else { let r = n[0].string; r !== null && (t = r.length) } if (t !== void 0) return t === 0 ? e.True : e.False } } }, Take: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["VarArg", "Values"], "Values"], evaluate: (e, n) => { if (n.length < 2) return; let i = n[0].string; if (i !== null) { let o = n.slice(1).map(s => Cr(s, i.length)); return e.string(Sd(i, o)) } let r = n[0].functionDefinition?.size?.(n[0]); return Mr(n[0], n.slice(1).map(o => Cr(o, r))) } } }, Drop: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["VarArg", "Values"], "Values"], evaluate: (e, n) => { if (n.length < 2) return; let i = n[0].string; if (i !== null) { let a = Fu(n.slice(1).map(u => Cr(u, i.length))); return e.string(i.split("").filter((u, l) => !a.includes(l + 1)).join("")) } let t = n[0].functionDefinition, r = t?.size?.(n[0]); if (!r || !t?.at) return e.Nothing; let o = Fu(n.slice(1).map(a => Cr(a, r))), s = []; for (let a = 1; a <= r; a++)if (!o.includes(a)) { let u = t.at(n[0], a); u && s.push(u) } return e.box(["List", ...s]) } } }, At: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values", "Values"], evaluate: (e, n) => { let i = n[0], t = i.functionDefinition; if (!t?.at) return; if (n[1].string !== null) return t.at(i, 1) ?? e.Nothing; let o = E(n[1]); if (!(o === null || !Number.isInteger(o))) return t.at(i, o) ?? e.Nothing } } }, First: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0], t = i.functionDefinition; return t?.at ? t.at(i, 1) ?? e.Nothing : e.Nothing } } }, Second: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0], t = i.functionDefinition; return t?.at ? t.at(i, 2) ?? e.Nothing : e.Nothing } } }, Last: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0], t = i.functionDefinition; return t?.at ? t.at(i, -1) ?? e.Nothing : e.Nothing } } }, Rest: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => Mr(n[0], [[2, -1, 1]]) } }, Most: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => Mr(n[0], [[1, -2, 1]]) } }, Reverse: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => Mr(n[0], [[-1, 2, 1]]) } }, Ordering: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["OptArg", "Functions"], "Values"], evaluate: (e, n) => { } } }, Sort: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["OptArg", "Functions"], "Values"], evaluate: (e, n) => { } } }, Shuffle: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { } } }, Map: { complexity: 8200, signature: { domain: ["FunctionOf", "Collections", "Functions", "Collections"], evaluate: (e, n) => { } } }, Filter: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Functions", "Values"], evaluate: (e, n) => { } } }, Reduce: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Functions", ["OptArg", "Values"], "Values"], evaluate: (e, n) => { } } }, Tabulate: { complexity: 8200, signature: { domain: ["FunctionOf", "Functions", "Integers", ["VarArg", "Integers"], "Values"], evaluate: (e, n) => { } } }, Tally: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Tuples"], evaluate: (e, n) => { } } }, Unique: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Tuples"], evaluate: (e, n) => { } } }, Zip: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["VarArg", "Values"], "Values"], evaluate: (e, n) => { } } }, RotateLeft: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["OptArg", "Integers"], "Values"], evaluate: (e, n) => { } } }, RotateRight: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["OptArg", "Integers"], "Values"], evaluate: (e, n) => { } } }, Join: { complexity: 8200, signature: { domain: ["FunctionOf", ["VarArg", "Values"], "Values"], evaluate: (e, n) => { } } }, Iterate: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["OptArg", "Values"], "Values"], evaluate: (e, n) => { } } }, Repeat: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { } } }, Cycle: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { } } }, Fill: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { } } } }; function Ar(e) { let n = E(e.op1) ?? 1, i = E(e.op2); if (i === void 0) return [1, n, 1]; let t = E(e.op3) ?? 1; return [n, i, t] } function Cr(e, n) { if (!e) return [0, 0, 0]; let i = E(e); if (i !== null) { if (i = Math.round(i), i < 0) { if (n === void 0) return [0, 0, 0]; i = n + i + 1 } return [i, i, 1] } let t = e.head; if (!t || typeof t != "string" || !/^(Single|Pair|Triple|Tuple|)$/.test(t)) return [0, 0, 0]; let [r, o, s] = Ar(e); return (r < 0 || o < 0) && n === void 0 ? [0, 0, 0] : (r < 0 && (r = n + r + 1), o < 0 && (o = n + o + 1), s = Math.abs(Math.round(s)), s === 0 ? [0, 0, 0] : (r > o && (s = -s), [r, o, s])) } function Mr(e, n) { let i = e.engine, t = e.functionDefinition; if (!t?.at) return i.Nothing; let r = []; for (let o of n) { let [s, a, u] = o; if (u !== 0) if (u < 0) for (let l = s; l >= a; l += u) { let f = t.at(e, l); f && r.push(f) } else for (let l = s; l <= a; l += u) { let f = t.at(e, l); f && r.push(f) } } return i.box(["List", ...r]) } function Sd(e, n) { let i = ""; for (let t of n) { let [r, o, s] = t; if (s === 1) i += e.slice(r - 1, o); else if (s < 0) for (let a = r; a >= o; a += s)i += e[a - 1]; else for (let a = r; a <= o; a += s)i += e[a - 1] } return i } function Fu(e) { let n = []; for (let i of e) { let [t, r, o] = i; if (o !== 0) if (o < 0) for (let s = t; s >= r; s += o)n.push(s); else for (let s = t; s <= r; s += o)n.push(s) } return n } function Td(e, n) { let i = n[0]; if (n.length === 1 && i.head === "Matrix") { let [t, r, o] = i.ops; if (!r || r.string === "..") return o ? e._fn("Matrix", [t, e.string("[]"), o]) : e._fn("Matrix", [t, r]) } return n = n.map(t => t.head === "Delimiter" ? t.op1.head === "Sequence" ? e.box(["List", ...me(t.op1.ops)]) : e.box(["List", t.op1?.canonical ?? e.Nothing]) : t.canonical), e.box(["List", ...n]) } var Lu = [{ Block: { hold: "all", signature: { domain: "Functions", canonical: kd, evaluate: Id } }, If: { hold: "rest", signature: { domain: "Functions", result: (e, n) => Un(n[0], n[1]), evaluate: (e, n) => { let i = n[0]; return i && i.symbol === "True" ? n[1] ? n[1].evaluate() : e.Nothing : n[2] ? n[2].evaluate() : e.Nothing } } }, Loop: { hold: "all", signature: { domain: "Functions", evaluate: (e, n) => { let i = n[0] ?? e.Nothing; if (i.isNothing) return i; let t = n[1]; if (t && wi(t)) { let o, s = li(i), a = 0; for (let u of X(t)) { if (o = s([u]) ?? e.Nothing, o.head === "Break") return o.op1; if (o.head === "Return") return o; if (a++ > e.iterationLimit) return e.error("iteration-limit-exceeded") } } let r = 0; for (; ;) { let o = i.evaluate(); if (o.head === "Break") return o.op1; if (o.head === "Return") return o; if (r++ > e.iterationLimit) return e.error("iteration-limit-exceeded") } } } }, Which: { hold: "all", signature: { domain: "Functions", result: (e, n) => Bd(e, n), evaluate: (e, n) => Dd(e, n, "evaluate") } }, FixedPoint: { hold: "all", signature: { domain: "Functions" } } }]; function Bd(e, n) { let i = null; for (let t = 1; t <= n.length - 1; t += 2)i = Un(i, n[t].domain); return i ?? e.domain("NothingDomain") } function Dd(e, n, i) { let t = 0; for (; t < n.length - 1;) { if (n[t].evaluate().symbol === "True") return n[t + 1] ? i === "N" ? n[t + 1].N() : n[t + 1].evaluate() : e.symbol("Undefined"); t += 2 } return e.symbol("Undefined") } function Id(e, n) { if (n.length === 0) return e.Nothing; e.resetContext(); let i; for (let t of n) { let r = t.head; if (r === "Return") { i = t.op1.evaluate(); break } if (r === "Break" || r === "Continue") { i = e.box([r, t.op1.evaluate()]); break } i = t.evaluate() } return i ?? e.Nothing } function kd(e, n) { if (n.length === 0) return null; e.pushScope(); let i = [], t = []; for (let o of n) o.head === "Declare" ? i.push(o) : t.push(qu(o)); let r = e._fn("Block", [...i, ...t]); return e.popScope(), r } function qu(e) { return e.head === "Declare" && e.engine.error("unexpected-declare"), e.ops ? e.engine._fn(e.head, e.ops.map(qu)) : e } var Vu = [{ Real: { threadable: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = n[0].numericValue; if (i !== null) return e.isComplex(i) ? e.number(i.re) : n[0] } } }, Imaginary: { threadable: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = n[0].numericValue; if (i !== null) return e.isComplex(i) ? e.number(i.im) : e.Zero } } }, Argument: { threadable: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = n[0].numericValue; if (i === null) return; if (e.isComplex(i)) return e.number(i.arg()); let t = E(n[0]); if (t !== null) return t >= 0 ? e.Zero : e.Pi } } }, AbsArg: { threadable: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "Tuples"], evaluate: (e, n) => { let i = n[0].numericValue; if (i === null) return; if (e.isComplex(i)) return e.tuple([e.number(i.abs()), e.number(i.arg())]); let t = E(n[0]); if (t !== null) return e.tuple([e.number(Math.abs(t)), e.number(t >= 0 ? 0 : Math.PI)]) } } }, Conjugate: { threadable: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = n[0].numericValue; if (!(i === null || !e.isComplex(i))) return e.number(i.conjugate()) } } }, ComplexRoots: { threadable: !0, complexity: 1200, signature: { domain: ["FunctionOf", "Numbers", "Numbers", "Lists"], evaluate: (e, n) => { let i = E(n[0]), t = E(n[1]); if (i === null || t === null || !Number.isInteger(t) || t <= 0) return; let r = [], [o, s] = e.isComplex(i) ? [i.re, i.im] : [i, 0], a = Math.atan2(s, o), u = Math.sqrt(o * o + s * s); for (let l = 0; l < t; l++) { let f = (a + 2 * Math.PI * l) / t, d = Math.pow(u, 1 / t); r.push([d * Math.cos(f), d * Math.sin(f)]) } return e.box(["List", ...r.map(l => e.number(l[1] !== 0 ? e.complex(l[0], l[1]) : l[0]))]) } } } }]; var $u = [{ Matrix: { complexity: 9e3, hold: "all", signature: { params: ["Lists"], optParams: ["Strings", "Strings"], result: "Lists", canonical: wd, evaluate: (e, n) => n[0].evaluate(), N: (e, n) => n[0].N() } }, Vector: { complexity: 9e3, hold: "all", signature: { restParam: "Anything", result: "Lists", canonical: (e, n) => e._fn("Matrix", [e.box(["List", ...e.canonical(n).map(i => e.box(["List", i]))])]) } } }, { Shape: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Tuples"], evaluate: (e, n) => { let i = n[0]; return Le(i) ? e.tuple(i.tensor.shape) : e.tuple([]) } } }, Rank: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Numbers"], evaluate: (e, n) => { let i = n[0]; return Le(i) ? e.number(i.tensor.rank) : e.Zero } } }, Reshape: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Tuples", "Values"], evaluate: (e, n) => { let i = n[0], t = n[1].ops?.map(r => r.value) ?? []; if (!Le(i) && ue(i) && (i = e.box(["List", ...X(i)])), Le(i)) return i.tensor.reshape(...t).expression } } }, Flatten: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0]; if (Le(i)) return e.box(["List", ...i.tensor.flatten().map(t => e.box(t))]); if (ue(i)) return e.box(["List", ...X(i)]) } } }, Transpose: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", ["OptArg", "Numbers", "Numbers"], "Values"], evaluate: (e, n) => { let i = n[0], t = 1, r = 2; if (n.length === 3 && (t = n[1].value, r = n[2].value, t > 0 && r > 0), t !== r && (!Le(i) && ue(i) && (i = e.box(["List", ...X(i)])), Le(i))) return t === 1 && r === 2 ? i.tensor.transpose()?.expression : i.tensor.transpose(t, r)?.expression } } }, ConjugateTranspose: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0], t = 1, r = 2; if (n.length === 3 && (t = n[1].value, r = n[2].value, t > 0 && r > 0), t !== r && Le(i)) return i.tensor.conjugateTranspose(t, r)?.expression } } }, Determinant: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0]; if (Le(i)) return i.tensor.determinant() } } }, Inverse: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0]; if (Le(i)) return i.tensor.inverse()?.expression } } }, PseudoInverse: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0]; if (Le(i)) return i.tensor.pseudoInverse()?.expression } } }, AdjugateMatrix: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0]; if (Le(i)) return i.tensor.adjugateMatrix()?.expression } } }, Trace: { complexity: 8200, signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0]; if (Le(i)) return i.tensor.trace() } } } }]; function wd(e, n, i = "Matrix") { if (n.length === 0) return e._fn(i, []); let t = n[0].head === "Vector" ? n[0].canonical.ops[0] : n[0].canonical, r = n[1]?.canonical, o = n[2]?.canonical; return n.length > 3 ? e._fn(i, Se(e, n, 3)) : o ? e._fn(i, [t, r, o]) : r ? e._fn(i, [t, r]) : e._fn(i, [t]) } var Hu = { True: { wikidata: "Q16751793", domain: "Booleans", constant: !0 }, False: { wikidata: "Q5432619", domain: "Booleans", constant: !0 }, And: { wikidata: "Q191081", threadable: !0, associative: !0, commutative: !0, idempotent: !0, complexity: 1e4, signature: { domain: "LogicOperators", simplify: zu, evaluate: zu } }, Or: { wikidata: "Q1651704", threadable: !0, associative: !0, commutative: !0, idempotent: !0, complexity: 1e4, signature: { domain: "LogicOperators", simplify: Uu, evaluate: Uu } }, Not: { wikidata: "Q190558", threadable: !0, involution: !0, complexity: 10100, signature: { domain: "LogicOperators", simplify: Gu, evaluate: Gu } }, Equivalent: { wikidata: "Q220433", threadable: !0, complexity: 10200, signature: { domain: "LogicOperators", canonical: (e, n) => { let i = n[0].symbol, t = n[1].symbol; return i === "True" && t === "True" || i === "False" && t === "False" ? e.True : i === "True" && t === "False" || i === "False" && t === "True" ? e.False : e._fn("Equivalent", n) }, simplify: ju, evaluate: ju } }, Implies: { wikidata: "Q7881229", threadable: !0, complexity: 10200, signature: { domain: "LogicOperators", simplify: Zu, evaluate: Zu } }, Exists: { signature: { domain: "Functions" } } }; function zu(e, n) { if (n.length === 0) return e.True; let i = []; for (let t of n) { if (t.symbol === "False") return e.False; if (t.symbol !== "True") { let r = !1; for (let o of i) if (o.isSame(t)) r = !0; else if (t.head === "Not" && t.op1.isSame(o) || o.head === "Not" && o.op1.isSame(t)) return e.False; r || i.push(t) } } return i.length === 0 ? e.True : i.length === 1 ? i[0] : e._fn("And", i) } function Uu(e, n) { if (n.length === 0) return e.True; let i = []; for (let t of n) { if (t.symbol === "True") return e.True; if (t.symbol !== "False") { let r = !1; for (let o of i) if (o.isSame(t)) r = !0; else if (t.head === "Not" && t.op1.isSame(o) || o.head === "Not" && o.op1.isSame(t)) return e.True; r || i.push(t) } } return i.length === 0 ? e.True : i.length === 1 ? i[0] : e._fn("Or", i) } function Gu(e, n) { let i = n[0]?.symbol; if (i === "True") return e.False; if (i === "False") return e.True } function ju(e, n) { let i = n[0].symbol, t = n[1].symbol; if (i === "True" && t === "True" || i === "False" && t === "False") return e.True; if (i === "True" && t === "False" || i === "False" && t === "True") return e.False } function Zu(e, n) { let i = n[0].symbol, t = n[1].symbol; if (i === "True" && t === "True" || i === "False" && t === "False" || i === "False" && t === "True") return e.True; if (i === "True" && t === "False") return e.False } var Ju = [{ Expand: { description: "Expand out products and positive integer powers", signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => rn(n[0]) ?? n[0] } }, ExpandAll: { description: "Recursively expand out products and positive integer powers", signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => Po(n[0]) ?? n[0] } }, Factor: { description: "Factors an algebraic expression into a product of irreducible factors", signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => Xa(n[0]) } }, Together: { description: "Combine rational expressions into a single fraction", signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => oi(n[0]) } }, Distribute: { description: "Distribute multiplication over addition", signature: { domain: ["FunctionOf", "Values", "Values"], evaluate: (e, n) => { let i = n[0].head; if (i === "Multiply") return Pi(n[0].ops) ?? n[0]; if (i === "Negate") return Pi([e.NegativeOne, ...n[0].ops]) ?? n[0]; if (i === "Divide" && n[0].ops[0].head === "Multiply") { let t = Pi(n[0].ops), r = n[0].ops[1]; if (t) return t.head === "Add" ? e.add(...t.ops.map(o => e.div(o, r))).evaluate() : e.div(t, r).evaluate() } return n[0] } } } }]; var Wu = { Congruent: { commutative: !1, complexity: 11e3, numeric: !0, signature: { simplify: (e, n) => { if (!(n.length < 3)) return e._fn("Equal", [e.box(["Mod", n[0], n[2]]).simplify(), e.box(["Mod", n[1], n[2]]).simplify()]).simplify() }, evaluate: (e, n) => { if (n.length < 3) return; let [i, t, r] = n, o = i.value, s = t.value, a = r.value; if (typeof o == "number" && typeof s == "number" && typeof a == "number") return o % a === s % a ? e.True : e.False } } }, IsSame: { description: "Compare two expressions for structural equality", hold: "all", signature: { domain: "RelationalOperators", evaluate: (e, n) => { if (n.length !== 2) return; let [i, t] = n; return i.isSame(t) === !0 ? e.True : e.False } } }, Equal: { commutative: !0, complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "Equal", n), evaluate: (e, n) => { if (n.length < 2) return e.True; let i; for (let t of n) if (!i) i = t; else if (i.isEqual(t) !== !0) return e.False; return e.True } } }, NotEqual: { wikidata: "Q28113351", commutative: !0, complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "NotEqual", n), evaluate: (e, n) => { if (n.length < 2) return e.False; let i; for (let t of n) if (!i) i = t; else if (i.isEqual(t) === !0) return e.False; return e.True } } }, Less: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "Less", n), evaluate: (e, n) => { if (n.length < 2) return e.True; let i; for (let t of n) { if (!t.isNumber) return; if (!i) i = t; else { let r = e.box(["Subtract", t, i]).N().sgn; if (r == null) return; if (r <= 0) return e.False; i = t } } return e.True } } }, NotLess: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "Less", n)]) } }, Greater: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "Less", n.reverse()), evaluate: (e, n) => { if (n.length < 2) return e.True; let i; for (let t of n) { if (!t.isNumber) return; if (!i) i = t; else { let r = e.box(["Subtract", t, i]).N().sgn; if (r == null) return; if (r >= 0) return e.False; i = t } } return e.True } } }, NotGreater: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [e._fn("Greater", n)]) } }, LessEqual: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "LessEqual", n), evaluate: (e, n) => { if (n.length < 2) return e.True; let i; for (let t of n) { if (!t.isNumber) return; if (!i) i = t; else { let r = e.box(["Subtract", t, i]).N().sgn; if (r == null) return; if (r < 0) return e.False; i = t } } return e.True } } }, NotLessNotEqual: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "LessEqual", n)]) } }, GreaterEqual: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "LessEqual", n.reverse()), evaluate: (e, n) => { if (n.length < 2) return e.True; let i; for (let t of n) { if (!t.isNumber) return; if (!i) i = t; else { let r = e.box(["Subtract", t, i]).N().sgn; if (r == null) return; if (r > 0) return e.False; i = t } } return e.True } } }, NotGreaterNotEqual: { complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "GreaterEqual", n)]) } }, TildeFullEqual: { description: "Indicate isomorphism, congruence and homotopic equivalence", signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "TildeFullEqual", n) } }, NotTildeFullEqual: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "TildeFullEqual", n)]) } }, TildeEqual: { description: "Approximately or asymptotically equal", complexity: 11e3, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "TildeEqual", n) } }, NotTildeEqual: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "TildeEqual", n)]) } }, Approx: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "Approx", n) } }, NotApprox: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "Approx", n)]) } }, ApproxEqual: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "ApproxEqual", n) } }, NotApproxEqual: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "ApproxEqual", n)]) } }, ApproxNotEqual: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "ApproxNotEqual", n) } }, NotApproxNotEqual: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "ApproxNotEqual", n)]) } }, Precedes: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "Precedes", n) } }, NotPrecedes: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "Precedes", n)]) } }, Succeeds: { signature: { domain: "RelationalOperators", canonical: (e, n) => fe(e, "Succeeds", n) } }, NotSucceeds: { complexity: 11100, signature: { domain: "RelationalOperators", canonical: (e, n) => e._fn("Not", [fe(e, "Succeeds", n)]) } } }; function fe(e, n, i) { i = te(se(me(i)), n); let t = [], r = []; for (let o of i) Cd(o) ? (t.push(o), r.push(o.ops[o.ops.length - 1])) : r.push(o); return r = r.map(o => ja(e, o)), t.length === 0 ? e._fn(n, r) : e._fn("And", [e._fn(n, r), ...t]) } function Cd(e) { return typeof e.head == "string" && /Equal|NotEqual|Less|NotLess|Greater|NotGreater|LessEqual|NotLessNotEqual|GreaterEqual|NotGreater|NotEqual|TildeFullEqual|NotTildeFullEqual|TildeEqual|NotTildeEqual|Approx|NotApprox|ApproxEqual|NotApproxEqual|ApproxNotEqual|NotApproxNotEqual|Precedes|NotPrecedes|Succeeds|NotSucceeds/.test(e.head) } var Yu = { EmptySet: { domain: "Sets", constant: !0, wikidata: "Q226183" }, Element: { complexity: 11200, hold: "all", signature: { domain: "Predicates", canonical: (e, n) => (n = Se(e, n, 2), n.length === 2 && n[0].isValid && mn(n[1]) ? e._fn("Element", [n[0], e.domain(n[1])]) : e._fn("Element", n)), evaluate: (e, n) => Pd(e, n) } }, NotElement: { complexity: 11200, hold: "all", signature: { domain: "Predicates", canonical: (e, n) => e.box(["Not", ["Element", ...n]]) } }, Subset: { complexity: 11200, signature: { domain: "Predicates" } }, NotSubset: { complexity: 11200, signature: { domain: "Predicates", canonical: (e, n) => e.box(["Not", ["Subset", ...n]]) } }, Superset: { complexity: 11200, signature: { domain: "Predicates" } }, SupersetEqual: { complexity: 11200, signature: { domain: "Predicates" } }, NotSuperset: { complexity: 11200, signature: { domain: "Predicates", canonical: (e, n) => e.box(["Not", ["Superset", ...n]]) } }, NotSupersetEqual: { complexity: 11200, signature: { domain: "Predicates", canonical: (e, n) => e.box(["Not", ["SupersetEqual", ...n]]) } }, SubsetEqual: { complexity: 11200, signature: { domain: "Predicates" } }, NotSubsetNotEqual: { complexity: 11200, signature: { domain: "Predicates", canonical: (e, n) => e.box(["Not", ["SubsetEqual", ...n]]) } }, CartesianProduct: { wikidata: "Q173740", signature: { domain: ["FunctionOf", "Sets", ["VarArg", "Sets"], "Sets"] } }, Complement: { wikidata: "Q242767", signature: { domain: ["FunctionOf", "Sets", "Sets"] } }, Intersection: { wikidata: "Q185837", associative: !0, commutative: !0, involution: !0, signature: { domain: ["FunctionOf", "Collections", ["VarArg", "Collections"], "Sets"], canonical: (e, n) => n.length === 0 || n.length === 1 ? e.symbol("EmptySet") : e._fn("Intersection", n), evaluate: Ad } }, Union: { wikidata: "Q185359", associative: !0, commutative: !0, involution: !0, signature: { domain: ["FunctionOf", "Collections", ["VarArg", "Collections"], "Sets"], canonical: (e, n) => n.length === 0 ? e.symbol("EmptySet") : e._fn("Union", n), evaluate: Md } }, SetMinus: { wikidata: "Q18192442", signature: { domain: ["FunctionOf", "Sets", "Values", "Sets"], evaluate: Od } }, SymmetricDifference: { wikidata: "Q1147242", signature: { domain: ["FunctionOf", "Sets", ["VarArg", "Sets"], "Sets"] } } }; function Md(e, n) { let i = []; for (let t of n) if (ue(t)) for (let r of X(t)) i.every(o => !o.isEqual(r)) && i.push(r); else i.every(r => !r.isEqual(t)) && i.push(t); return i.length === 0 ? e.symbol("EmptySet") : e._fn("Set", i) } function Ad(e, n) { let i = n[0].ops ?? []; for (let t of n.slice(1)) ue(t) ? i = i.filter(r => [...X(t)].some(o => r.isEqual(o))) : i = i.filter(r => r.isEqual(t)); return i.length === 0 ? e.symbol("EmptySet") : e._fn("Set", i) } function Od(e, n) { return e.symbol("EmptySet") } function Pd(e, n) { n.length; let [i, t] = n; if (t.string) return i.string && t.string.includes(i.string) ? e.True : e.False; if (t.keys) { if (i.string) { for (let r of t.keys) if (r === i.string) return e.True } return e.False } if (t.head === "List") { if (i.head === "List") { let o = !1; for (let s = 0; s < 1 + (t.nops - i.nops); ++s) { o = !0; for (let a = 0; a < i.nops; ++a)if (!t.ops[s + a].isEqual(i.ops[a])) { o = !1; break } if (o) return e.True } return e.False } let r = i.head === "Hold" ? i.op1 : i; for (let o of t.ops) if (r.isEqual(o)) return e.True; return e.False } return mn(t) && i.domain ? i.domain.isCompatible(e.domain(t)) ? e.True : e.False : e._fn("Element", [i, t]) } var Qu = [{ Mean: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = 0, t = 0; for (let r of X(n[0])) { let o = E(r); if (o === null) return; i += o, t++ } return t === 0 ? e.NaN : e.number(i / t) } } }, Median: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = []; for (let r of X(n[0])) { let o = E(r); if (o === null) return; i.push(o) } if (i.length === 0) return e.NaN; i.sort((r, o) => r - o); let t = Math.floor(i.length / 2); return i.length % 2 === 0 ? e.number((i[t - 1] + i[t]) / 2) : e.number(i[t]) } } }, Variance: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = 0, t = 0, r = 0; for (let o of X(n[0])) { let s = E(o); if (s === null) return; i += s, t += s * s, r++ } return r === 0 ? e.NaN : e.number((t - i * i / r) / (r - 1)) } } }, StandardDeviation: { complexity: 1200, threadable: !1, description: "Sample Standard Deviation of a collection of numbers.", signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = 0, t = 0, r = 0; for (let o of X(n[0])) { let s = E(o); if (s === null) return; i += s, t += s * s, r++ } return r === 0 ? e.NaN : e.number(Math.sqrt((t - i * i / r) / (r - 1))) } } }, Kurtosis: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = 0, t = 0, r = 0, o = 0; for (let u of X(n[0])) { let l = E(u); if (l === null) return; i += l, t += l * l, r += l * l * l * l, o++ } if (o === 0) return e.NaN; let s = (t - i * i / o) / (o - 1), a = (r - t * t / o) / (o - 1); return e.number((a / (s * s) - 3) * (o * (o + 1)) / 6) } } }, Skewness: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = 0, t = 0, r = 0, o = 0; for (let u of X(n[0])) { let l = E(u); if (l === null) return; i += l, t += l * l, r += l * l * l, o++ } if (o === 0) return e.NaN; let s = (t - i * i / o) / (o - 1), a = (r - t * i / o) / (o - 1); return e.number(a / Math.pow(s, 3 / 2) * Math.sqrt(o * 1)) } } }, Mode: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = []; for (let s of X(n[0])) { let a = E(s); if (a === null) return; i.push(a) } if (i.length === 0) return e.NaN; i.sort((s, a) => s - a); let t = {}; for (let s of i) t[s] = (t[s] ?? 0) + 1; let r = 0, o = i[0]; for (let s of i) { let a = t[s]; a > r && (r = a, o = s) } return e.number(o) } } }, Quartiles: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Lists"], evaluate: (e, n) => { let i = []; for (let s of X(n[0])) { let a = E(s); if (a === null) return; i.push(a) } if (i.length === 0) return e.NaN; i.sort((s, a) => s - a); let t = Math.floor(i.length / 2), r = i.slice(0, t), o = i.slice(t + 1); return e.box(["List", e.number(i[t]), e.number(r[Math.floor(r.length / 2)]), e.number(o[Math.floor(o.length / 2)])]) } } }, InterquartileRange: { complexity: 1200, threadable: !1, signature: { domain: ["FunctionOf", "Collections", "Numbers"], evaluate: (e, n) => { let i = []; for (let s of X(n[0])) { let a = E(s); if (a === null) return; i.push(a) } if (i.length === 0) return e.NaN; i.sort((s, a) => s - a); let t = Math.floor(i.length / 2), r = i.slice(0, t), o = i.slice(t + 1); return e.number(o[Math.floor(o.length / 2)] - r[Math.floor(r.length / 2)]) } } }, Erf: { complexity: 7500, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = E(n[0]); if (i !== null) return e.number(So(i)) } } }, Erfc: { complexity: 7500, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = E(n[0]); if (i !== null) return e.number(1 - So(i)) } } }, ErfInv: { complexity: 7500, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], evaluate: (e, n) => { let i = E(n[0]); if (i !== null) return e.number(Ca(i)) } } } }]; var Cn = e => ["FunctionOf", "Numbers", "ExtendedRealNumbers"], Or = e => ["FunctionOf", "Numbers", "Numbers"], Hn = e => ["FunctionOf", "Numbers", "Numbers"], Xu = [{ Pi: { domain: "TranscendentalNumbers", flags: { algebraic: !1 }, constant: !0, holdUntil: "N", wikidata: "Q167", value: e => F(e) ? e._BIGNUM_PI : Math.PI } }, { Degrees: { signature: { domain: ["FunctionOf", "Numbers", "Numbers"], canonical: (e, n) => { if (n = Pe(e, n, 1), n.length !== 1) return e._fn("Degrees", n); let i = n[0]; if (i.numericValue === null || !i.isValid) return e._fn("Degrees", n); let t = E(i); if (t !== null) { if (t = t % 360, t < 0 && (t += 360), Number.isInteger(t)) { let r = je([t, 180]); return r[0] === 0 ? e.Zero : r[0] === 1 && r[1] === 1 ? e.Pi : r[0] === 1 ? e.div(e.Pi, e.number(r[1])) : e.mul(e.number(r), e.Pi) } return e.mul(e.div(e.number(t), e.number(180)), e.Pi) } return e.div(e.mul(i, e.Pi), e.number(180)) }, evaluate: (e, n) => e.mul(n[0], e.div(e.Pi, e.number(180))).evaluate() } }, Hypot: { threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers", "NonNegativeNumbers"], simplify: (e, n) => e.box(["Sqrt", ["Add", ["Square", n[0]], ["Square", n[1]]]]).simplify(), evaluate: ["Function", ["Sqrt", ["Add", ["Square", "_1"], ["Square", "_2"]]]] } }, Sin: { complexity: 5e3, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], simplify: (e, n) => Ne(e, "Sin", n[0])?.simplify() ?? (ae(e) ? e.box(["Divide", ["Subtract", ["Exp", ["Multiply", "ImaginaryUnit", n[0]]], ["Exp", ["Multiply", "ImaginaryUnit", ["Negate", n[0]]]]], ["Complex", 0, 2]]).simplify() : void 0), evaluate: (e, n) => k(e, "evaluate", "Sin", n[0]), N: (e, n) => k(e, "N", "Sin", n[0]) } } }, { Arctan: { wikidata: "Q2257242", complexity: 5200, threadable: !0, signature: { domain: Cn("Arctan"), simplify: (e, n) => Ne(e, "Arctan", n[0])?.simplify(), evaluate: (e, n) => k(e, "evaluate", "Arctan", n[0]), N: (e, n) => k(e, "N", "Arctan", n[0]) } }, Arctan2: { wikidata: "Q776598", complexity: 5200, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers", "Numbers"], N: (e, n) => Vn(n[0], n[1], Math.atan2, (i, t) => v.atan2(i, t)) } }, Cos: { complexity: 5050, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], simplify: (e, n) => Ne(e, "Cos", n[0])?.simplify() ?? e.box(["Sin", ["Add", n[0], ["Multiply", "Half", "Pi"]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Cos", n[0]), N: (e, n) => k(e, "N", "Cos", n[0]) } }, Tan: { complexity: 5100, threadable: !0, signature: { domain: Or("Tan"), simplify: (e, n) => Ne(e, "Tan", n[0])?.simplify() ?? e.box(["Divide", ["Sin", n[0]], ["Cos", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Tan", n[0]), N: (e, n) => k(e, "N", "Tan", n[0]) } } }, { Arcosh: { complexity: 6200, threadable: !0, signature: { domain: Hn("Arcosh"), simplify: (e, n) => Ne(e, "Arcosh", n[0])?.simplify() ?? e.box(["Ln", ["Add", n[0], ["Sqrt", ["Subtract", ["Square", n[0]], 1]]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Arcosh", n[0]), N: (e, n) => k(e, "N", "Arcosh", n[0]) } }, Arcsin: { complexity: 5500, threadable: !0, signature: { domain: Hn("Arcsin"), simplify: (e, n) => Ne(e, "Arcsin", n[0])?.simplify() ?? e.box(["Multiply", 2, ["Arctan2", n[0], ["Add", 1, ["Sqrt", ["Subtract", 1, ["Square", n[0]]]]]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Arcsin", n[0]), N: (e, n) => k(e, "N", "Arcsin", n[0]) } }, Arsinh: { complexity: 6100, threadable: !0, signature: { domain: Hn("Arsinh"), simplify: (e, n) => Ne(e, "Arsinh", n[0])?.simplify() ?? e.box(["Ln", ["Add", n[0], ["Sqrt", ["Add", ["Square", n[0]], 1]]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Arsinh", n[0]), N: (e, n) => k(e, "N", "Arsinh", n[0]) } }, Artanh: { complexity: 6300, threadable: !0, signature: { domain: Hn("Artanh"), simplify: (e, n) => Ne(e, "Artanh", n[0])?.simplify() ?? e.box(["Multiply", "Half", ["Ln", ["Divide", ["Add", 1, n[0]], ["Subtract", 1, n[0]]]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Artanh", n[0]), N: (e, n) => k(e, "N", "Artanh", n[0]) } }, Cosh: { complexity: 6050, threadable: !0, signature: { domain: Hn("Cosh"), simplify: (e, n) => Ne(e, "Cosh", n[0])?.simplify() ?? e.box(["Multiply", "Half", ["Add", ["Exp", n[0]], ["Exp", ["Negate", n[0]]]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Cosh", n[0]), N: (e, n) => k(e, "N", "Cosh", n[0]) } }, Cot: { complexity: 5600, threadable: !0, signature: { domain: Or("Cot"), simplify: (e, n) => Ne(e, "Cot", n[0])?.simplify() ?? e.box(["Divide", ["Cos", n[0]], ["Sin", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Cot", n[0]), N: (e, n) => k(e, "N", "Cot", n[0]) } }, Csc: { description: "Cosecant", complexity: 5600, threadable: !0, signature: { domain: Or("Csc"), simplify: (e, n) => Ne(e, "Csc", n[0])?.simplify() ?? e.box(["Divide", 1, ["Sin", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Csc", n[0]), N: (e, n) => k(e, "N", "Csc", n[0]) } }, Haversine: { wikidata: "Q2528380", threadable: !0, signature: { domain: ["FunctionOf", "ExtendedRealNumbers", "Numbers"], evaluate: ["Divide", ["Subtract", 1, ["Cos", "_1"]], 2] } }, InverseHaversine: { threadable: !0, signature: { domain: ["FunctionOf", "ExtendedRealNumbers", "RealNumbers"], evaluate: ["Multiply", 2, ["Arcsin", ["Sqrt", "_1"]]] } }, Sec: { description: "Secant, inverse of cosine", complexity: 5500, threadable: !0, signature: { domain: Or("Sec"), simplify: (e, n) => Ne(e, "Sec", n[0])?.simplify() ?? e.box(["Divide", 1, ["Cos", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Sec", n[0]), N: (e, n) => k(e, "N", "Sec", n[0]) } }, Sinh: { complexity: 6e3, threadable: !0, signature: { domain: Hn("Sinh"), simplify: (e, n) => Ne(e, "Sinh", n[0])?.simplify() ?? e.box(["Multiply", "Half", ["Subtract", ["Exp", n[0]], ["Exp", ["Negate", n[0]]]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Sinh", n[0]), N: (e, n) => k(e, "N", "Sinh", n[0]) } } }, { Csch: { complexity: 6200, threadable: !0, signature: { domain: Cn("Csch"), simplify: (e, n) => Ne(e, "Csch", n[0])?.simplify() ?? e.box(["Divide", 1, ["Sinh", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Csch", n[0]), N: (e, n) => k(e, "N", "Csch", n[0]) } }, Sech: { complexity: 6200, threadable: !0, signature: { domain: ["FunctionOf", "Numbers", "Numbers"], simplify: (e, n) => Ne(e, "Sech", n[0])?.simplify() ?? e.box(["Divide", 1, ["Cosh", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Sech", n[0]), N: (e, n) => k(e, "N", "Sech", n[0]) } }, Tanh: { complexity: 6200, threadable: !0, signature: { domain: Hn("Tanh"), simplify: (e, n) => Ne(e, "Tanh", n[0])?.simplify() ?? e.box(["Divide", ["Sinh", n[0]], ["Cosh", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Tanh", n[0]), N: (e, n) => k(e, "N", "Tanh", n[0]) } } }, { Arccos: { complexity: 5550, threadable: !0, signature: { domain: Cn("Arccos"), simplify: (e, n) => Ne(e, "Arccos", n[0])?.simplify() ?? e.box(["Subtract", ["Divide", "Pi", 2], ["Arcsin", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Arccos", n[0]), N: (e, n) => k(e, "N", "Arccos", n[0]) } }, Arccot: { numeric: !0, threadable: !0, signature: { domain: Cn("Arccot"), evaluate: (e, n) => k(e, "evaluate", "Arccot", n[0]), N: (e, n) => k(e, "N", "Arccot", n[0]) } }, Arcoth: { numeric: !0, threadable: !0, signature: { domain: Cn("Arcoth"), evaluate: (e, n) => k(e, "evaluate", "Arcoth", n[0]), N: (e, n) => k(e, "N", "Arcoth", n[0]) } }, Arcsch: { numeric: !0, threadable: !0, signature: { domain: Cn("Arcsch"), evaluate: (e, n) => k(e, "evaluate", "Arcsch", n[0]), N: (e, n) => k(e, "N", "Arcsch", n[0]) } }, Arcsec: { numeric: !0, threadable: !0, signature: { domain: Cn("Arcsec"), evaluate: (e, n) => k(e, "evaluate", "Arcsec", n[0]), N: (e, n) => k(e, "N", "Arcsec", n[0]) } }, Arsech: { numeric: !0, threadable: !0, signature: { domain: Cn("Arsech"), evaluate: (e, n) => k(e, "evaluate", "Arsech", n[0]), N: (e, n) => k(e, "N", "Arsech", n[0]) } }, Arccsc: { numeric: !0, threadable: !0, signature: { domain: Cn("Arccsc"), evaluate: (e, n) => k(e, "evaluate", "Arccsc", n[0]), N: (e, n) => k(e, "N", "Arccsc", n[0]) } }, Coth: { complexity: 6300, threadable: !0, signature: { domain: Hn("Coth"), simplify: (e, n) => Ne(e, "Coth", n[0])?.simplify() ?? e.box(["Divide", 1, ["Tanh", n[0]]]).simplify(), evaluate: (e, n) => k(e, "evaluate", "Coth", n[0]), N: (e, n) => k(e, "N", "Coth", n[0]) } }, InverseFunction: { signature: { domain: ["FunctionOf", "Functions", "Functions"], canonical: (e, n) => (n = Se(e, n, 1), fs(e, n) ?? e._fn("InverseFunction", n)), simplify: (e, n) => fs(e, n), evaluate: (e, n) => fs(e, n) } } }], Jn = ["Sqrt", 2], $i = ["Sqrt", 3], zi = ["Sqrt", 5], Pr = ["Sqrt", 6], Fd = [[[0, 1], { Sin: 0, Cos: 1, Tan: 0, Cot: "ComplexInfinity", Sec: 1, Csc: "ComplexInfinity" }], [[1, 12], { Sin: ["Divide", ["Subtract", Pr, Jn], 4], Cos: ["Divide", ["Add", Pr, Jn], 4], Tan: ["Subtract", 2, $i], Cot: ["Add", 2, $i], Sec: ["Subtract", Pr, Jn], Csc: ["Add", Pr, Jn] }], [[1, 10], { Sin: ["Divide", ["Subtract", zi, 1], 4], Cos: ["Divide", ["Sqrt", ["Add", 10, ["Multiply", 2, zi]]], 4], Tan: ["Divide", ["Sqrt", ["Subtract", 25, ["Multiply", 10, zi]]], 5], Cot: ["Sqrt", ["Add", 5, ["Multiply", 2, zi]]], Sec: ["Divide", ["Sqrt", ["Subtract", 50, ["Multiply", 10, zi]]], 5], Csc: ["Add", 1, zi] }], [[1, 8], { Sin: "$\\frac{\\sqrt{2-\\sqrt2}}{2}$", Cos: "$\\frac{\\sqrt {2+{\\sqrt {2}}}}{2}$", Tan: "$\\sqrt{2} - 1$", Cot: "$\\sqrt{2} + 1$", Sec: "$\\sqrt{ 4 - 2\\sqrt{2}}$", Csc: "$\\sqrt{ 4 + 2\\sqrt{2}}$" }], [[1, 6], { Sin: "$\\frac{1}{2}$", Cos: "$\\frac{\\sqrt{3}}{2}$", Tan: "$\\frac{\\sqrt{3}}{3}$", Cot: "$\\sqrt{3}$", Sec: "$\\frac{2\\sqrt{3}}{3}$", Csc: 2 }], [[1, 5], { Sin: "$\\frac{\\sqrt{10- 2\\sqrt{5}}} {4}$", Cos: "$\\frac{1+ \\sqrt{5}} {4}$", Tan: "$\\sqrt{5-2\\sqrt5}$", Cot: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$", Sec: "$\\sqrt{5} - 1$", Csc: "$\\frac{\\sqrt{50+10\\sqrt{5}}} {5}$" }], [[1, 4], { Sin: ["Divide", Jn, 2], Cos: ["Divide", Jn, 2], Tan: 1, Cot: 1, Sec: Jn, Csc: Jn }], [[3, 10], { Sin: "$\\frac{1+ \\sqrt5} {4}$", Cos: "$\\frac{\\sqrt{10- 2\\sqrt5}} {4}$", Tan: "$\\frac{\\sqrt{25+10\\sqrt5}} {5}$", Cot: "$\\sqrt{5-2\\sqrt5}$", Sec: "$\\frac{\\sqrt{50+10\\sqrt5}} {5}$", Csc: "$\\sqrt5-1$" }], [[1, 3], { Sin: ["Divide", $i, 2], Cos: "Half", Tan: $i, Cot: ["Divide", $i, 3], Sec: 2, Csc: ["Divide", ["Multiply", 2, $i], 3] }], [[3, 8], { Sin: "$\\frac{ \\sqrt{2 + \\sqrt{2}} } {2}$", Cos: "$\\frac{ \\sqrt{2 - \\sqrt{2}} } {2}$", Tan: "$\\sqrt{2} + 1$", Cot: "$\\sqrt{2} - 1$", Sec: "$\\sqrt{ 4 + 2 \\sqrt{2} }$", Csc: "$\\sqrt{ 4 - 2 \\sqrt{2} }$" }], [[2, 5], { Sin: "$\\frac{\\sqrt{10+ 2\\sqrt{5}}} {4}$", Cos: "$\\frac{\\sqrt{5}-1} {4}$", Tan: "$\\sqrt{5+2\\sqrt{5}}$", Cot: "$\\frac{\\sqrt{25-10\\sqrt{5}}} {5}$", Sec: "$1 + \\sqrt{5}$", Csc: "$\\frac{\\sqrt{50-10\\sqrt{5}}} {5}$" }], [[5, 12], { Sin: "$\\frac{\\sqrt{6} + \\sqrt{2}} {4}$", Cos: "$\\frac{ \\sqrt{6} - \\sqrt{2}} {4}$", Tan: "$2+\\sqrt{3}$", Cot: "$2-\\sqrt{3}$", Sec: "$\\sqrt{6}+\\sqrt{2}$", Csc: "$\\sqrt{6} - \\sqrt{2}$" }], [[1, 2], { Sin: 1, Cos: 0, Tan: "ComplexInfinity", Cot: 0, Sec: "ComplexInfinity", Csc: 1 }]], Rd = { Sin: [[1, "Sin"], [1, "Cos"], [-1, "Sin"], [-1, "Cos"]], Cos: [[1, "Cos"], [-1, "Sin"], [-1, "Cos"], [1, "Sin"]], Sec: [[1, "Sec"], [-1, "Csc"], [-1, "Sec"], [1, "Csc"]], Csc: [[1, "Csc"], [1, "Sec"], [-1, "Csc"], [-1, "Sec"]], Tan: [[1, "Tan"], [-1, "Cot"], [1, "Tan"], [-1, "Cot"]], Cot: [[1, "Cot"], [-1, "Tan"], [1, "Cot"], [-1, "Tan"]] }; function Ne(e, n, i) { if (!i) return; let t = E(i.N()); if (t === null) return; let r = e.cache("constructible-trigonometric-values", () => Fd.map(([u, l]) => [u, Object.fromEntries(Object.entries(l).map(([f, d]) => [f, e.parse(Ii(d)) ?? e.box(d)]))]), u => { for (let [l, f] of u) for (let d of Object.values(f)) d.reset(); return u }), o = n !== "Cos" && n !== "Sec" ? Math.sign(t) : 1; t = Math.abs(t % (2 * Math.PI)); let s = Math.floor(t * 2 / Math.PI); t = t % (Math.PI / 2); let a;[a, n] = Rd[n]?.[s] ?? [1, n]; for (let [[u, l], f] of r) { let d = f[n]; if (d && e.chop(t - Math.PI * u / l) === 0) return d.symbol === "ComplexInfinity" ? d : o * a < 0 ? ge(d) : d } } function fs(e, n) { if (n.length !== 1 || !n[0].isValid) return; let i = n[0], t = i.symbol; if (typeof t != "string") return; if (t === "InverseFunction") return i.op1; let r = { Sin: "Arcsin", Cos: "Arccos", Tan: "Arctan", Sec: "Arcsec", Csc: " Arccsc", Sinh: "Arsinh", Cosh: "Arcosh", Tanh: "Artanh", Sech: "Arcsech", Csch: "Arcsch", Arcosh: "Cosh", Arccos: "Cos", Arccsc: "Csc", Arcsch: "Csch", Arcsec: "Sec", Arcsin: "Sin", Arsinh: "Sinh", Arctan: "Tan", Artanh: "Tanh" }[t]; return r ? e.symbol(r) : void 0 } function k(e, n, i, t) { if (!t) return; let r = Ne(e, i, t)?.evaluate({ numericMode: n === "N" }); if (r) return r; if (!(n === "evaluate" && t.isExact)) switch (i) { case "Arccos": return R(t, Math.acos, o => o.acos(), o => o.acos()); case "Arccot": return R(t, o => Math.atan2(1, o), o => v.atan2(e._BIGNUM_ONE, o), o => o.inverse().atan()); case "Arccsc": return R(t, o => Math.asin(1 / o), o => e._BIGNUM_ONE.div(o).asin(), o => o.inverse().asin()); case "Arcosh": return R(t, Math.acosh, o => o.acosh(), o => o.acosh()); case "Arcoth": return R(t, o => o, o => o.acosh(), o => o.acosh()); case "Arcsch": return R(t, o => Math.log(1 / o + Math.sqrt(1 / (o * o) + 1)), o => e._BIGNUM_ONE.div(o.mul(o)).add(e._BIGNUM_ONE).sqrt().add(e._BIGNUM_ONE.div(o)).log(), o => o.mul(o).inverse().add(1).sqrt().add(o.inverse()).log()); case "Arcsec": return R(t, o => Math.acos(1 / o), o => e._BIGNUM_ONE.div(o).acos(), o => o.inverse().acos()); case "Arcsin": return R(t, Math.asin, o => o.asin(), o => o.asin()); case "Arsech": return R(t, o => Math.log((1 + Math.sqrt(1 - o * o)) / o), o => e._BIGNUM_ONE.sub(o.mul(o).add(e._BIGNUM_ONE).div(o)).log(), o => e.complex(1).sub(o.mul(o)).add(1).div(o).log()); case "Arsinh": return R(t, Math.asinh, o => o.asinh(), o => o.asinh()); case "Arctan": return R(t, Math.atan, o => o.atan(), o => o.atan()); case "Artanh": return R(t, Math.atanh, o => o.atanh(), o => o.atanh()); case "Cos": return R(t, Math.cos, o => o.toSignificantDigits(e.precision + 4).cos().toSignificantDigits(e.precision), o => o.cos()); case "Cosh": return R(t, Math.cosh, o => o.cosh(), o => o.cosh()); case "Cot": return R(t, o => 1 / Math.tan(o), o => e._BIGNUM_ONE.div(o.tan()), o => o.tan().inverse()); case "Coth": return R(t, o => 1 / Math.tanh(o), o => e._BIGNUM_ONE.div(o.tanh()), o => o.tanh().inverse()); case "Csc": return R(t, o => 1 / Math.sin(o), o => e._BIGNUM_ONE.div(o.sin()), o => o.sin().inverse()); case "Csch": return R(t, o => 1 / Math.sinh(o), o => e._BIGNUM_ONE.div(o.sinh()), o => o.sinh().inverse()); case "Sec": return R(t, o => 1 / Math.cos(o), o => e._BIGNUM_ONE.div(o.cos()), o => o.cos().inverse()); case "Sech": return R(t, o => 1 / Math.cosh(o), o => e._BIGNUM_ONE.div(o.cosh()), o => o.cosh().inverse()); case "Sin": return R(t, Math.sin, o => o.toSignificantDigits(e.precision + 4).sin().toSignificantDigits(e.precision), o => o.sin()); case "Sinh": return R(t, Math.sinh, o => o.sinh(), o => o.sinh()); case "Tan": return R(t, Math.tan, o => o.toSignificantDigits(e.precision + 4).tan().toSignificantDigits(e.precision), o => o.tan()); case "Tanh": return R(t, Math.tanh, o => o.tanh(), o => o.tanh()) } } var Ku = pe(ce(), 1); var de = class { constructor(n, i, t) { if (!n.context) throw Error("No context available"); this.name = i, this.wikidata = t.wikidata, this.description = t.description, this.url = t.url, this._engine = n, this.scope = n.context, this.name = i, this._flags = t.flags ? Bt(t.flags) : void 0, this._domain = t.domain ? n.domain(t.domain) : void 0, this.inferredDomain = t.inferred ?? !1, this.constant = t.constant ?? !1, this.holdUntil = t.holdUntil ?? "evaluate", this.constant ? (this._defValue = t.value, this._value = null) : (t.value !== void 0 ? Di(t.value) ? this._value = n.parse(t.value) ?? n.symbol("Undefined") : typeof t.value == "function" ? this._value = n.box(t.value(n) ?? "Undefined") : t.value instanceof L ? this._value = t.value : this._value = n.box(t.value) : this._value = void 0, !this._value && this._domain && !t.flags && (this._flags = Fr(this._domain))), this._value && !this._domain && (this._domain = this._value.domain, this.inferredDomain = !0) } update(n) { n.wikidata && (this.wikidata = n.wikidata), n.description && (this.description = n.description), n.url && (this.url = n.url); let i = n?.flags, t = n?.domain ? this._engine.domain(n.domain) : void 0; t && (i = { ...Fr(t), ...i ?? {} }), i && (this._flags = Bt(i)), t && (this._domain = t, this.inferredDomain = !1), n.holdUntil && (this.holdUntil = n.holdUntil), n.constant ? (this.constant = n.constant, this._defValue = n.value, this._value = null) : n.value && (Di(n.value) ? this._value = this._engine.parse(n.value) ?? this._engine.symbol("Undefined") : typeof n.value == "function" ? this._value = this._engine.box(n.value(this._engine) ?? "Undefined") : n.value instanceof L ? this._value = n.value : this._value = this._engine.box(n.value)), this._value && !this._domain && (this._domain = this._value.domain, this.inferredDomain = !0) } reset() { this.constant && (this._value = null) } get value() { if (this._value === null) { let n = this._engine; if (Di(this._defValue) ? this._value = n.parse(this._defValue) ?? n.symbol("Undefined") : typeof this._defValue == "function" ? this._value = n.box(this._defValue(n) ?? "Undefined") : this._defValue ? this._value = n.box(this._defValue) : this._value = void 0, this._value?.numericValue) { let i = this._value.numericValue; !F(n) && i instanceof v ? this._value = n.number(i.toNumber()) : !ae(n) && i instanceof Ku.Complex && (this._value = n.NaN) } } return this._value ?? void 0 } set value(n) { if (this.constant) throw new Error(`The value of the constant "${this.name}" cannot be changed`); if (this._defValue, typeof n == "number") this._value = this._engine.number(n); else if (n) { let i = this._engine.box(n); this.inferredDomain ? (this._value = i, this._domain = Un(this._domain, i.domain)) : !this._domain || !i.domain || i.domain?.isCompatible(this._domain) ? this._value = i : this._value = void 0 } else this._value = void 0; this._value !== void 0 ? this._flags = void 0 : this._flags = Fr(this._domain) } get domain() { return this._domain ?? void 0 } set domain(n) { if (this.constant) throw new Error(`The domain of the constant "${this.name}" cannot be changed`); if (!this.inferredDomain) throw Error(`The domain of "${this.name}" cannot be changed because it has already been declared`); if (!n) { this._defValue = void 0, this._value = void 0, this._flags = void 0, this._domain = void 0; return } if (n = this._engine.domain(n), this._domain && !n.isCompatible(this._domain)) throw Error(`The domain of "${this.name}" cannot be widened from "${this._domain.base}" to "${n.base}"`); if (this._value?.domain && !this._value.domain.isCompatible(n)) throw Error(`The domain of "${this.name}" cannot be changed to "${n.base}" because its value has a domain of "${this._value.domain.base}"`); this._domain = n, this._flags = void 0, this._value === void 0 && n.isNumeric && (this._flags = Fr(n)) } get number() { return this.value?.isNumber ?? this._flags?.number } set number(n) { this.updateFlags({ number: n }) } get integer() { return this.value?.isInteger ?? this._flags?.integer } set integer(n) { this.updateFlags({ integer: n }) } get rational() { return this.value?.isRational ?? this._flags?.rational } set rational(n) { this.updateFlags({ rational: n }) } get algebraic() { return this.value?.isAlgebraic ?? this._flags?.algebraic } set algebraic(n) { this.updateFlags({ algebraic: n }) } get real() { return this.value?.isReal ?? this._flags?.real } set real(n) { this.updateFlags({ real: n }) } get extendedReal() { return this.value?.isExtendedReal ?? this._flags?.extendedReal } set extendedReal(n) { this.updateFlags({ extendedReal: n }) } get complex() { return this.value?.isComplex ?? this._flags?.complex } set complex(n) { this.updateFlags({ complex: n }) } get extendedComplex() { return this.value?.isExtendedComplex ?? this._flags?.extendedComplex } set extendedComplex(n) { this.updateFlags({ extendedComplex: n }) } get imaginary() { return this.value?.isImaginary ?? this._flags?.imaginary } set imaginary(n) { this.updateFlags({ imaginary: n }) } get positive() { return this.value?.isPositive ?? this._flags?.positive } set positive(n) { this.updateFlags({ positive: n }) } get nonPositive() { return this.value?.isNonPositive ?? this._flags?.nonPositive } set nonPositive(n) { this.updateFlags({ nonPositive: n }) } get negative() { return this.value?.isNegative ?? this._flags?.negative } set negative(n) { this.updateFlags({ negative: n }) } get nonNegative() { return this.value?.isNonNegative ?? this._flags?.nonNegative } set nonNegative(n) { this.updateFlags({ nonNegative: n }) } get zero() { return this.value?.isZero ?? this._flags?.zero } set zero(n) { this.updateFlags({ zero: n }) } get notZero() { return this.value?.isNotZero ?? this._flags?.notZero } set notZero(n) { this.updateFlags({ notZero: n }) } get one() { return this.value?.isOne ?? this._flags?.one } set one(n) { this.updateFlags({ one: n }) } get negativeOne() { return this.value?.isNegativeOne ?? this._flags?.negativeOne } set negativeOne(n) { this.updateFlags({ negativeOne: n }) } get infinity() { return this.value?.isInfinity ?? this._flags?.infinity } set infinity(n) { this.updateFlags({ infinity: n }) } get finite() { return this.value?.isFinite ?? this._flags?.finite } set finite(n) { this.updateFlags({ finite: n }) } get NaN() { return this.value?.isNaN ?? this._flags?.NaN } set NaN(n) { this.updateFlags({ NaN: n }) } get even() { return this.value?.isEven ?? this._flags?.even } set even(n) { this.updateFlags({ even: n }) } get odd() { return this.value?.isOdd ?? this._flags?.odd } set odd(n) { this.updateFlags({ odd: n }) } get prime() { let n = this._value; return n ? !n.isInteger || n.isNonPositive ? !1 : jn(E(n) ?? NaN) : this._flags?.prime } set prime(n) { this.updateFlags({ prime: n }) } get composite() { let n = this._value; return n ? !n.isInteger || n.isNonPositive ? !1 : !jn(E(n) ?? NaN) : this._flags?.composite } set composite(n) { this.updateFlags({ composite: n }) } updateFlags(n) { if (this.constant) throw Error("The flags of constant cannot be changed"); if (this.domain?.isNumeric === !1) throw Error("Flags only apply to numeric domains"); let i = 0, t = !0; for (let r in Object.keys(n)) if (i += 1, this._value && n[r] !== void 0) switch (r) { case "number": t = this._value.isNumber === n.number; break; case "integer": t = this._value.isInteger === n.integer; break; case "rational": t = this._value.isRational === n.rational; break; case "algebraic": t = this._value.isAlgebraic === n.algebraic; break; case "real": t = this._value.isReal === n.real; break; case "extendedReal": t = this._value.isExtendedReal === n.extendedReal; break; case "complex": t = this._value.isComplex === n.complex; break; case "extendedComplex": t = this._value.isExtendedComplex === n.extendedComplex; break; case "imaginary": t = this._value.isImaginary === n.imaginary; break; case "positive": t = this._value.isPositive === n.positive; break; case "nonPositive": t = this._value.isNonPositive === n.nonPositive; break; case "negative": t = this._value.isNegative === n.negative; break; case "nonNegative": t = this._value.isNonNegative === n.nonNegative; break; case "zero": t = this._value.isZero === n.zero; break; case "notZero": t = this._value.isNotZero === n.notZero; break; case "one": t = this._value.isOne === n.one; break; case "negativeOne": t = this._value.isNegativeOne === n.negativeOne; break; case "infinity": t = this._value.isInfinity === n.infinity; break; case "NaN": t = this._value.isNaN === n.NaN; break; case "finite": t = this._value.isFinite === n.finite; break; case "even": t = this._value.isEven === n.even; break; case "odd": t = this._value.isOdd === n.odd; break; case "prime": t = this._value.isPrime === n.prime; break; case "composite": t = this._value.isComposite === n.composite; break }i > 0 && (t || (this._defValue = void 0, this._value = void 0), this._domain = this._engine.Numbers, this._flags ? this._flags = { ...this._flags, ...Bt(n) } : this._flags = Bt(n)) } }; function Ld(e) { return Object.fromEntries(Object.entries(e).filter(([n, i]) => i !== void 0)) } function Bt(e) { let n = { ...e }; return (e.zero || e.one || e.negativeOne) && (n.zero = e.zero && !e.one && !e.negativeOne, n.notZero = !e.zero || e.one || e.negativeOne, n.one = e.one && !e.zero && !e.negativeOne, n.negativeOne = e.negativeOne && !e.zero && !e.one, n.infinity = !1, n.NaN = !1, n.finite = !0, n.integer = !0, n.finite = !0, n.infinity = !1, n.NaN = !1, n.even = e.one, n.odd = !e.one, n.prime = !1, n.composite = !1), n.zero && (n.positive = !1, n.negative = !1, n.nonPositive = !0, n.nonNegative = !0), n.notZero === !0 && (n.imaginary || (n.real = !0), n.zero = !1), n.one && (n.positive = !0), n.negativeOne && (n.nonPositive = !0), (n.positive || n.nonNegative) && (n.negativeOne = !1), n.positive ? (n.nonPositive = !1, n.negative = !1, n.nonNegative = !0) : n.nonPositive ? (n.positive = !1, n.negative = n.notZero, n.nonNegative = !n.zero) : n.negative ? (n.positive = !1, n.nonPositive = n.notZero, n.nonNegative = !1) : n.nonNegative && (n.positive = n.notZero, n.nonPositive = !n.zero, n.negative = !1), (n.positive || n.negative || n.nonPositive || n.nonNegative) && (n.number = !0, n.finite ? n.real = !0 : n.finite || (n.complex = !0), n.imaginary = !1), n.finite && (n.number = !0, n.complex = !0, n.infinity = !1, n.NaN = !1), n.infinity && (n.finite = !1, n.NaN = !1), n.infinity === !1 && (n.extendedComplex = !1, n.extendedReal = !1), e.even && (n.odd = !1), e.odd && (n.even = !1), n.integer && (n.rational = !0), n.rational && (n.algebraic = !0), n.algebraic && (n.real = !0), n.real && (n.complex = !0), n.imaginary && (n.complex = !0), n.complex && (n.number = !0), n.real && n.infinity !== !1 && (n.extendedReal = !0), n.complex && n.infinity !== !1 && (n.extendedComplex = !0), (n.even || n.infinity || n.NaN || n.negative || n.imaginary || n.integer === !1) && (n.prime = !1), n.number && n.prime && (n.composite = !1), n } function Fr(e) { if (!e) return {}; let n = {}; if (!e.isNumeric) return n.number = !1, n.integer = !1, n.rational = !1, n.algebraic = !1, n.real = !1, n.extendedReal = !1, n.complex = !1, n.extendedComplex = !1, n.imaginary = !1, n.positive = !1, n.nonPositive = !1, n.negative = !1, n.nonNegative = !1, n.zero = !1, n.notZero = !1, n.one = !1, n.negativeOne = !1, n.infinity = !1, n.NaN = !1, n.odd = !1, n.even = !1, n.prime = !1, n.composite = !1, n; let i = e.base; return n.number = !0, i === "Integers" && (n.integer = !0), i === "RationalNumbers" && (n.rational = !0), i === "AlgebraicNumbers" && (n.algebraic = !0), i === "TranscendentalNumbers" && (n.algebraic = !1, n.real = !0), i === "ExtendedRealNumbers" && (n.extendedReal = !0), i === "RealNumbers" && (n.real = !0), i === "ImaginaryNumbers" && (n.imaginary = !0), i === "ExtendedComplexNumbers" && (n.extendedComplex = !0), i === "ComplexNumbers" && (n.complex = !0), i === "PositiveNumbers" && (n.notZero = !0, n.real = !0, n.positive = !0), i === "NegativeNumbers" && (n.notZero = !0, n.real = !0, n.negative = !0), i === "NonNegativeNumbers" && (n.real = !0, n.positive = !0), i === "NonPositiveNumbers" && (n.real = !0, n.negative = !0), i === "PositiveIntegers" && (n.notZero = !0, n.integer = !0, n.positive = !0), i === "NegativeNumbers" && (n.notZero = !0, n.integer = !0, n.negative = !0), i === "NonNegativeNumbers" && (n.integer = !0, n.positive = !0), i === "NonPositiveNumbers" && (n.integer = !0, n.negative = !0), Ld(Bt(n)) } var We = class { constructor(n, i, t) { if (!n.context) throw Error("No context available"); this.engine = n, this.scope = n.context; let r = t.idempotent ?? !1, o = t.involution ?? !1; if (r && o) throw new Error(`Function Definition "${i}": the 'idempotent' and 'involution' flags are mutually exclusive`); if (this.name = i, this.description = t.description, this.wikidata = t.wikidata, this.threadable = t.threadable ?? !1, this.associative = t.associative ?? !1, this.commutative = t.commutative ?? !1, this.idempotent = r, this.involution = o, this.inert = t.inert ?? !1, this.numeric = t.numeric ?? !1, this.pure = t.pure ?? !0, this.complexity = t.complexity ?? pn, this.hold = t.hold ?? "none", t.at && (this.at = t.at), t.iterator && (this.iterator = t.iterator), t.size && (this.size = t.size), t.keys && (this.keys = t.keys), t.indexOf && (this.indexOf = t.indexOf), t.at && !t.size && (this.size = s => { let a = t.at, u = 0; for (; a(s, u) !== void 0;)u++; return u }), t.at && !t.iterator && (this.iterator = (s, a = 1, u = -1) => { let l = t.at, f = a; return { next() { if (u >= 0 && f >= a + u) return { done: !0, value: void 0 }; let d = l(s, f); return d === void 0 ? { done: !0, value: void 0 } : (f++, { done: !1, value: d }) } } }), this.iterator && !t.indexOf && (this.indexOf = (s, a) => { let u = 1, l = this.iterator(s), f = l.next(); for (; !f.done;) { if (a.isEqual(f.value)) return u; u++, f = l.next() } }), this.inert) { if (t.hold) throw Error(`Function Definition "${i}": an inert function should not have a hold`); if (this.hold = "rest", t.signature) { let s = t.signature; if ("simplify" in s || "evaluate" in s || "N" in s || "evalDimension" in s || "sgn" in s || "compile" in s) throw Error(`Function Definition "${i}": an inert function should only have 'canonical' or 'codomain' handlers`) } if (this.threadable) throw Error(`Function Definition "${i}": an inert function should not be threadable`); if (this.associative) throw Error(`Function Definition "${i}": an inert function should not be associative`); if (this.commutative) throw Error(`Function Definition "${i}": an inert function should not be commutative`); if (this.idempotent) throw Error(`Function Definition "${i}": an inert function should not be idempotent`); if (this.involution) throw Error(`Function Definition "${i}": an inert function should not be involution`); if (!this.pure) throw Error(`Function Definition "${i}": an inert function should be pure`) } if (t.signature) { let s = t.signature, a, u, l, f, d = !1; if (s.domain) { let m = n.domain(s.domain); if (!m.isValid) throw Error(`Function Definition "${i}": invalid domain ${JSON.stringify(s.domain)}`);[a, u, l, f] = at(n.domain(m)) } else s.params || s.result ? (a = s.params?.map(m => n.domain(m)) ?? [], u = s.optParams?.map(m => n.domain(m)) ?? [], l = s.restParam ? n.domain(s.restParam) : void 0, typeof s.result == "function" ? f = s.result : s.result ? f = n.domain(s.result) : t.numeric ? f = n.Numbers : f = n.Anything) : t.numeric ? (d = !0, a = [], u = [], l = n.Numbers, f = n.Numbers) : (d = !0, a = [], u = [], l = n.Anything, f = n.Anything); let c; if (s.evaluate && typeof s.evaluate != "function") { let m = n.box(s.evaluate, { canonical: !1 }); if (!m.isValid) throw Error(`Invalid function ${m.toString()}`); let g = li(m); c = (h, x) => g(x), c.toString = () => m.toString() } else c = s.evaluate; this.signature = { inferredSignature: d, params: a, optParams: u, restParam: l || void 0, result: f, canonical: s.canonical, simplify: s.simplify, evaluate: c, N: s.N, evalDimension: s.evalDimension, sgn: s.sgn, compile: s.compile } } else t.numeric ? this.signature = { inferredSignature: !0, params: [], optParams: [], restParam: n.Numbers, result: n.Numbers } : this.signature = { inferredSignature: !0, params: [], optParams: [], restParam: n.Anything, result: n.Anything } } reset() { } }; function Rr(e, n, i) { return i instanceof We ? i : new We(e, n, i) } function ds(e) { if (e === "all") return ds(["core", "control-structures", "logic", "collections", "relop", "numeric", "arithmetic", "trigonometry", "algebra", "calculus", "polynomials", "combinatorics", "linear-algebra", "statistics", "dimensions", "units", "physics", "other"]); typeof e == "string" && (e = [e]); let n = []; for (let i of e) { let t = qd[i]; if (!t) throw Error(`Unknown library category ${i}`); Array.isArray(t) ? n.push(...t) : n.push(t) } return Object.freeze(n) } var qd = { algebra: [], arithmetic: [...Au, ...Vu], calculus: Pu, collections: [Yu, Ru, Ua()], combinatorics: [], "control-structures": Lu, core: Su, dimensions: [], domains: [], "linear-algebra": $u, logic: Hu, numeric: [], other: [], relop: Wu, polynomials: Ju, physics: { Mu0: { description: "Vaccum permeability", constant: !0, wikidata: "Q1515261", domain: "RealNumbers", value: 125663706212e-17 } }, statistics: Qu, trigonometry: Xu, units: [] }; function Vd(e) { if (e = e.normalize(), Ee(e)) return e; throw new Error(`Invalid definition name "${e}": ${en(e)}`) } function cs(e, n) {
      var t; if (!e.context) throw Error("No context available"); (t = e.context).ids ?? (t.ids = new Map); let i = e.context.ids; e.strict; for (let [r, o] of Object.entries(n)) if (r = Vd(r), ms(o)) {
        let s = Rr(e, r, o); if (i.has(r)) throw new Error(`Duplicate function definition ${r}:
${JSON.stringify(i.get(r))}
${JSON.stringify(o)}`); i.set(r, s)
      } else if (Lr(o)) { let s = new de(e, r, o); if (e.strict && o.wikidata) { for (let [a, u] of i) if (u.wikidata === o.wikidata) throw new Error(`Duplicate entries with wikidata "${o.wikidata}": "${r}" and "${u.name}"`) } if (i.has(r)) throw new Error(`Duplicate symbol definition "${r}"`); i.set(r, s) } else { let s = new de(e, r, { value: e.box(o) }); i.set(r, s) }
    } function Lr(e) { return e == null || typeof e != "object" || e instanceof L ? !1 : "domain" in e || "value" in e || "constant" in e } function ms(e) { return e == null || typeof e != "object" || e instanceof L ? !1 : "signature" in e || "complexity" in e } var el = pe(ce(), 1); function fi(e) { return Number.isInteger(e) && e !== 0 ? Math.floor(Math.log2(Math.abs(e)) / Math.log2(10)) + (e > 0 ? 1 : 2) : 2 } function ps(e) { if (e.symbol) return 1; let n = e.numericValue; if (n !== null) { if (e.isZero) return 1; if (e.isInteger) return fi(E(e)); if (U(n)) return J(n) ? fi(n[0]) + fi(n[1]) + 1 : fi(Number(n[0])) + fi(Number(n[1])) + 1; if (n instanceof el.Complex) return fi(n.re) + fi(n.im) + 1; if (e.isNumber) return 2 } let i = e.head, t = 2; return typeof i == "string" ? ["Add", "Divide"].includes(i) ? t = 3 : ["Subtract", "Negate"].includes(i) ? t = 4 : ["Square", "Sqrt", "Multiply", "Root"].includes(i) ? t = 5 : ["Power"].includes(i) ? t = 6 : ["Ln", "Exp", "Log"].includes(i) ? t = 7 : ["Arcsin", "Arccos", "Arctan", "Arcsec", " Arccsc", "Arsinh", "Arcosh", "Artanh", "Arcsech", "Arcsch", "Cosh", "Cos", "Csc", "Csch", "Sec", "Sin", "Sinh", "Tan", "Tanh"].includes(i) ? t = 9 : t = 10 : t = ps(i), t + (e.ops?.reduce((r, o) => r + ps(o), 0) ?? 0) } var hs = ps; var Ui = class e { constructor(n) { n ? n instanceof e ? this._items = new Map(n._items) : this._items = new Map(n) : this._items = new Map } has(n) { for (let i of this._items.keys()) if (i.isSame(n)) return !0; return !1 } get(n) { for (let [i, t] of this._items) if (i.isSame(n)) return t } clear() { this._items.clear() } set(n, i) { for (let t of this._items.keys()) if (t.isSame(n)) { this._items.set(t, i); return } this._items.set(n, i) } delete(n) { this._items.delete(n) } [Symbol.iterator]() { return this._items.entries() } entries() { return this._items.entries() } }; function nl(e) { let n = [], i = (t, r = []) => { if (t.length === 0) n.push(r); else for (let o = 0; o < t.length; o++) { let s = t.slice(), a = s.splice(o, 1); i(s.slice(), r.concat(a)) } }; return i(e), n } var Vr = class e extends L { constructor(i, t, r) { super(i, r); this._pattern = Di(t) ? i.parse(t, { canonical: !1 }) : i.box(t, { canonical: !1 }) } get hash() { return xe("Pattern") ^ this._pattern.hash } reset() { this._pattern.reset() } get json() { return O(this.engine, "Pattern", [this._pattern]) } get head() { return "Pattern" } get domain() { return this.engine.domain("Values") } get isCanonical() { return !0 } set isCanonical(i) { } isSame(i) { return this === i ? !0 : i instanceof e && this._pattern.isSame(i._pattern) } isEqual(i) { return i instanceof e && this._pattern.isEqual(i._pattern) } match(i, t) { return tl(i, this._pattern, { recursive: t?.recursive ?? !1, numericTolerance: t?.numericTolerance ?? 0, substitution: t?.substitution ?? {}, exact: t?.exact ?? !1 }) } test(i, t) { return this.match(i, t) !== null } count(i, t) { let r = 0; for (let o of i) this.match(o, t) !== null && (r += 1); return r } subs(i, t) { return this._pattern.subs(i, t) } }; function qr(e) { if (typeof e == "string") return e.startsWith("_"); if (e.symbol?.startsWith("_")) return !0; if (e.ops) return qr(e.head) || e.ops.some(qr); if (e.keys) { for (let n of e.keys) if (qr(e.getKey(n))) return !0 } return !1 } function $r(e, n, i) { return e.startsWith("_"), e === "_" || e === "__" || e === "___" ? i : e in i ? n.isSame(i[e]) ? i : null : qr(n) ? null : { ...i, [e]: n } } function Ve(e, n, i, t) { let r = t.exact ?? !1, o = e.engine; if (n.head === "Pattern") return n.match(e, { ...t, ...i }); if (n instanceof le) return e instanceof le ? t.numericTolerance === 0 ? n.isSame(e) ? i : null : n.isEqualWithTolerance(e, t.numericTolerance) ? i : null : null; let s = n.string; if (s !== null) return e.string === s ? i : null; let a = n.symbol; if (a !== null) return a.startsWith("_") ? $r(a, e, i) : a === e.symbol ? i : null; let u = n.keys; if (u !== null) { let l = e.keys; if (l === null) return null; for (let f of u) { let d = Ve(l[f], u[f], i, t); if (d === null) return null; i = d } return i } if (n.ops) { let l = n.head; if (typeof l == "string" && l.startsWith("_")) return $r(l, o.box(e.head), i); let f; if (typeof l == "string" && typeof e.head == "string") { if (l !== e.head) { if (r) return null; if (l === "Add") { let d = Ve(o.box(["Add", 0, e], { canonical: !1 }), n, i, t); if (d !== null || (e.head === "Subtract" && (d = Ve(o.box(["Add", e.op1, ["Negate", e.op2]], { canonical: !1 }), n, i, t)), d !== null)) return d } if (l === "Subtract") { let d = Ve(o.box(["Subtract", e, 0], { canonical: !1 }), n, i, t); if (d !== null || (e.head === "Negate" && (d = Ve(o.box(["Subtract", 0, e.op1], { canonical: !1 }), n, i, t)), d !== null)) return d } if (l === "Multiply") { let d = Ve(o.box(["Multiply", 1, e], { canonical: !1 }), n, i, t); if (d !== null || e.head === "Negate" && (d = Ve(o.box(["Multiply", -1, e.op1], { canonical: !1 }), n, i, t), d !== null) || e.head === "Divide" && (d = Ve(o.box(["Multiply", e.op1, ["Divide", 1, e.op2]], { canonical: !1 }), n, i, t), d !== null)) return d } if (l === "Divide") { let d = Ve(o.box(["Divide", e, 1], { canonical: !1 }), n, i, t); if (d !== null) return d } return null } f = o.lookupFunction(l) } else { let d = Ve(o.box(e.head, { canonical: !1 }), o.box(l, { canonical: !1 }), i, t); if (d === null) return null; i = d } return f?.commutative ? $d(e, n, i, t) : il(e, n.ops, i, t) } return null } function $d(e, n, i, t) { let r = nl(n.ops); for (let o of r) { let s = il(e, o, i, t); if (s !== null) return s } return null } function il(e, n, i, t) { if (n.length === 0) return null; let r = n[0].engine, o = { ...i }, s = [...e.ops], a = 0; for (; a < n.length;) { let u = n[a], l = u.symbol; if (l !== null) { if (l.startsWith("__")) { let f = 0; if (n[a + 1] === void 0) f = s.length + 1; else { let c = !1; for (; !c && f < s.length;)c = Ve(s[f], n[a + 1], o, t) !== null, f += 1; if (!c && l.startsWith("___")) return null } if (!l.startsWith("___") && f <= 1) return null; let d; f <= 1 ? e.head === "Add" ? d = r.Zero : e.head === "Multiply" ? d = r.One : d = r.box(["Sequence"]) : d = r.box([e.head, ...s.splice(0, f - 1)]), o = $r(l, d, o) } else if (l.startsWith("_")) o = $r(l, s.shift(), o); else if (o = Ve(s.shift(), u, o, t), o === null) return null } else { let f = s.shift(); if (!f || (o = Ve(f, u, o, t), o === null)) return null } if (o === null) return null; a += 1 } return s.length > 0 ? null : o } function tl(e, n, i) { let t = Ve(e, n, i.substitution ?? {}, { numericTolerance: i?.numericTolerance ?? tt }); if (t) return t; if (!i.recursive) return null; if (e.ops) { let r = e.ops, o = {}; for (let s = 0; s < r.length; s++) { let a = tl(r[s], n, i); if (a !== null) return a } return o } return null } var Wn = class e extends L { constructor(i, t, r) { super(i, r?.metadata); Ee(t), `${t}${en(t)}`, this._id = t, this._def = r?.def ?? void 0, r?.canonical ?? !0 ? this._def ? this._scope = i.context : this.bind() : this._scope = null } get hash() { return this._hash === void 0 && (this._hash = xe(this._id)), this._hash } get isPure() { return !0 } get json() { let i = this._scope ? this.wikidata : void 0; return yr(this.engine, this._id, { latex: this._latex, wikidata: i }) } get scope() { return this._scope } get isConstant() { let i = this._def ?? this.engine.lookupSymbol(this._id, this.wikidata); return !(i instanceof de) || i.constant } bind() { this._scope = this.engine.context; let i = this.engine.lookupSymbol(this._id) ?? this.engine.lookupFunction(this._id); if (i) { this._def = i; return } this._def = this.engine.defineSymbol(this._id, { domain: void 0, inferred: !0 }), this._id = this._def.name } reset() { this._def?.reset(), this._def = void 0 } get isCanonical() { return this._scope !== null } set isCanonical(i) { this._scope = i ? this.engine.context : null, this._def = void 0 } get canonical() { return this._scope ? this : this.engine.box(this._id) } solve(i) { return i.length !== 1 ? null : i.includes(this.symbol) ? [this.engine.Zero] : null } get complexity() { return 7 } get head() { return "Symbol" } get symbol() { return this._id } get isNothing() { return this._id === "Nothing" } get baseDefinition() { return this._def === void 0 && this.bind(), this._def ?? void 0 } get symbolDefinition() { return this._def === void 0 && this.bind(), this._def instanceof de ? this._def : void 0 } get functionDefinition() { return this._def === void 0 && this.bind(), this._def instanceof We ? this._def : void 0 } infer(i) { let t = this.engine.lookupSymbol(this._id) ?? this.engine.lookupFunction(this._id); if (!t) { let r = this.engine.swapScope(this._scope ?? this.engine.context); return this._def = this.engine.defineSymbol(this._id, { domain: i, inferred: !0 }), this.engine.swapScope(r), !0 } return t instanceof de && t.inferredDomain ? (t.domain = mt(t.domain, i), !0) : !1 } get value() { let i = this._def; if (i && i instanceof de) return i.value?.value } set value(i) { let t = this.engine; t.forget(this._id); let r; if (typeof i == "boolean" && (i = i ? t.True : t.False), typeof i == "string" && (i = t.string(i)), typeof i == "object") if ("re" in i && "im" in i) i = t.complex(i.re, i.im); else if ("num" in i && "denom" in i) i = t.number([i.num, i.denom]); else if (Array.isArray(i)) i = t._fn("List", i.map(s => t.box(s))); else throw new Error(`Invalid value for symbol ${this._id}: ${i}`); if (i !== void 0 && (r = t.box(i).evaluate()), r?.domain?.isFunction) { this.engine.lookupSymbol(this._id), this._def = t.defineFunction(this._id, { signature: { ...ut(r.domain), evaluate: r } }); return } let o = this.engine.lookupSymbol(this._id); if (o && o instanceof de) o.value = r; else { let s = r?.domain; s?.isNumeric && (s = t.Numbers), this._def = t.defineSymbol(this._id, { value: r, domain: s }) } } get domain() { let i = this._def; if (i) { if (i instanceof We) return tr(this.engine, i.signature); if (i instanceof de) return i.domain ?? void 0 } } set domain(i) { if (!this._def) return; if (this._id[0] === "_") throw new Error(`The domain of the wildcard "${this._id}" cannot be changed`); let t = this.engine.domain(i); t.isFunction ? (this.engine.forget(this._id), this._def = this.engine.defineFunction(this._id, { signature: ut(t) })) : this._def instanceof de ? this._def.domain = t : (this.engine.forget(this._id), this._def = this.engine.defineSymbol(this._id, { domain: t })) } get sgn() { let i = this._def; if (!i || !(i instanceof de)) return null; let t = i.value; if (t && t !== this) { let r = t.sgn; if (r !== void 0) return r } if (i.zero === !0) return 0; if (i.positive === !0) return 1; if (i.negative === !0) return -1 } has(i) { return typeof i == "string" ? this._id === i : i.includes(this._id) } isSame(i) { return this === i ? !0 : i instanceof e ? this._id === i._id : !1 } match(i, t) { return i instanceof e && this._id === i._id ? {} : null } isEqual(i) { if (!this.isCanonical) return this.canonical.isEqual(i); if (i = i.canonical, this === i) return !0; if (i.symbol !== null) return i.symbol === this._id; let t = this.symbolDefinition?.value?.N(); if (t) return t.isEqual(i.N()); if (i.isZero) { if (this.isZero) return !0; if (this.isNotZero) return !1 } return this.isZero && i.isNotZero ? !1 : this.engine.ask(["Equal", this, i]).length > 0 ? !0 : (this.engine.ask(["NotEqual", this, i]).length > 0, !1) } isLess(i) { if (i.symbol !== null && i.symbol === this._id) return !1; let t = this.symbolDefinition?.value?.N(); if (t) return t.isLess(i.N()); if (i.isZero) { let r = this.sgn; if (r === null) return !1; if (r !== void 0) return r < 0 } } isLessEqual(i) { if (i.symbol !== null && i.symbol === this._id) return !0; let t = this.symbolDefinition?.value?.N(); if (t) return t.isLessEqual(i.N()); if (i.isZero) { let r = this.sgn; if (r === null) return !1; if (r !== void 0) return r <= 0 } return this.isLess(i) || this.isEqual(i) } isGreater(i) { if (i.symbol !== null && i.symbol === this._id) return !1; let t = this.symbolDefinition?.value?.N(); if (t) return t.isGreater(i.N()); if (i.isZero) { let r = this.sgn; if (r === null) return !1; if (r !== void 0) return r > 0 } } isGreaterEqual(i) { if (i.symbol !== null && i.symbol === this._id) return !0; let t = this.symbolDefinition?.value?.N(); if (t) return t.isGreaterEqual(i.N()); if (i.isZero) { let r = this.sgn; if (r === null) return !1; if (r !== void 0) return r >= 0 } return this.isGreater(i) || this.isEqual(i) } get isFunction() { return !!this.functionDefinition } get isZero() { return this.symbolDefinition?.zero } get isNotZero() { return this.symbolDefinition?.notZero } get isOne() { return this.symbolDefinition?.one } get isNegativeOne() { return this.symbolDefinition?.negativeOne } get isOdd() { return this.symbolDefinition?.odd } get isEven() { return this.symbolDefinition?.even } get isPrime() { return this.symbolDefinition?.prime } get isComposite() { return this.symbolDefinition?.composite } get isInfinity() { return this.symbolDefinition?.infinity } get isNaN() { return this.symbolDefinition?.NaN } get isPositive() { return this.symbolDefinition?.positive } get isNonPositive() { return this.symbolDefinition?.nonPositive } get isNegative() { return this.symbolDefinition?.negative } get isNonNegative() { return this.symbolDefinition?.nonNegative } get isNumber() { return this.symbolDefinition?.number } get isInteger() { return this.symbolDefinition?.integer } get isRational() { return this.symbolDefinition?.rational } get isAlgebraic() { return this.symbolDefinition?.rational } get isReal() { return this.symbolDefinition?.real } get isExtendedReal() { return this.symbolDefinition?.extendedReal } get isComplex() { return this.symbolDefinition?.complex } get isImaginary() { return this.symbolDefinition?.imaginary } simplify(i) { let t = this.symbolDefinition; return t?.holdUntil === "simplify" && t.value ? t.value.simplify(i) : i?.rules ? this.replace(i.rules) ?? this : this } evaluate(i) { let t = this.symbolDefinition; if (t) { if (i?.numericMode) return t.holdUntil === "never" ? this : t.value?.N(i) ?? this; if (t.holdUntil === "simplify" || t.holdUntil === "evaluate") return t.value?.evaluate(i) ?? this } return this } N(i) { let t = this.symbolDefinition; return t && t.holdUntil === "never" ? this : t?.value?.N(i) ?? this } replace(i, t) { return rr(this, i, t) } subs(i, t) { return i[this._id] === void 0 ? t?.canonical ? this.canonical : this : this.engine.box(i[this._id], t) } }; function gs(e, n) { let i = e.lookupSymbol(n); return i?.holdUntil === "never" && i.value ? i.value : new Wn(e, n, { canonical: !0, def: i }) } var Dt = "\x1B[0m"; var rl = "\x1B[33m"; var ol = "\x1B[36;1m", xs = "\x1B[101;97m"; var ji = class e {
      constructor(n) { this._cache = {}; this._commonSymbols = { True: null, False: null, All: null, Nothing: null, None: null, Undefined: null, Pi: null, ImaginaryUnit: null, ExponentialE: null }; this._commonNumbers = { "-5": null, "-4": null, "-3": null, "-2": null, 2: null, 3: null, 4: null, 5: null, 6: null, 7: null, 8: null, 9: null, 10: null, 11: null, 12: null, 36: null }; this._commonDomains = { Anything: null, Void: null, NothingDomain: null, Booleans: null, Strings: null, Domains: null, Symbols: null, Integers: null, RationalNumbers: null, AlgebraicNumbers: null, RealNumbers: null, ExtendedRealNumbers: null, ImaginaryNumbers: null, ComplexNumbers: null, ExtendedComplexNumbers: null, Numbers: null, PositiveIntegers: null, TranscendentalNumbers: null, PositiveNumbers: null, Functions: null, NumericFunctions: null, RealFunctions: null, LogicOperators: null, Predicates: null }; if (n !== void 0 && typeof n != "object") throw Error("Unexpected argument"); this.strict = !0, this._jsonSerializationOptions = { exclude: [], shorthands: ["function", "symbol", "string", "dictionary", "number"], metadata: [], precision: "max", repeatingDecimals: !0 }, this._useRawJsonSerializationOptions = !1, this._rawJsonSerializationOptions = { exclude: [], shorthands: ["function", "symbol", "string", "dictionary", "number"], metadata: [], precision: "max", repeatingDecimals: !1 }, this._stats = { highwaterMark: 0, symbols: new Set, expressions: new Set }, this._numericMode = n?.numericMode ?? "auto", this._precision = Math.max(n?.numericPrecision ?? 100, Math.floor(ei)), this._bignum = v.clone({ precision: this._precision }), this.tolerance = n?.tolerance ?? tt, this.Zero = new le(this, 0), this.One = new le(this, 1), this.Half = new le(this, [1, 2]), this.NegativeOne = new le(this, -1), this.NaN = new le(this, Number.NaN), this.PositiveInfinity = new le(this, Number.POSITIVE_INFINITY), this.NegativeInfinity = new le(this, Number.NEGATIVE_INFINITY), this.I = new le(this, Gi.Complex.I), this.ComplexInfinity = new le(this, Gi.Complex.INFINITY), this.reset(), this.context = { assumptions: new Ui, timeLimit: 2, memoryLimit: 1, recursionLimit: 1024, iterationLimit: Number.POSITIVE_INFINITY }; for (let t of e.getStandardLibrary("domains")) cs(this, t); for (let t of Object.keys(this._commonDomains)) this._commonDomains[t] && !this._commonDomains[t].symbolDefinition ? this._commonDomains[t].bind() : this._commonDomains[t] = new Dn(this, or[t] ?? t); this.Anything = this._commonDomains.Anything, this.Void = this._commonDomains.Void, this.Strings = this._commonDomains.Strings, this.Booleans = this._commonDomains.Booleans, this.Numbers = this._commonDomains.Numbers; let i = n?.ids ?? e.getStandardLibrary(); for (let t of i) cs(this, t); for (let t of Object.keys(this._commonSymbols)) { let r = new Wn(this, t, { canonical: !0 }); r.bind(), this._commonSymbols[t] = r } this.True = this._commonSymbols.True, this.False = this._commonSymbols.False, this.Pi = this._commonSymbols.Pi, this.E = this._commonSymbols.ExponentialE, this.Nothing = this._commonSymbols.Nothing, this.pushScope() } static getStandardLibrary(n = "all") { return ds(n) } get latexDictionary() { return this.latexSyntax.dictionary } set latexDictionary(n) { this.latexSyntax.dictionary = n } reset() { this._bignum, this._BIGNUM_NEGATIVE_ONE = this.bignum(-1), this._BIGNUM_NAN = this.bignum(NaN), this._BIGNUM_ZERO = this.bignum(0), this._BIGNUM_ONE = this.bignum(1), this._BIGNUM_TWO = this.bignum(2), this._BIGNUM_HALF = this._BIGNUM_ONE.div(this._BIGNUM_TWO), this._BIGNUM_PI = this._BIGNUM_NEGATIVE_ONE.acos(); let n = this._stats.symbols.values(), i = this._stats.expressions.values(); this._stats.symbols = new Set, this._stats.expressions = new Set; for (let r of n) r.reset(); for (let r of i) r.reset(); for (let r of Object.values(this._commonDomains)) r?.reset(); for (let r of Object.values(this._commonSymbols)) r?.reset(); let t = this.context; for (; t;) { if (t.ids) for (let [r, o] of t.ids) o.reset(); t = t.parentScope ?? null } for (let r of Object.keys(this._cache)) this._cache[r].value && (this._cache[r].purge ? this._cache[r].value = this._cache[r].purge(this._cache[r].value) : delete this._cache[r]) } _register(n) { this._stats.highwaterMark += 1 } _unregister(n) { } get stats() { let n = this._stats.expressions; return this._stats.expressions = null, this._stats.expressions = n, { ...this._stats } } get precision() { return this._numericMode === "machine" || this._numericMode === "complex" ? Math.floor(ei) : this._precision } set precision(n) { n === "machine" && (n = Math.floor(ei)); let i = this._precision; if (n !== i) { if (typeof n != "number" || n <= 0) throw Error('Expected "machine" or a positive number'); this._latexSyntax?.updateOptions({ precision: n, avoidExponentsInRange: [-6, n] }), this._precision = Math.max(n, Math.floor(ei)), this.jsonSerializationOptions.precision > this._precision && (this.jsonSerializationOptions = { precision: this._precision }), this._numericMode !== "auto" && this._numericMode !== "bignum" && this._precision > Math.floor(ei) && (this._numericMode = "auto"), this._bignum = this._bignum.config({ precision: this._precision }), this.reset() } } get numericMode() { return this._numericMode } set numericMode(n) { if (n !== this._numericMode) { if (typeof n != "string") throw Error("Expected a string"); this._numericMode = n, (n === "complex" || n === "machine") && (this._precision = Math.floor(ei)), this._latexSyntax && this.latexSyntax.options.precision > this._precision && this.latexSyntax.updateOptions({ precision: this._precision }), this.jsonSerializationOptions.precision > this._precision && (this.jsonSerializationOptions = { precision: this._precision }), this.reset() } } get timeLimit() { let n = this.context; for (; n;) { if (n.timeLimit !== void 0) return n.timeLimit; n = n.parentScope ?? null } return 2 } get iterationLimit() { let n = this.context; for (; n;) { if (n.iterationLimit !== void 0) return n.iterationLimit; n = n.parentScope ?? null } return 1024 } get recursionLimit() { let n = this.context; for (; n;) { if (n.recursionLimit !== void 0) return n.recursionLimit; n = n.parentScope ?? null } return 1024 } get tolerance() { return this._tolerance } set tolerance(n) { typeof n == "number" && Number.isFinite(n) ? this._tolerance = Math.max(n, 0) : this._tolerance = tt, this._bignumTolerance = this.bignum(this._tolerance) } chop(n) { return typeof n == "number" && Math.abs(n) <= this._tolerance || n instanceof v && n.abs().lte(this._bignumTolerance) || n instanceof Gi.Complex && Math.abs(n.re) <= this._tolerance && Math.abs(n.im) <= this._tolerance ? 0 : n } bignum(n) { if (typeof n == "bigint") return new this._bignum(n.toString()); try { return new this._bignum(n) } catch (i) { console.error(i) } return this._BIGNUM_NAN } complex(n, i) { return n instanceof v && (n = n.toNumber()), i instanceof v && (i = i.toNumber()), new Gi.Complex(n, i) } isBignum(n) { return n instanceof v } isComplex(n) { return n instanceof Gi.Complex } get latexSyntax() { if (!this._latexSyntax) { let n = this.precision; this._latexSyntax = new it({ computeEngine: this, precision: n, avoidExponentsInRange: [-6, n], onError: i => { throw new Error(JSON.stringify(i[0].message)) } }) } return this._latexSyntax } static getLatexDictionary(n = "all") { return it.getDictionary(n) } set costFunction(n) { typeof n != "function" && (this._cost = hs), this._cost = n } get costFunction() { return this._cost ?? hs } lookupSymbol(n, i, t) { if (!this.strict) { for (t ?? (t = this.context ?? void 0); t;) { let o = t.ids?.get(n); if (o && o instanceof de) return o; t = t.parentScope } return } if (typeof n != "string") throw Error("Expected a string"); if (n.length === 0 || !this.context) return; let r = t ?? this.context; if (i) for (t = r; t;) { if (t.ids) { for (let [o, s] of t.ids) if (s instanceof de && s.wikidata === i) return s } t = t.parentScope } for (t = r; t;) { let o = t.ids?.get(n); if (o instanceof de) return o; t = t.parentScope } } lookupFunction(n, i) { if (typeof n == "string" && this.context) for (i ?? (i = this.context); i;) { let t = i.ids?.get(n); if (t instanceof We) return t; i = i.parentScope } } defineSymbol(n, i) { if (!this.context) throw Error("Symbol cannot be defined: no scope available"); if (n.length === 0 || !Ee(n)) throw Error(`Invalid identifier "${n}": ${en(n)}}`); return this._defineSymbol(n, i) } _defineSymbol(n, i) { var r; (r = this.context).ids ?? (r.ids = new Map); let t = new de(this, n, i); return t.name && this.context.ids.set(t.name, t), t } defineFunction(n, i) { if (!this.context) throw Error("Function cannot be defined: no scope available"); if (n.length === 0 || !Ee(n)) throw Error(`Invalid identifier "${n}": ${en(n)}}`); return this._defineFunction(n, i) } _defineFunction(n, i) { var r; (r = this.context).ids ?? (r.ids = new Map); let t = Rr(this, n, i); return t.name && this.context.ids.set(t.name, t), t } pushScope(n) { if (this.context === null) throw Error("No parent scope available"); return this.context = { timeLimit: this.context.timeLimit, memoryLimit: this.context.memoryLimit, recursionLimit: this.context.recursionLimit, iterationLimit: this.context.iterationLimit, ...n ?? {}, parentScope: this.context, assumptions: new Ui(this.context.assumptions) }, this } popScope() { if (!this.context) throw Error("No scope available"); return this.context = this.context.parentScope ?? null, this.context, this } swapScope(n) { let i = this.context; return this.context = n, this.context, i } resetContext() { if (this.context) { for (let [n, i] of this.context.ids ?? []) if (i instanceof de) i.constant || (i.value = void 0); else if (i instanceof We) { let t = i.signature; i.signature = { ...t, evaluate: void 0, N: void 0, simplify: void 0, canonical: void 0 } } } } _printScope(n, i, t = 0) { if (n ?? (n = { details: !1, maxDepth: 1 }), i ?? (i = this.context), !i || n.maxDepth && t > n.maxDepth) return null; let r = `${rl}[undefined]${Dt}`; if (t === 0 ? console.group("current scope - level 0") : console.groupCollapsed(i.parentScope ? `scope - level ${t}` : `root scope - level ${t}`), i.ids) { let o = 0; for (let [s, a] of i.ids) { let u = `${ol}${s}${Dt}`; try { if (a instanceof de) { let l = a.value?.isValid ? a.value.toString() : a.value ? `${xs}${a.value.toString()}${Dt}` : r; console.info(`${u}: ${a.domain?.toString() ?? r} = ${l}`) } else a instanceof We && (typeof a.signature.evaluate == "function" ? console.info(`${u}(): ${n.details ? a.signature.evaluate.toString() : "[native-code]"}`) : a.signature.evaluate === void 0 ? console.info(`${u}(): ${r}`) : console.info(`${u}(): ${a.toString()}`)); o === 11 && console.groupCollapsed(`... and ${i.ids.size - o} more`), o += 1 } catch (l) { console.info(`${u}: ${xs}${l.message}${Dt}`) } } o >= 11 && console.groupEnd() } if (i.assumptions) { let o = [...i.assumptions.entries()].map(([s, a]) => `${s}: ${a}`); if (o.length > 0) { console.groupCollapsed(`${o.length} assumptions)`); for (let s of o) console.info(s); console.groupEnd() } } return i.parentScope && this._printScope(n, i.parentScope, t + 1), console.groupEnd(), this.context } declare(n, i) { if (typeof n != "string" || i === void 0) { for (let [s, a] of Object.entries(n)) this.declare(s, a); return this } let [t, r] = Jo(n); if (r !== void 0) throw Error(`Unexpected arguments with ${n}. Use 'ce.assign()' instead to assign a value, or a use a function definition with 'ce.declare()'.`); if (t === "Nothing") return this; if (this.context?.ids?.get(t)) { let s = this.context.ids.get(t); if (s instanceof de && s.inferredDomain) return Lr(i) ? s.update(i) : (s.domain = this.domain(i), s.inferredDomain = !1), this; throw Error(`Symbol "${t}" has already been declared in the current scope`) } let o = i; if (!o) throw Error(`Expected a definition for ${t}`); if (Lr(o)) return this.defineSymbol(t, o), this; if (ms(o)) return this.defineFunction(t, o), this; { let s = this.domain(o); if (s.isValid) if (s.isFunction) this.defineFunction(t, { signature: ut(s) }); else { if (r) throw Error(`Unexpected arguments with domain for "${t}"`); this.defineSymbol(t, { domain: s }) } else throw Error(`Invalid argument for "${t}": use a domain, a FunctionDefinition or a SymbolDefinition`) } return this } assign(n, i) { if (typeof n == "object") { for (let [u, l] of Object.entries(n)) this.assign(u, l); return this } let [t, r] = Jo(n); if (t === "Nothing") return this; let o = i; if (typeof o == "boolean" && (o = o ? this.True : this.False), typeof o == "string") { let u = o.trim(); u.startsWith("$") && u.endsWith("$") ? o = this.parse(u.slice(1, -1), { canonical: !1 }) : u.startsWith("$$") && u.endsWith("$$") ? o = this.parse(u.slice(2, -2), { canonical: !1 }) : o = this.string(o) } let s = this.lookupSymbol(t); if (s) { if (s.constant) throw Error(`Cannot assign a value to the constant "${t}"`); if (!s.inferredDomain && bs(o)) throw Error(`Cannot assign a function to symbol "${t}"`); let u = s.scope; if (u?.ids?.delete(s.name), !r && !bs(o)) return o == null ? s.value = void 0 : s.value = this.box(o), u?.ids?.set(s.name, s), this } let a = this.lookupFunction(t); if (a) { let u = a.scope; if (u?.ids?.delete(a.name), o == null) return this; if (typeof o == "function") { let d = this.swapScope(u); return this.defineFunction(t, { signature: { evaluate: o } }), this.swapScope(d), this } if (r && bs(o)) throw Error(`Unexpected arguments for "${t}"`); let l = r ? this.box(["Function", o, ...r]) : this.box(o), f = this.swapScope(u); return this.defineFunction(t, { signature: { evaluate: l } }), this.swapScope(f), this } if (o == null) return this.declare(t, { inferred: !0, domain: this.Anything }), this; if (typeof o == "function") return this.defineFunction(t, { signature: { evaluate: o } }), this; if (o instanceof L && o.domain?.base === "Functions") return this.defineFunction(t, { signature: { evaluate: o } }), this; if (Array.isArray(o) || o instanceof L || r) { let u = this.box(o, { canonical: !1 }); if (u.head === "Function") return u = this.box(["Function", ...u.ops, ...(r ?? []).map(f => this.symbol(f))]), this.defineFunction(t, { signature: { evaluate: u } }), this; let l = [...u.unknowns].sort(); if (l.length === 0) { let f = u.evaluate(); return this.defineSymbol(t, { value: f }), this } if (l.some(f => /\_[\d]+/.test(f))) return u = this.box(["Function", u]), this.defineFunction(t, { signature: { evaluate: u } }), this; if (r && r.length > 0) return this.pushScope(), u = this.box(["Function", u, ...r]), this.popScope(), this.defineFunction(t, { signature: { evaluate: u } }), this; this.pushScope(), o = u.evaluate(), this.popScope() } return this.defineSymbol(t, { value: o }), this } _assign(n, i) { let t = this.lookupSymbol(n); if (t) return t.value = this.box(i).evaluate(), this; let r = this.lookupFunction(n); if (r) { let o = r.signature; return r.signature = { ...o, N: void 0, simplify: void 0, canonical: void 0, evaluate: i }, this } return `${n}`, this } get assumptions() { if (!this.context) throw Error("No scope available"); return this.context.assumptions ? this.context.assumptions : (this.context.assumptions = new Ui, this.context.assumptions) } shouldContinueExecution() { return this.deadline === void 0 || this.deadline >= Date.now() } checkContinueExecution() { if (!this.shouldContinueExecution()) throw new Error("timeout") } cache(n, i, t) {
        if (this._cache[n] === void 0) try { this._cache[n] = { build: i, purge: t, value: i() } } catch (r) {
          console.error(`Fatal error building cache "${n}":
	 ${r.toString()}`)
        } return this._cache[n]?.value
      } canonical(n) { if (!n.every(t => t instanceof L)) return n.map(t => this.box(t)); let i = n; return i.every(t => t.isCanonical) ? i : i.map(t => t.canonical) } box(n, i) { return we(this, n, i) } function(n, i, t) { return t ?? (t = {}), "canonical" in t || (t.canonical = !0), Tt(this, n, i, t) } error(n, i) { i instanceof L ? i = this.rawJson(i) : i && Array.isArray(i) && i[0] === "LatexString" && ((i[1] === void 0 || !i[1]) && (i = ""), typeof i[1] == "object" && "str" in i[1] && !i[1].str && (i = "")); let t; return typeof n == "string" && (t = this.string(n)), !t && typeof n != "string" && (t = new be(this, "ErrorCode", [this.string(n[0]), ...n.slice(1).map(r => this.box(r, { canonical: !1 }))])), i ? new be(this, "Error", [t, this.box(i, { canonical: !1 })], { canonical: !1 }) : new be(this, "Error", [t], { canonical: !1 }) } domainError(n, i, t) { let r = mn(n) ? this.domain(n) : this.symbol(n), o = i || this.symbol("Undefined"); return this.error(["incompatible-domain", r, o], t) } hold(n) { return this._fn("Hold", [this.box(n, { canonical: !1 })]) } add(...n) { return xt(this, te(se(n), "Add")) } neg(n) { return bt(n.canonical) } mul(...n) { let i = te(se(n), "Multiply"); return vt(this, i) } div(n, i) { return vr(this, n.canonical, i.canonical) } sqrt(n) { return Ri(this, n, "evaluate") ?? this._fn("Power", [n, this.Half]) } pow(n, i) { return (typeof i == "number" || U(i)) && (i = this.number(i)), kn(this, n, i) } inv(n) { if (n.isOne) return this.One; if (n.isNegativeOne) return this.NegativeOne; if (n.isInfinity) return this.Zero; let i = n.numericValue; if (i !== null) return U(i) ? this.number(Tn(i)) : typeof i == "number" && Number.isInteger(i) ? this.number([1, i]) : i instanceof v && i.isInteger() ? this.number([BigInt(1), P(i)]) : this._fn("Divide", [this.One, n]); if (n.head === "Sqrt") return this._fn("Sqrt", [this.inv(n.op1)]); if (n.head === "Divide") return this._fn("Divide", [n.op1, n.op2]); let t = this.NegativeOne; if (n.head === "Power") { if (n.op2.isNegativeOne) return n.op1; t = ge(n.op2), n = n.op1 } return t.isNegativeOne ? this._fn("Divide", [this.One, n]) : this._fn("Power", [n, t]) } pair(n, i, t) { return new be(this, "Tuple", [n.canonical, i.canonical], { metadata: t, canonical: !0 }) } tuple(n, i) { return new be(this, "Tuple", me(n.map(t => typeof t == "number" ? this.number(t) : t.canonical)), { metadata: i, canonical: !0 }) } array(n, i) { return this.Nothing } string(n, i) { return new gn(this, n, i) } symbol(n, i) { if (i = i ? { ...i } : {}, "canonical" in i || (i.canonical = !0), n = n.normalize(), n === "NaN") return this.NaN; if (n === "Infinity") return this.PositiveInfinity; if (n === "+Infinity") return this.PositiveInfinity; if (n === "-Infinity") return this.NegativeInfinity; if (n === "Half") return this.Half; if (this.strict && !Ee(n)) { let r = i?.metadata?.latex, o = `'${n}'`; return this.error(["invalid-identifier", { str: en(n) }], r ? ["LatexString", `'${r}'`] : o) } if (i?.metadata?.latex !== void 0 && !i.canonical) return new Wn(this, n, i); let t = this._commonSymbols[n]; return t ? !i?.metadata?.wikidata || !t.wikidata || t.wikidata === i.metadata.wikidata ? t : i.canonical ? gs(this, n) : new Wn(this, n, i) : i.canonical ? gs(this, n) : new Wn(this, n, i) } domain(n, i) { if (n instanceof Dn) return n; if (typeof n == "string") { let r = this._commonDomains[n]; if (r) return r } if (!this.strict) { if (typeof n == "string") { let r = or[n]; if (r) return this.domain(r) } return new Dn(this, n, i) } if (Array.isArray(n) && n[0] === "Domain" && (n = n[1]), typeof n == "string") { let r = or[n]; if (r) return this.domain(r); if (!ri(n)) throw Error("Expected a domain literal, got " + n); return new Dn(this, n, i) } if (!Array.isArray(n) || n.length === 0) throw Error("Expected a valid domain"); let t = n[0]; if (!ki.includes(t)) throw Error("Expected a domain constructor, got " + t); return new Dn(this, n, i) } number(n, i) { if (i = i ? { ...i } : {}, "canonical" in i || (i.canonical = !0), i.metadata === void 0) { if (typeof n == "bigint") { if (n === BigInt(1)) return this.One; if (n === BigInt(0)) return this.Zero; if (n === BigInt(-1)) return this.NegativeOne } if (typeof n == "number") { let t = n; if (t === 1) return this.One; if (t === 0) return this.Zero; if (t === -1) return this.NegativeOne; if (Number.isInteger(t) && this._commonNumbers[t] !== void 0) return this._commonNumbers[t] === null && (this._commonNumbers[t] = Ir(this, n) ?? this.NaN), this._commonNumbers[t]; if (Number.isNaN(t)) return this.NaN; if (!Number.isFinite(t)) return t < 0 ? this.NegativeInfinity : this.PositiveInfinity } } return typeof n == "bigint" && (n = this.bignum(n)), Ir(this, n, i) ?? this.NaN } rules(n) { return ti(this, n) } pattern(n) { return new Vr(this, n) } _fn(n, i, t) { return new be(this, n, i, { metadata: t, canonical: !0 }) } parse(n, i) { if (typeof n != "string") return null; let t = this.latexSyntax.parse(Ii(n) ?? n); return this.box(t, i) } serialize(n, i) { if (typeof n == "object" && "json" in n) { let t = "engine" in n ? n.engine : this; return this.latexSyntax.serialize(this.rawJson(t.box(n, { canonical: !1 })), i) } return this.latexSyntax.serialize(n, i) } get latexOptions() { let n = this.latexSyntax; return new Proxy({ ...this.latexSyntax.options, ...this.latexSyntax.serializer.options }, { set(i, t, r) { return t in i ? (n.updateOptions({ [t]: r }), !0) : !1 } }) } set latexOptions(n) { this.latexSyntax.updateOptions(n) } get jsonSerializationOptions() { if (this._useRawJsonSerializationOptions) return new Proxy(this._rawJsonSerializationOptions, { get(i, t) { if (t in i) return i[t] } }); let n = this; return new Proxy(this._jsonSerializationOptions, { get(i, t) { if (t in i) return i[t] }, set(i, t, r) { return t in i ? (n.jsonSerializationOptions = { [t]: r }, !0) : !1 } }) } set jsonSerializationOptions(n) { n.exclude && (this._jsonSerializationOptions.exclude = [...n.exclude]), n.shorthands && (n.shorthands === "all" || n.shorthands.includes("all") ? this._jsonSerializationOptions.shorthands = ["function", "symbol", "string", "dictionary", "number"] : this._jsonSerializationOptions.shorthands = [...n.shorthands]), n.metadata && (n.metadata === "all" || n.metadata.includes("all") ? this._jsonSerializationOptions.metadata = ["latex", "wikidata"] : this._jsonSerializationOptions.metadata = [...n.metadata]), typeof n.precision == "number" && n.precision > 0 && (this._jsonSerializationOptions.precision = n.precision), typeof n.repeatingDecimals == "boolean" && (this._jsonSerializationOptions.repeatingDecimals = n.repeatingDecimals) } rawJson(n) { let i = this._useRawJsonSerializationOptions; this._useRawJsonSerializationOptions = !0; let t = n.json; return this._useRawJsonSerializationOptions = i, t } ask(n) { let i = this.pattern(n), t = []; for (let [r, o] of this.assumptions) { let s = i.match(r, { numericTolerance: this._tolerance }); s !== null && o === !0 && t.push(s) } return t } verify(n) { return !1 } assume(n) { try { return uu(this.box(n, { canonical: !1 })) } catch (i) { return console.error(i.toString()), "internal-error" } } forget(n) { if (!this.context) throw Error("No scope available"); if (n === void 0) { if (this.context.ids) for (let i of this.context.ids.keys()) this.forget(i); this.assumptions.clear(); return } if (Array.isArray(n)) { for (let i of n) this.forget(i); return } if (typeof n == "string") { if (this.context.ids) { let i = this.context.ids.get(n); if (i instanceof de) i.value = void 0; else if (i instanceof We) { let t = i.signature; i.signature = { ...t, evaluate: void 0, N: void 0, simplify: void 0, canonical: void 0 } } } for (let [i, t] of this.assumptions) i.symbols.includes(n) && this.assumptions.delete(i) } }
    }; function bs(e) { return typeof e == "function" || e instanceof L && e.domain?.base === "Functions" } var zd = "0.23.0"; globalThis[Symbol.for("io.cortexjs.compute-engine")] = { ComputeEngine: ji.prototype.constructor, version: "0.23.0" }; return ml(Ud);
  })();
  /*! Bundled license information:
  
  complex.js/complex.js:
    (**
     * @license Complex.js v2.1.1 12/05/2020
     *
     * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
     * Dual licensed under the MIT or GPL Version 2 licenses.
     **)
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
  Object.assign(exports, ComputeEngine); Object.defineProperty(exports, '__esModule', { value: true });
}));
